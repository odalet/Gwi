// This file is auto generated, do not edit.
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Gwi.OpenGL.GLES3
{
#pragma warning disable IDE1006 // Naming Styles

    public static class NVOverloads
    {
        // CreateSemaphoresNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateSemaphoresNV(this GL.NVExtension glInstance, Span<uint> semaphores)
        {
            var n = (int)(semaphores.Length);
            fixed (uint* semaphores_ptr = semaphores) // SpanOrArrayLayer
            {
                glInstance.CreateSemaphoresNV(n, semaphores_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateSemaphoresNV(this GL.NVExtension glInstance, uint[] semaphores)
        {
            var n = (int)(semaphores.Length);
            fixed (uint* semaphores_ptr = semaphores) // SpanOrArrayLayer
            {
                glInstance.CreateSemaphoresNV(n, semaphores_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CreateSemaphoresNV(this GL.NVExtension glInstance, int n, ref uint semaphores)
        {
            fixed (uint* semaphores_ptr = &semaphores) // RefInsteadOfPointerLayer
            {
                glInstance.CreateSemaphoresNV(n, semaphores_ptr);
            }
        }

        // SemaphoreParameterivNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SemaphoreParameterivNV(this GL.NVExtension glInstance, uint semaphore, SemaphoreParameterName pname, in int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.SemaphoreParameterivNV(semaphore, pname, parameters_ptr);
            }
        }

        // GetSemaphoreParameterivNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetSemaphoreParameterivNV(this GL.NVExtension glInstance, uint semaphore, SemaphoreParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetSemaphoreParameterivNV(semaphore, pname, parameters_ptr);
            }
        }

        // GetImageHandleNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe ulong GetImageHandleNV(this GL.NVExtension glInstance, TextureHandle texture, int level, bool layered, int layer, PixelFormat format)
        {
            ulong returnValue;
            var layered_byte = (byte)(layered ? 1 : 0);
            returnValue = glInstance.GetImageHandleNV(texture, level, layered_byte, layer, format);
            return returnValue;
        }

        // UniformHandleui64vNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformHandleui64vNV(this GL.NVExtension glInstance, int location, ReadOnlySpan<ulong> value)
        {
            var count = (int)(value.Length);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.UniformHandleui64vNV(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformHandleui64vNV(this GL.NVExtension glInstance, int location, ulong[] value)
        {
            var count = (int)(value.Length);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.UniformHandleui64vNV(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformHandleui64vNV(this GL.NVExtension glInstance, int location, int count, in ulong value)
        {
            fixed (ulong* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.UniformHandleui64vNV(location, count, value_ptr);
            }
        }

        // ProgramUniformHandleui64vNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformHandleui64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<ulong> values)
        {
            var count = (int)(values.Length);
            fixed (ulong* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.ProgramUniformHandleui64vNV(program, location, count, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformHandleui64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, ulong[] values)
        {
            var count = (int)(values.Length);
            fixed (ulong* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.ProgramUniformHandleui64vNV(program, location, count, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformHandleui64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, int count, in ulong values)
        {
            fixed (ulong* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniformHandleui64vNV(program, location, count, values_ptr);
            }
        }

        // CoverageMaskNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void CoverageMaskNV(this GL.NVExtension glInstance, bool mask)
        {
            var mask_byte = (byte)(mask ? 1 : 0);
            glInstance.CoverageMaskNV(mask_byte);
        }

        // DrawBuffersNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DrawBuffersNV(this GL.NVExtension glInstance, ReadOnlySpan<GLEnum> bufs)
        {
            var n = (int)(bufs.Length);
            fixed (GLEnum* bufs_ptr = bufs) // SpanOrArrayLayer
            {
                glInstance.DrawBuffersNV(n, bufs_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DrawBuffersNV(this GL.NVExtension glInstance, GLEnum[] bufs)
        {
            var n = (int)(bufs.Length);
            fixed (GLEnum* bufs_ptr = bufs) // SpanOrArrayLayer
            {
                glInstance.DrawBuffersNV(n, bufs_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DrawBuffersNV(this GL.NVExtension glInstance, int n, in GLEnum bufs)
        {
            fixed (GLEnum* bufs_ptr = &bufs) // RefInsteadOfPointerLayer
            {
                glInstance.DrawBuffersNV(n, bufs_ptr);
            }
        }

        // DrawElementsInstancedNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void DrawElementsInstancedNV(this GL.NVExtension glInstance, PrimitiveType mode, int count, PrimitiveType type, nint offset, int primcount)
        {
            void* indices = (void*)offset;
            glInstance.DrawElementsInstancedNV(mode, count, type, indices, primcount);
        }

        // GetVkProcAddrNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe IntPtr GetVkProcAddrNV(this GL.NVExtension glInstance, string name)
        {
            IntPtr returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = glInstance.GetVkProcAddrNV(name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }

        // DeleteFencesNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteFencesNV(this GL.NVExtension glInstance, ReadOnlySpan<uint> fences)
        {
            var n = (int)(fences.Length);
            fixed (uint* fences_ptr = fences) // SpanOrArrayLayer
            {
                glInstance.DeleteFencesNV(n, fences_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteFencesNV(this GL.NVExtension glInstance, uint[] fences)
        {
            var n = (int)(fences.Length);
            fixed (uint* fences_ptr = fences) // SpanOrArrayLayer
            {
                glInstance.DeleteFencesNV(n, fences_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteFencesNV(this GL.NVExtension glInstance, int n, in uint fences)
        {
            fixed (uint* fences_ptr = &fences) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteFencesNV(n, fences_ptr);
            }
        }

        // GenFencesNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenFencesNV(this GL.NVExtension glInstance, Span<uint> fences)
        {
            var n = (int)(fences.Length);
            fixed (uint* fences_ptr = fences) // SpanOrArrayLayer
            {
                glInstance.GenFencesNV(n, fences_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenFencesNV(this GL.NVExtension glInstance, uint[] fences)
        {
            var n = (int)(fences.Length);
            fixed (uint* fences_ptr = fences) // SpanOrArrayLayer
            {
                glInstance.GenFencesNV(n, fences_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenFencesNV(this GL.NVExtension glInstance, int n, ref uint fences)
        {
            fixed (uint* fences_ptr = &fences) // RefInsteadOfPointerLayer
            {
                glInstance.GenFencesNV(n, fences_ptr);
            }
        }

        // GetFenceivNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetFenceivNV(this GL.NVExtension glInstance, uint fence, FenceParameterNameNV pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetFenceivNV(fence, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetFenceivNV(this GL.NVExtension glInstance, uint fence, FenceParameterNameNV pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetFenceivNV(fence, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetFenceivNV(this GL.NVExtension glInstance, uint fence, FenceParameterNameNV pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetFenceivNV(fence, pname, parameters_ptr);
            }
        }

        // RasterSamplesEXT overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void RasterSamplesEXT(this GL.NVExtension glInstance, uint samples, bool fixedsamplelocations)
        {
            var fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
            glInstance.RasterSamplesEXT(samples, fixedsamplelocations_byte);
        }

        // CoverageModulationTableNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CoverageModulationTableNV(this GL.NVExtension glInstance, ReadOnlySpan<float> v)
        {
            var n = (int)(v.Length);
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.CoverageModulationTableNV(n, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CoverageModulationTableNV(this GL.NVExtension glInstance, float[] v)
        {
            var n = (int)(v.Length);
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.CoverageModulationTableNV(n, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CoverageModulationTableNV(this GL.NVExtension glInstance, int n, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.CoverageModulationTableNV(n, v_ptr);
            }
        }

        // GetCoverageModulationTableNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetCoverageModulationTableNV(this GL.NVExtension glInstance, int bufSize, ref float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.GetCoverageModulationTableNV(bufSize, v_ptr);
            }
        }

        // Uniform1i64vNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1i64vNV(this GL.NVExtension glInstance, int location, ReadOnlySpan<long> value)
        {
            var count = (int)(value.Length / 1);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1i64vNV(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1i64vNV(this GL.NVExtension glInstance, int location, long[] value)
        {
            var count = (int)(value.Length / 1);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1i64vNV(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform1i64vNV(this GL.NVExtension glInstance, int location, int count, in long value)
        {
            fixed (long* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform1i64vNV(location, count, value_ptr);
            }
        }

        // Uniform2i64vNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2i64vNV(this GL.NVExtension glInstance, int location, ReadOnlySpan<long> value)
        {
            var count = (int)(value.Length / 2);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2i64vNV(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2i64vNV(this GL.NVExtension glInstance, int location, long[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2i64vNV(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform2i64vNV(this GL.NVExtension glInstance, int location, int count, in long value)
        {
            fixed (long* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform2i64vNV(location, count, value_ptr);
            }
        }

        // Uniform3i64vNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3i64vNV(this GL.NVExtension glInstance, int location, ReadOnlySpan<long> value)
        {
            var count = (int)(value.Length / 3);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3i64vNV(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3i64vNV(this GL.NVExtension glInstance, int location, long[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3i64vNV(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform3i64vNV(this GL.NVExtension glInstance, int location, int count, in long value)
        {
            fixed (long* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform3i64vNV(location, count, value_ptr);
            }
        }

        // Uniform4i64vNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4i64vNV(this GL.NVExtension glInstance, int location, ReadOnlySpan<long> value)
        {
            var count = (int)(value.Length / 4);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4i64vNV(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4i64vNV(this GL.NVExtension glInstance, int location, long[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4i64vNV(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform4i64vNV(this GL.NVExtension glInstance, int location, int count, in long value)
        {
            fixed (long* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform4i64vNV(location, count, value_ptr);
            }
        }

        // Uniform1ui64vNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1ui64vNV(this GL.NVExtension glInstance, int location, ReadOnlySpan<ulong> value)
        {
            var count = (int)(value.Length / 1);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1ui64vNV(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1ui64vNV(this GL.NVExtension glInstance, int location, ulong[] value)
        {
            var count = (int)(value.Length / 1);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1ui64vNV(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform1ui64vNV(this GL.NVExtension glInstance, int location, int count, in ulong value)
        {
            fixed (ulong* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform1ui64vNV(location, count, value_ptr);
            }
        }

        // Uniform2ui64vNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2ui64vNV(this GL.NVExtension glInstance, int location, ReadOnlySpan<ulong> value)
        {
            var count = (int)(value.Length / 2);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2ui64vNV(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2ui64vNV(this GL.NVExtension glInstance, int location, ulong[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2ui64vNV(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform2ui64vNV(this GL.NVExtension glInstance, int location, int count, in ulong value)
        {
            fixed (ulong* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform2ui64vNV(location, count, value_ptr);
            }
        }

        // Uniform3ui64vNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3ui64vNV(this GL.NVExtension glInstance, int location, ReadOnlySpan<ulong> value)
        {
            var count = (int)(value.Length / 3);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3ui64vNV(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3ui64vNV(this GL.NVExtension glInstance, int location, ulong[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3ui64vNV(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform3ui64vNV(this GL.NVExtension glInstance, int location, int count, in ulong value)
        {
            fixed (ulong* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform3ui64vNV(location, count, value_ptr);
            }
        }

        // Uniform4ui64vNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4ui64vNV(this GL.NVExtension glInstance, int location, ReadOnlySpan<ulong> value)
        {
            var count = (int)(value.Length / 4);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4ui64vNV(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4ui64vNV(this GL.NVExtension glInstance, int location, ulong[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4ui64vNV(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform4ui64vNV(this GL.NVExtension glInstance, int location, int count, in ulong value)
        {
            fixed (ulong* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform4ui64vNV(location, count, value_ptr);
            }
        }

        // GetUniformi64vNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformi64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, Span<long> parameters)
        {
            fixed (long* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformi64vNV(program, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformi64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, long[] parameters)
        {
            fixed (long* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformi64vNV(program, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetUniformi64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, ref long parameters)
        {
            fixed (long* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetUniformi64vNV(program, location, parameters_ptr);
            }
        }

        // ProgramUniform1i64vNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1i64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<long> value)
        {
            var count = (int)(value.Length);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1i64vNV(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1i64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, long[] value)
        {
            var count = (int)(value.Length);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1i64vNV(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform1i64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, int count, in long value)
        {
            fixed (long* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform1i64vNV(program, location, count, value_ptr);
            }
        }

        // ProgramUniform2i64vNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2i64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<long> value)
        {
            var count = (int)(value.Length / 2);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2i64vNV(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2i64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, long[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2i64vNV(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform2i64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, int count, in long value)
        {
            fixed (long* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform2i64vNV(program, location, count, value_ptr);
            }
        }

        // ProgramUniform3i64vNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3i64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<long> value)
        {
            var count = (int)(value.Length / 3);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3i64vNV(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3i64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, long[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3i64vNV(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform3i64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, int count, in long value)
        {
            fixed (long* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform3i64vNV(program, location, count, value_ptr);
            }
        }

        // ProgramUniform4i64vNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4i64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<long> value)
        {
            var count = (int)(value.Length / 4);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4i64vNV(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4i64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, long[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4i64vNV(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform4i64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, int count, in long value)
        {
            fixed (long* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform4i64vNV(program, location, count, value_ptr);
            }
        }

        // ProgramUniform1ui64vNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1ui64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<ulong> value)
        {
            var count = (int)(value.Length);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1ui64vNV(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1ui64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, ulong[] value)
        {
            var count = (int)(value.Length);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1ui64vNV(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform1ui64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, int count, in ulong value)
        {
            fixed (ulong* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform1ui64vNV(program, location, count, value_ptr);
            }
        }

        // ProgramUniform2ui64vNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2ui64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<ulong> value)
        {
            var count = (int)(value.Length / 2);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2ui64vNV(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2ui64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, ulong[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2ui64vNV(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform2ui64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, int count, in ulong value)
        {
            fixed (ulong* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform2ui64vNV(program, location, count, value_ptr);
            }
        }

        // ProgramUniform3ui64vNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3ui64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<ulong> value)
        {
            var count = (int)(value.Length / 3);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3ui64vNV(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3ui64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, ulong[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3ui64vNV(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform3ui64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, int count, in ulong value)
        {
            fixed (ulong* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform3ui64vNV(program, location, count, value_ptr);
            }
        }

        // ProgramUniform4ui64vNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4ui64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<ulong> value)
        {
            var count = (int)(value.Length / 4);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4ui64vNV(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4ui64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, ulong[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4ui64vNV(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform4ui64vNV(this GL.NVExtension glInstance, ProgramHandle program, int location, int count, in ulong value)
        {
            fixed (ulong* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform4ui64vNV(program, location, count, value_ptr);
            }
        }

        // GetInternalformatSampleivNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInternalformatSampleivNV(this GL.NVExtension glInstance, TextureTarget target, InternalFormat internalformat, int samples, InternalFormatPName pname, Span<int> parameters)
        {
            var count = (int)(parameters.Length);
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetInternalformatSampleivNV(target, internalformat, samples, pname, count, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInternalformatSampleivNV(this GL.NVExtension glInstance, TextureTarget target, InternalFormat internalformat, int samples, InternalFormatPName pname, int[] parameters)
        {
            var count = (int)(parameters.Length);
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetInternalformatSampleivNV(target, internalformat, samples, pname, count, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetInternalformatSampleivNV(this GL.NVExtension glInstance, TextureTarget target, InternalFormat internalformat, int samples, InternalFormatPName pname, int count, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetInternalformatSampleivNV(target, internalformat, samples, pname, count, parameters_ptr);
            }
        }

        // GetMemoryObjectDetachedResourcesuivNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetMemoryObjectDetachedResourcesuivNV(this GL.NVExtension glInstance, uint memory, GLEnum pname, int first, int count, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetMemoryObjectDetachedResourcesuivNV(memory, pname, first, count, parameters_ptr);
            }
        }

        // BufferPageCommitmentMemNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void BufferPageCommitmentMemNV(this GL.NVExtension glInstance, BufferStorageTarget target, IntPtr offset, nint size, uint memory, ulong memOffset, bool commit)
        {
            var commit_byte = (byte)(commit ? 1 : 0);
            glInstance.BufferPageCommitmentMemNV(target, offset, size, memory, memOffset, commit_byte);
        }

        // TexPageCommitmentMemNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void TexPageCommitmentMemNV(this GL.NVExtension glInstance, TextureTarget target, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, ulong offset, bool commit)
        {
            var commit_byte = (byte)(commit ? 1 : 0);
            glInstance.TexPageCommitmentMemNV(target, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit_byte);
        }

        // NamedBufferPageCommitmentMemNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void NamedBufferPageCommitmentMemNV(this GL.NVExtension glInstance, BufferHandle buffer, IntPtr offset, nint size, uint memory, ulong memOffset, bool commit)
        {
            var commit_byte = (byte)(commit ? 1 : 0);
            glInstance.NamedBufferPageCommitmentMemNV(buffer, offset, size, memory, memOffset, commit_byte);
        }

        // TexturePageCommitmentMemNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void TexturePageCommitmentMemNV(this GL.NVExtension glInstance, TextureHandle texture, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, ulong offset, bool commit)
        {
            var commit_byte = (byte)(commit ? 1 : 0);
            glInstance.TexturePageCommitmentMemNV(texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit_byte);
        }

        // UniformMatrix2x3fvNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2x3fvNV(this GL.NVExtension glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 6);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x3fvNV(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2x3fvNV(this GL.NVExtension glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 6);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x3fvNV(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix2x3fvNV(this GL.NVExtension glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x3fvNV(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix3x2fvNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3x2fvNV(this GL.NVExtension glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 6);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x2fvNV(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3x2fvNV(this GL.NVExtension glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 6);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x2fvNV(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix3x2fvNV(this GL.NVExtension glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x2fvNV(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix2x4fvNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2x4fvNV(this GL.NVExtension glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 8);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x4fvNV(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2x4fvNV(this GL.NVExtension glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 8);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x4fvNV(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix2x4fvNV(this GL.NVExtension glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x4fvNV(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix4x2fvNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4x2fvNV(this GL.NVExtension glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 8);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x2fvNV(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4x2fvNV(this GL.NVExtension glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 8);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x2fvNV(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix4x2fvNV(this GL.NVExtension glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x2fvNV(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix3x4fvNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3x4fvNV(this GL.NVExtension glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 12);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x4fvNV(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3x4fvNV(this GL.NVExtension glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 12);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x4fvNV(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix3x4fvNV(this GL.NVExtension glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x4fvNV(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix4x3fvNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4x3fvNV(this GL.NVExtension glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 12);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x3fvNV(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4x3fvNV(this GL.NVExtension glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 12);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x3fvNV(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix4x3fvNV(this GL.NVExtension glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x3fvNV(location, count, transpose_byte, value_ptr);
            }
        }

        // PathCommandsNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathCommandsNV(this GL.NVExtension glInstance, uint path, ReadOnlySpan<byte> commands, int numCoords, PathCoordType coordType, IntPtr coords)
        {
            var numCommands = (int)(commands.Length);
            fixed (byte* commands_ptr = commands) // SpanOrArrayLayer
            {
                var coords_vptr = (void*)coords;
                glInstance.PathCommandsNV(path, numCommands, commands_ptr, numCoords, coordType, coords_vptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathCommandsNV(this GL.NVExtension glInstance, uint path, byte[] commands, int numCoords, PathCoordType coordType, IntPtr coords)
        {
            var numCommands = (int)(commands.Length);
            fixed (byte* commands_ptr = commands) // SpanOrArrayLayer
            {
                var coords_vptr = (void*)coords;
                glInstance.PathCommandsNV(path, numCommands, commands_ptr, numCoords, coordType, coords_vptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void PathCommandsNV(this GL.NVExtension glInstance, uint path, int numCommands, in byte commands, int numCoords, PathCoordType coordType, IntPtr coords)
        {
            fixed (byte* commands_ptr = &commands) // RefInsteadOfPointerLayer
            {
                var coords_vptr = (void*)coords;
                glInstance.PathCommandsNV(path, numCommands, commands_ptr, numCoords, coordType, coords_vptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathCommandsNV<T1>(this GL.NVExtension glInstance, uint path, ReadOnlySpan<byte> commands, int numCoords, PathCoordType coordType, ReadOnlySpan<T1> coords)
            where T1 : unmanaged
        {
            var numCommands = (int)(commands.Length);
            fixed (byte* commands_ptr = commands) // SpanOrArrayLayer
            {
                fixed (void* coords_ptr = coords) // SpanOrArrayLayer
                {
                    glInstance.PathCommandsNV(path, numCommands, commands_ptr, numCoords, coordType, coords_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathCommandsNV<T1>(this GL.NVExtension glInstance, uint path, byte[] commands, int numCoords, PathCoordType coordType, T1[] coords)
            where T1 : unmanaged
        {
            var numCommands = (int)(commands.Length);
            fixed (byte* commands_ptr = commands) // SpanOrArrayLayer
            {
                fixed (void* coords_ptr = coords) // SpanOrArrayLayer
                {
                    glInstance.PathCommandsNV(path, numCommands, commands_ptr, numCoords, coordType, coords_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void PathCommandsNV<T1>(this GL.NVExtension glInstance, uint path, int numCommands, in byte commands, int numCoords, PathCoordType coordType, in T1 coords)
            where T1 : unmanaged
        {
            fixed (byte* commands_ptr = &commands) // RefInsteadOfPointerLayer
            fixed (void* coords_ptr = &coords) // RefInsteadOfPointerLayer
            {
                glInstance.PathCommandsNV(path, numCommands, commands_ptr, numCoords, coordType, coords_ptr);
            }
        }

        // PathCoordsNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void PathCoordsNV(this GL.NVExtension glInstance, uint path, int numCoords, PathCoordType coordType, IntPtr coords)
        {
            var coords_vptr = (void*)coords;
            glInstance.PathCoordsNV(path, numCoords, coordType, coords_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathCoordsNV<T1>(this GL.NVExtension glInstance, uint path, int numCoords, PathCoordType coordType, ReadOnlySpan<T1> coords)
            where T1 : unmanaged
        {
            fixed (void* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.PathCoordsNV(path, numCoords, coordType, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathCoordsNV<T1>(this GL.NVExtension glInstance, uint path, int numCoords, PathCoordType coordType, T1[] coords)
            where T1 : unmanaged
        {
            fixed (void* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.PathCoordsNV(path, numCoords, coordType, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void PathCoordsNV<T1>(this GL.NVExtension glInstance, uint path, int numCoords, PathCoordType coordType, in T1 coords)
            where T1 : unmanaged
        {
            fixed (void* coords_ptr = &coords) // RefInsteadOfPointerLayer
            {
                glInstance.PathCoordsNV(path, numCoords, coordType, coords_ptr);
            }
        }

        // PathSubCommandsNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathSubCommandsNV(this GL.NVExtension glInstance, uint path, int commandStart, int commandsToDelete, ReadOnlySpan<byte> commands, int numCoords, PathCoordType coordType, IntPtr coords)
        {
            var numCommands = (int)(commands.Length);
            fixed (byte* commands_ptr = commands) // SpanOrArrayLayer
            {
                var coords_vptr = (void*)coords;
                glInstance.PathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands_ptr, numCoords, coordType, coords_vptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathSubCommandsNV(this GL.NVExtension glInstance, uint path, int commandStart, int commandsToDelete, byte[] commands, int numCoords, PathCoordType coordType, IntPtr coords)
        {
            var numCommands = (int)(commands.Length);
            fixed (byte* commands_ptr = commands) // SpanOrArrayLayer
            {
                var coords_vptr = (void*)coords;
                glInstance.PathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands_ptr, numCoords, coordType, coords_vptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void PathSubCommandsNV(this GL.NVExtension glInstance, uint path, int commandStart, int commandsToDelete, int numCommands, in byte commands, int numCoords, PathCoordType coordType, IntPtr coords)
        {
            fixed (byte* commands_ptr = &commands) // RefInsteadOfPointerLayer
            {
                var coords_vptr = (void*)coords;
                glInstance.PathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands_ptr, numCoords, coordType, coords_vptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathSubCommandsNV<T1>(this GL.NVExtension glInstance, uint path, int commandStart, int commandsToDelete, ReadOnlySpan<byte> commands, int numCoords, PathCoordType coordType, ReadOnlySpan<T1> coords)
            where T1 : unmanaged
        {
            var numCommands = (int)(commands.Length);
            fixed (byte* commands_ptr = commands) // SpanOrArrayLayer
            {
                fixed (void* coords_ptr = coords) // SpanOrArrayLayer
                {
                    glInstance.PathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands_ptr, numCoords, coordType, coords_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathSubCommandsNV<T1>(this GL.NVExtension glInstance, uint path, int commandStart, int commandsToDelete, byte[] commands, int numCoords, PathCoordType coordType, T1[] coords)
            where T1 : unmanaged
        {
            var numCommands = (int)(commands.Length);
            fixed (byte* commands_ptr = commands) // SpanOrArrayLayer
            {
                fixed (void* coords_ptr = coords) // SpanOrArrayLayer
                {
                    glInstance.PathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands_ptr, numCoords, coordType, coords_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void PathSubCommandsNV<T1>(this GL.NVExtension glInstance, uint path, int commandStart, int commandsToDelete, int numCommands, in byte commands, int numCoords, PathCoordType coordType, in T1 coords)
            where T1 : unmanaged
        {
            fixed (byte* commands_ptr = &commands) // RefInsteadOfPointerLayer
            fixed (void* coords_ptr = &coords) // RefInsteadOfPointerLayer
            {
                glInstance.PathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands_ptr, numCoords, coordType, coords_ptr);
            }
        }

        // PathSubCoordsNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void PathSubCoordsNV(this GL.NVExtension glInstance, uint path, int coordStart, int numCoords, PathCoordType coordType, IntPtr coords)
        {
            var coords_vptr = (void*)coords;
            glInstance.PathSubCoordsNV(path, coordStart, numCoords, coordType, coords_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathSubCoordsNV<T1>(this GL.NVExtension glInstance, uint path, int coordStart, int numCoords, PathCoordType coordType, ReadOnlySpan<T1> coords)
            where T1 : unmanaged
        {
            fixed (void* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.PathSubCoordsNV(path, coordStart, numCoords, coordType, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathSubCoordsNV<T1>(this GL.NVExtension glInstance, uint path, int coordStart, int numCoords, PathCoordType coordType, T1[] coords)
            where T1 : unmanaged
        {
            fixed (void* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.PathSubCoordsNV(path, coordStart, numCoords, coordType, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void PathSubCoordsNV<T1>(this GL.NVExtension glInstance, uint path, int coordStart, int numCoords, PathCoordType coordType, in T1 coords)
            where T1 : unmanaged
        {
            fixed (void* coords_ptr = &coords) // RefInsteadOfPointerLayer
            {
                glInstance.PathSubCoordsNV(path, coordStart, numCoords, coordType, coords_ptr);
            }
        }

        // PathStringNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void PathStringNV(this GL.NVExtension glInstance, uint path, PathStringFormat format, int length, IntPtr pathString)
        {
            var pathString_vptr = (void*)pathString;
            glInstance.PathStringNV(path, format, length, pathString_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathStringNV<T1>(this GL.NVExtension glInstance, uint path, PathStringFormat format, ReadOnlySpan<T1> pathString)
            where T1 : unmanaged
        {
            var length = (int)(pathString.Length * sizeof(T1));
            fixed (void* pathString_ptr = pathString) // SpanOrArrayLayer
            {
                glInstance.PathStringNV(path, format, length, pathString_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathStringNV<T1>(this GL.NVExtension glInstance, uint path, PathStringFormat format, T1[] pathString)
            where T1 : unmanaged
        {
            var length = (int)(pathString.Length * sizeof(T1));
            fixed (void* pathString_ptr = pathString) // SpanOrArrayLayer
            {
                glInstance.PathStringNV(path, format, length, pathString_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void PathStringNV<T1>(this GL.NVExtension glInstance, uint path, PathStringFormat format, int length, in T1 pathString)
            where T1 : unmanaged
        {
            fixed (void* pathString_ptr = &pathString) // RefInsteadOfPointerLayer
            {
                glInstance.PathStringNV(path, format, length, pathString_ptr);
            }
        }

        // PathGlyphsNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void PathGlyphsNV(this GL.NVExtension glInstance, uint firstPathName, PathFontTarget fontTarget, IntPtr fontName, PathFontStyle fontStyle, int numGlyphs, PathElementType type, IntPtr charcodes, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
        {
            var fontName_vptr = (void*)fontName;
            var charcodes_vptr = (void*)charcodes;
            glInstance.PathGlyphsNV(firstPathName, fontTarget, fontName_vptr, fontStyle, numGlyphs, type, charcodes_vptr, handleMissingGlyphs, pathParameterTemplate, emScale);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathGlyphsNV<T1, T2>(this GL.NVExtension glInstance, uint firstPathName, PathFontTarget fontTarget, ReadOnlySpan<T2> fontName, PathFontStyle fontStyle, int numGlyphs, PathElementType type, ReadOnlySpan<T1> charcodes, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
            where T1 : unmanaged
            where T2 : unmanaged
        {
            fixed (void* fontName_ptr = fontName) // SpanOrArrayLayer
            {
                fixed (void* charcodes_ptr = charcodes) // SpanOrArrayLayer
                {
                    glInstance.PathGlyphsNV(firstPathName, fontTarget, fontName_ptr, fontStyle, numGlyphs, type, charcodes_ptr, handleMissingGlyphs, pathParameterTemplate, emScale);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathGlyphsNV<T1, T2>(this GL.NVExtension glInstance, uint firstPathName, PathFontTarget fontTarget, T2[] fontName, PathFontStyle fontStyle, int numGlyphs, PathElementType type, T1[] charcodes, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
            where T1 : unmanaged
            where T2 : unmanaged
        {
            fixed (void* fontName_ptr = fontName) // SpanOrArrayLayer
            {
                fixed (void* charcodes_ptr = charcodes) // SpanOrArrayLayer
                {
                    glInstance.PathGlyphsNV(firstPathName, fontTarget, fontName_ptr, fontStyle, numGlyphs, type, charcodes_ptr, handleMissingGlyphs, pathParameterTemplate, emScale);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void PathGlyphsNV<T1, T2>(this GL.NVExtension glInstance, uint firstPathName, PathFontTarget fontTarget, in T1 fontName, PathFontStyle fontStyle, int numGlyphs, PathElementType type, in T2 charcodes, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
            where T1 : unmanaged
            where T2 : unmanaged
        {
            fixed (void* fontName_ptr = &fontName) // RefInsteadOfPointerLayer
            fixed (void* charcodes_ptr = &charcodes) // RefInsteadOfPointerLayer
            {
                glInstance.PathGlyphsNV(firstPathName, fontTarget, fontName_ptr, fontStyle, numGlyphs, type, charcodes_ptr, handleMissingGlyphs, pathParameterTemplate, emScale);
            }
        }

        // PathGlyphRangeNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void PathGlyphRangeNV(this GL.NVExtension glInstance, uint firstPathName, PathFontTarget fontTarget, IntPtr fontName, PathFontStyle fontStyle, uint firstGlyph, int numGlyphs, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
        {
            var fontName_vptr = (void*)fontName;
            glInstance.PathGlyphRangeNV(firstPathName, fontTarget, fontName_vptr, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathGlyphRangeNV<T1>(this GL.NVExtension glInstance, uint firstPathName, PathFontTarget fontTarget, ReadOnlySpan<T1> fontName, PathFontStyle fontStyle, uint firstGlyph, int numGlyphs, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
            where T1 : unmanaged
        {
            fixed (void* fontName_ptr = fontName) // SpanOrArrayLayer
            {
                glInstance.PathGlyphRangeNV(firstPathName, fontTarget, fontName_ptr, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathGlyphRangeNV<T1>(this GL.NVExtension glInstance, uint firstPathName, PathFontTarget fontTarget, T1[] fontName, PathFontStyle fontStyle, uint firstGlyph, int numGlyphs, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
            where T1 : unmanaged
        {
            fixed (void* fontName_ptr = fontName) // SpanOrArrayLayer
            {
                glInstance.PathGlyphRangeNV(firstPathName, fontTarget, fontName_ptr, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void PathGlyphRangeNV<T1>(this GL.NVExtension glInstance, uint firstPathName, PathFontTarget fontTarget, in T1 fontName, PathFontStyle fontStyle, uint firstGlyph, int numGlyphs, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
            where T1 : unmanaged
        {
            fixed (void* fontName_ptr = &fontName) // RefInsteadOfPointerLayer
            {
                glInstance.PathGlyphRangeNV(firstPathName, fontTarget, fontName_ptr, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
            }
        }

        // WeightPathsNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WeightPathsNV(this GL.NVExtension glInstance, uint resultPath, int numPaths, ReadOnlySpan<uint> paths, ReadOnlySpan<float> weights)
        {
            fixed (uint* paths_ptr = paths) // SpanOrArrayLayer
            {
                fixed (float* weights_ptr = weights) // SpanOrArrayLayer
                {
                    glInstance.WeightPathsNV(resultPath, numPaths, paths_ptr, weights_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WeightPathsNV(this GL.NVExtension glInstance, uint resultPath, int numPaths, uint[] paths, float[] weights)
        {
            fixed (uint* paths_ptr = paths) // SpanOrArrayLayer
            {
                fixed (float* weights_ptr = weights) // SpanOrArrayLayer
                {
                    glInstance.WeightPathsNV(resultPath, numPaths, paths_ptr, weights_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WeightPathsNV(this GL.NVExtension glInstance, uint resultPath, int numPaths, in uint paths, in float weights)
        {
            fixed (uint* paths_ptr = &paths) // RefInsteadOfPointerLayer
            fixed (float* weights_ptr = &weights) // RefInsteadOfPointerLayer
            {
                glInstance.WeightPathsNV(resultPath, numPaths, paths_ptr, weights_ptr);
            }
        }

        // TransformPathNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TransformPathNV(this GL.NVExtension glInstance, uint resultPath, uint srcPath, PathTransformType transformType, ReadOnlySpan<float> transformValues)
        {
            fixed (float* transformValues_ptr = transformValues) // SpanOrArrayLayer
            {
                glInstance.TransformPathNV(resultPath, srcPath, transformType, transformValues_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TransformPathNV(this GL.NVExtension glInstance, uint resultPath, uint srcPath, PathTransformType transformType, float[] transformValues)
        {
            fixed (float* transformValues_ptr = transformValues) // SpanOrArrayLayer
            {
                glInstance.TransformPathNV(resultPath, srcPath, transformType, transformValues_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TransformPathNV(this GL.NVExtension glInstance, uint resultPath, uint srcPath, PathTransformType transformType, in float transformValues)
        {
            fixed (float* transformValues_ptr = &transformValues) // RefInsteadOfPointerLayer
            {
                glInstance.TransformPathNV(resultPath, srcPath, transformType, transformValues_ptr);
            }
        }

        // PathParameterivNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathParameterivNV(this GL.NVExtension glInstance, uint path, PathParameter pname, ReadOnlySpan<int> value)
        {
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.PathParameterivNV(path, pname, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathParameterivNV(this GL.NVExtension glInstance, uint path, PathParameter pname, int[] value)
        {
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.PathParameterivNV(path, pname, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void PathParameterivNV(this GL.NVExtension glInstance, uint path, PathParameter pname, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.PathParameterivNV(path, pname, value_ptr);
            }
        }

        // PathParameterfvNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathParameterfvNV(this GL.NVExtension glInstance, uint path, PathParameter pname, ReadOnlySpan<float> value)
        {
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.PathParameterfvNV(path, pname, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathParameterfvNV(this GL.NVExtension glInstance, uint path, PathParameter pname, float[] value)
        {
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.PathParameterfvNV(path, pname, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void PathParameterfvNV(this GL.NVExtension glInstance, uint path, PathParameter pname, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.PathParameterfvNV(path, pname, value_ptr);
            }
        }

        // PathDashArrayNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathDashArrayNV(this GL.NVExtension glInstance, uint path, ReadOnlySpan<float> dashArray)
        {
            var dashCount = (int)(dashArray.Length);
            fixed (float* dashArray_ptr = dashArray) // SpanOrArrayLayer
            {
                glInstance.PathDashArrayNV(path, dashCount, dashArray_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathDashArrayNV(this GL.NVExtension glInstance, uint path, float[] dashArray)
        {
            var dashCount = (int)(dashArray.Length);
            fixed (float* dashArray_ptr = dashArray) // SpanOrArrayLayer
            {
                glInstance.PathDashArrayNV(path, dashCount, dashArray_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void PathDashArrayNV(this GL.NVExtension glInstance, uint path, int dashCount, in float dashArray)
        {
            fixed (float* dashArray_ptr = &dashArray) // RefInsteadOfPointerLayer
            {
                glInstance.PathDashArrayNV(path, dashCount, dashArray_ptr);
            }
        }

        // StencilFillPathInstancedNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void StencilFillPathInstancedNV(this GL.NVExtension glInstance, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathFillMode fillMode, uint mask, PathTransformType transformType, ReadOnlySpan<float> transformValues)
        {
            fixed (float* transformValues_ptr = transformValues) // SpanOrArrayLayer
            {
                var paths_vptr = (void*)paths;
                glInstance.StencilFillPathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, fillMode, mask, transformType, transformValues_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void StencilFillPathInstancedNV(this GL.NVExtension glInstance, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathFillMode fillMode, uint mask, PathTransformType transformType, float[] transformValues)
        {
            fixed (float* transformValues_ptr = transformValues) // SpanOrArrayLayer
            {
                var paths_vptr = (void*)paths;
                glInstance.StencilFillPathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, fillMode, mask, transformType, transformValues_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void StencilFillPathInstancedNV(this GL.NVExtension glInstance, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathFillMode fillMode, uint mask, PathTransformType transformType, in float transformValues)
        {
            fixed (float* transformValues_ptr = &transformValues) // RefInsteadOfPointerLayer
            {
                var paths_vptr = (void*)paths;
                glInstance.StencilFillPathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, fillMode, mask, transformType, transformValues_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void StencilFillPathInstancedNV<T1>(this GL.NVExtension glInstance, int numPaths, PathElementType pathNameType, ReadOnlySpan<T1> paths, uint pathBase, PathFillMode fillMode, uint mask, PathTransformType transformType, ReadOnlySpan<float> transformValues)
            where T1 : unmanaged
        {
            fixed (void* paths_ptr = paths) // SpanOrArrayLayer
            {
                fixed (float* transformValues_ptr = transformValues) // SpanOrArrayLayer
                {
                    glInstance.StencilFillPathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, fillMode, mask, transformType, transformValues_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void StencilFillPathInstancedNV<T1>(this GL.NVExtension glInstance, int numPaths, PathElementType pathNameType, T1[] paths, uint pathBase, PathFillMode fillMode, uint mask, PathTransformType transformType, float[] transformValues)
            where T1 : unmanaged
        {
            fixed (void* paths_ptr = paths) // SpanOrArrayLayer
            {
                fixed (float* transformValues_ptr = transformValues) // SpanOrArrayLayer
                {
                    glInstance.StencilFillPathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, fillMode, mask, transformType, transformValues_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void StencilFillPathInstancedNV<T1>(this GL.NVExtension glInstance, int numPaths, PathElementType pathNameType, in T1 paths, uint pathBase, PathFillMode fillMode, uint mask, PathTransformType transformType, in float transformValues)
            where T1 : unmanaged
        {
            fixed (void* paths_ptr = &paths) // RefInsteadOfPointerLayer
            fixed (float* transformValues_ptr = &transformValues) // RefInsteadOfPointerLayer
            {
                glInstance.StencilFillPathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, fillMode, mask, transformType, transformValues_ptr);
            }
        }

        // StencilStrokePathInstancedNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void StencilStrokePathInstancedNV(this GL.NVExtension glInstance, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, int reference, uint mask, PathTransformType transformType, ReadOnlySpan<float> transformValues)
        {
            fixed (float* transformValues_ptr = transformValues) // SpanOrArrayLayer
            {
                var paths_vptr = (void*)paths;
                glInstance.StencilStrokePathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, reference, mask, transformType, transformValues_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void StencilStrokePathInstancedNV(this GL.NVExtension glInstance, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, int reference, uint mask, PathTransformType transformType, float[] transformValues)
        {
            fixed (float* transformValues_ptr = transformValues) // SpanOrArrayLayer
            {
                var paths_vptr = (void*)paths;
                glInstance.StencilStrokePathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, reference, mask, transformType, transformValues_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void StencilStrokePathInstancedNV(this GL.NVExtension glInstance, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, int reference, uint mask, PathTransformType transformType, in float transformValues)
        {
            fixed (float* transformValues_ptr = &transformValues) // RefInsteadOfPointerLayer
            {
                var paths_vptr = (void*)paths;
                glInstance.StencilStrokePathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, reference, mask, transformType, transformValues_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void StencilStrokePathInstancedNV<T1>(this GL.NVExtension glInstance, int numPaths, PathElementType pathNameType, ReadOnlySpan<T1> paths, uint pathBase, int reference, uint mask, PathTransformType transformType, ReadOnlySpan<float> transformValues)
            where T1 : unmanaged
        {
            fixed (void* paths_ptr = paths) // SpanOrArrayLayer
            {
                fixed (float* transformValues_ptr = transformValues) // SpanOrArrayLayer
                {
                    glInstance.StencilStrokePathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, reference, mask, transformType, transformValues_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void StencilStrokePathInstancedNV<T1>(this GL.NVExtension glInstance, int numPaths, PathElementType pathNameType, T1[] paths, uint pathBase, int reference, uint mask, PathTransformType transformType, float[] transformValues)
            where T1 : unmanaged
        {
            fixed (void* paths_ptr = paths) // SpanOrArrayLayer
            {
                fixed (float* transformValues_ptr = transformValues) // SpanOrArrayLayer
                {
                    glInstance.StencilStrokePathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, reference, mask, transformType, transformValues_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void StencilStrokePathInstancedNV<T1>(this GL.NVExtension glInstance, int numPaths, PathElementType pathNameType, in T1 paths, uint pathBase, int reference, uint mask, PathTransformType transformType, in float transformValues)
            where T1 : unmanaged
        {
            fixed (void* paths_ptr = &paths) // RefInsteadOfPointerLayer
            fixed (float* transformValues_ptr = &transformValues) // RefInsteadOfPointerLayer
            {
                glInstance.StencilStrokePathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, reference, mask, transformType, transformValues_ptr);
            }
        }

        // CoverFillPathInstancedNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CoverFillPathInstancedNV(this GL.NVExtension glInstance, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, ReadOnlySpan<float> transformValues)
        {
            fixed (float* transformValues_ptr = transformValues) // SpanOrArrayLayer
            {
                var paths_vptr = (void*)paths;
                glInstance.CoverFillPathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, coverMode, transformType, transformValues_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CoverFillPathInstancedNV(this GL.NVExtension glInstance, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, float[] transformValues)
        {
            fixed (float* transformValues_ptr = transformValues) // SpanOrArrayLayer
            {
                var paths_vptr = (void*)paths;
                glInstance.CoverFillPathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, coverMode, transformType, transformValues_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CoverFillPathInstancedNV(this GL.NVExtension glInstance, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, in float transformValues)
        {
            fixed (float* transformValues_ptr = &transformValues) // RefInsteadOfPointerLayer
            {
                var paths_vptr = (void*)paths;
                glInstance.CoverFillPathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, coverMode, transformType, transformValues_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CoverFillPathInstancedNV<T1>(this GL.NVExtension glInstance, int numPaths, PathElementType pathNameType, ReadOnlySpan<T1> paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, ReadOnlySpan<float> transformValues)
            where T1 : unmanaged
        {
            fixed (void* paths_ptr = paths) // SpanOrArrayLayer
            {
                fixed (float* transformValues_ptr = transformValues) // SpanOrArrayLayer
                {
                    glInstance.CoverFillPathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, coverMode, transformType, transformValues_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CoverFillPathInstancedNV<T1>(this GL.NVExtension glInstance, int numPaths, PathElementType pathNameType, T1[] paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, float[] transformValues)
            where T1 : unmanaged
        {
            fixed (void* paths_ptr = paths) // SpanOrArrayLayer
            {
                fixed (float* transformValues_ptr = transformValues) // SpanOrArrayLayer
                {
                    glInstance.CoverFillPathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, coverMode, transformType, transformValues_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CoverFillPathInstancedNV<T1>(this GL.NVExtension glInstance, int numPaths, PathElementType pathNameType, in T1 paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, in float transformValues)
            where T1 : unmanaged
        {
            fixed (void* paths_ptr = &paths) // RefInsteadOfPointerLayer
            fixed (float* transformValues_ptr = &transformValues) // RefInsteadOfPointerLayer
            {
                glInstance.CoverFillPathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, coverMode, transformType, transformValues_ptr);
            }
        }

        // CoverStrokePathInstancedNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CoverStrokePathInstancedNV(this GL.NVExtension glInstance, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, ReadOnlySpan<float> transformValues)
        {
            fixed (float* transformValues_ptr = transformValues) // SpanOrArrayLayer
            {
                var paths_vptr = (void*)paths;
                glInstance.CoverStrokePathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, coverMode, transformType, transformValues_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CoverStrokePathInstancedNV(this GL.NVExtension glInstance, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, float[] transformValues)
        {
            fixed (float* transformValues_ptr = transformValues) // SpanOrArrayLayer
            {
                var paths_vptr = (void*)paths;
                glInstance.CoverStrokePathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, coverMode, transformType, transformValues_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CoverStrokePathInstancedNV(this GL.NVExtension glInstance, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, in float transformValues)
        {
            fixed (float* transformValues_ptr = &transformValues) // RefInsteadOfPointerLayer
            {
                var paths_vptr = (void*)paths;
                glInstance.CoverStrokePathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, coverMode, transformType, transformValues_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CoverStrokePathInstancedNV<T1>(this GL.NVExtension glInstance, int numPaths, PathElementType pathNameType, ReadOnlySpan<T1> paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, ReadOnlySpan<float> transformValues)
            where T1 : unmanaged
        {
            fixed (void* paths_ptr = paths) // SpanOrArrayLayer
            {
                fixed (float* transformValues_ptr = transformValues) // SpanOrArrayLayer
                {
                    glInstance.CoverStrokePathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, coverMode, transformType, transformValues_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CoverStrokePathInstancedNV<T1>(this GL.NVExtension glInstance, int numPaths, PathElementType pathNameType, T1[] paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, float[] transformValues)
            where T1 : unmanaged
        {
            fixed (void* paths_ptr = paths) // SpanOrArrayLayer
            {
                fixed (float* transformValues_ptr = transformValues) // SpanOrArrayLayer
                {
                    glInstance.CoverStrokePathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, coverMode, transformType, transformValues_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CoverStrokePathInstancedNV<T1>(this GL.NVExtension glInstance, int numPaths, PathElementType pathNameType, in T1 paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, in float transformValues)
            where T1 : unmanaged
        {
            fixed (void* paths_ptr = &paths) // RefInsteadOfPointerLayer
            fixed (float* transformValues_ptr = &transformValues) // RefInsteadOfPointerLayer
            {
                glInstance.CoverStrokePathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, coverMode, transformType, transformValues_ptr);
            }
        }

        // GetPathParameterivNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathParameterivNV(this GL.NVExtension glInstance, uint path, PathParameter pname, Span<int> value)
        {
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.GetPathParameterivNV(path, pname, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathParameterivNV(this GL.NVExtension glInstance, uint path, PathParameter pname, int[] value)
        {
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.GetPathParameterivNV(path, pname, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetPathParameterivNV(this GL.NVExtension glInstance, uint path, PathParameter pname, ref int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.GetPathParameterivNV(path, pname, value_ptr);
            }
        }

        // GetPathParameterfvNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathParameterfvNV(this GL.NVExtension glInstance, uint path, PathParameter pname, Span<float> value)
        {
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.GetPathParameterfvNV(path, pname, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathParameterfvNV(this GL.NVExtension glInstance, uint path, PathParameter pname, float[] value)
        {
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.GetPathParameterfvNV(path, pname, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetPathParameterfvNV(this GL.NVExtension glInstance, uint path, PathParameter pname, ref float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.GetPathParameterfvNV(path, pname, value_ptr);
            }
        }

        // GetPathCommandsNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathCommandsNV(this GL.NVExtension glInstance, uint path, Span<byte> commands)
        {
            fixed (byte* commands_ptr = commands) // SpanOrArrayLayer
            {
                glInstance.GetPathCommandsNV(path, commands_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathCommandsNV(this GL.NVExtension glInstance, uint path, byte[] commands)
        {
            fixed (byte* commands_ptr = commands) // SpanOrArrayLayer
            {
                glInstance.GetPathCommandsNV(path, commands_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetPathCommandsNV(this GL.NVExtension glInstance, uint path, ref byte commands)
        {
            fixed (byte* commands_ptr = &commands) // RefInsteadOfPointerLayer
            {
                glInstance.GetPathCommandsNV(path, commands_ptr);
            }
        }

        // GetPathCoordsNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathCoordsNV(this GL.NVExtension glInstance, uint path, Span<float> coords)
        {
            fixed (float* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.GetPathCoordsNV(path, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathCoordsNV(this GL.NVExtension glInstance, uint path, float[] coords)
        {
            fixed (float* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.GetPathCoordsNV(path, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetPathCoordsNV(this GL.NVExtension glInstance, uint path, ref float coords)
        {
            fixed (float* coords_ptr = &coords) // RefInsteadOfPointerLayer
            {
                glInstance.GetPathCoordsNV(path, coords_ptr);
            }
        }

        // GetPathDashArrayNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathDashArrayNV(this GL.NVExtension glInstance, uint path, Span<float> dashArray)
        {
            fixed (float* dashArray_ptr = dashArray) // SpanOrArrayLayer
            {
                glInstance.GetPathDashArrayNV(path, dashArray_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathDashArrayNV(this GL.NVExtension glInstance, uint path, float[] dashArray)
        {
            fixed (float* dashArray_ptr = dashArray) // SpanOrArrayLayer
            {
                glInstance.GetPathDashArrayNV(path, dashArray_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetPathDashArrayNV(this GL.NVExtension glInstance, uint path, ref float dashArray)
        {
            fixed (float* dashArray_ptr = &dashArray) // RefInsteadOfPointerLayer
            {
                glInstance.GetPathDashArrayNV(path, dashArray_ptr);
            }
        }

        // GetPathMetricsNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathMetricsNV(this GL.NVExtension glInstance, PathMetricMask metricQueryMask, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, int stride, Span<float> metrics)
        {
            fixed (float* metrics_ptr = metrics) // SpanOrArrayLayer
            {
                var paths_vptr = (void*)paths;
                glInstance.GetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths_vptr, pathBase, stride, metrics_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathMetricsNV(this GL.NVExtension glInstance, PathMetricMask metricQueryMask, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, int stride, float[] metrics)
        {
            fixed (float* metrics_ptr = metrics) // SpanOrArrayLayer
            {
                var paths_vptr = (void*)paths;
                glInstance.GetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths_vptr, pathBase, stride, metrics_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetPathMetricsNV(this GL.NVExtension glInstance, PathMetricMask metricQueryMask, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, int stride, ref float metrics)
        {
            fixed (float* metrics_ptr = &metrics) // RefInsteadOfPointerLayer
            {
                var paths_vptr = (void*)paths;
                glInstance.GetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths_vptr, pathBase, stride, metrics_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathMetricsNV<T1>(this GL.NVExtension glInstance, PathMetricMask metricQueryMask, int numPaths, PathElementType pathNameType, ReadOnlySpan<T1> paths, uint pathBase, int stride, Span<float> metrics)
            where T1 : unmanaged
        {
            fixed (void* paths_ptr = paths) // SpanOrArrayLayer
            {
                fixed (float* metrics_ptr = metrics) // SpanOrArrayLayer
                {
                    glInstance.GetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths_ptr, pathBase, stride, metrics_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathMetricsNV<T1>(this GL.NVExtension glInstance, PathMetricMask metricQueryMask, int numPaths, PathElementType pathNameType, T1[] paths, uint pathBase, int stride, float[] metrics)
            where T1 : unmanaged
        {
            fixed (void* paths_ptr = paths) // SpanOrArrayLayer
            {
                fixed (float* metrics_ptr = metrics) // SpanOrArrayLayer
                {
                    glInstance.GetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths_ptr, pathBase, stride, metrics_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetPathMetricsNV<T1>(this GL.NVExtension glInstance, PathMetricMask metricQueryMask, int numPaths, PathElementType pathNameType, in T1 paths, uint pathBase, int stride, ref float metrics)
            where T1 : unmanaged
        {
            fixed (void* paths_ptr = &paths) // RefInsteadOfPointerLayer
            fixed (float* metrics_ptr = &metrics) // RefInsteadOfPointerLayer
            {
                glInstance.GetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths_ptr, pathBase, stride, metrics_ptr);
            }
        }

        // GetPathMetricRangeNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathMetricRangeNV(this GL.NVExtension glInstance, PathMetricMask metricQueryMask, uint firstPathName, int numPaths, int stride, Span<float> metrics)
        {
            fixed (float* metrics_ptr = metrics) // SpanOrArrayLayer
            {
                glInstance.GetPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, metrics_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathMetricRangeNV(this GL.NVExtension glInstance, PathMetricMask metricQueryMask, uint firstPathName, int numPaths, int stride, float[] metrics)
        {
            fixed (float* metrics_ptr = metrics) // SpanOrArrayLayer
            {
                glInstance.GetPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, metrics_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetPathMetricRangeNV(this GL.NVExtension glInstance, PathMetricMask metricQueryMask, uint firstPathName, int numPaths, int stride, ref float metrics)
        {
            fixed (float* metrics_ptr = &metrics) // RefInsteadOfPointerLayer
            {
                glInstance.GetPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, metrics_ptr);
            }
        }

        // GetPathSpacingNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathSpacingNV(this GL.NVExtension glInstance, PathListMode pathListMode, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, float advanceScale, float kerningScale, PathTransformType transformType, Span<float> returnedSpacing)
        {
            fixed (float* returnedSpacing_ptr = returnedSpacing) // SpanOrArrayLayer
            {
                var paths_vptr = (void*)paths;
                glInstance.GetPathSpacingNV(pathListMode, numPaths, pathNameType, paths_vptr, pathBase, advanceScale, kerningScale, transformType, returnedSpacing_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathSpacingNV(this GL.NVExtension glInstance, PathListMode pathListMode, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, float advanceScale, float kerningScale, PathTransformType transformType, float[] returnedSpacing)
        {
            fixed (float* returnedSpacing_ptr = returnedSpacing) // SpanOrArrayLayer
            {
                var paths_vptr = (void*)paths;
                glInstance.GetPathSpacingNV(pathListMode, numPaths, pathNameType, paths_vptr, pathBase, advanceScale, kerningScale, transformType, returnedSpacing_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetPathSpacingNV(this GL.NVExtension glInstance, PathListMode pathListMode, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, float advanceScale, float kerningScale, PathTransformType transformType, ref float returnedSpacing)
        {
            fixed (float* returnedSpacing_ptr = &returnedSpacing) // RefInsteadOfPointerLayer
            {
                var paths_vptr = (void*)paths;
                glInstance.GetPathSpacingNV(pathListMode, numPaths, pathNameType, paths_vptr, pathBase, advanceScale, kerningScale, transformType, returnedSpacing_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathSpacingNV<T1>(this GL.NVExtension glInstance, PathListMode pathListMode, int numPaths, PathElementType pathNameType, ReadOnlySpan<T1> paths, uint pathBase, float advanceScale, float kerningScale, PathTransformType transformType, Span<float> returnedSpacing)
            where T1 : unmanaged
        {
            fixed (void* paths_ptr = paths) // SpanOrArrayLayer
            {
                fixed (float* returnedSpacing_ptr = returnedSpacing) // SpanOrArrayLayer
                {
                    glInstance.GetPathSpacingNV(pathListMode, numPaths, pathNameType, paths_ptr, pathBase, advanceScale, kerningScale, transformType, returnedSpacing_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathSpacingNV<T1>(this GL.NVExtension glInstance, PathListMode pathListMode, int numPaths, PathElementType pathNameType, T1[] paths, uint pathBase, float advanceScale, float kerningScale, PathTransformType transformType, float[] returnedSpacing)
            where T1 : unmanaged
        {
            fixed (void* paths_ptr = paths) // SpanOrArrayLayer
            {
                fixed (float* returnedSpacing_ptr = returnedSpacing) // SpanOrArrayLayer
                {
                    glInstance.GetPathSpacingNV(pathListMode, numPaths, pathNameType, paths_ptr, pathBase, advanceScale, kerningScale, transformType, returnedSpacing_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetPathSpacingNV<T1>(this GL.NVExtension glInstance, PathListMode pathListMode, int numPaths, PathElementType pathNameType, in T1 paths, uint pathBase, float advanceScale, float kerningScale, PathTransformType transformType, ref float returnedSpacing)
            where T1 : unmanaged
        {
            fixed (void* paths_ptr = &paths) // RefInsteadOfPointerLayer
            fixed (float* returnedSpacing_ptr = &returnedSpacing) // RefInsteadOfPointerLayer
            {
                glInstance.GetPathSpacingNV(pathListMode, numPaths, pathNameType, paths_ptr, pathBase, advanceScale, kerningScale, transformType, returnedSpacing_ptr);
            }
        }

        // PointAlongPathNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe byte PointAlongPathNV(this GL.NVExtension glInstance, uint path, int startSegment, int numSegments, float distance, Span<float> x, Span<float> y, Span<float> tangentX, Span<float> tangentY)
        {
            byte returnValue;
            fixed (float* x_ptr = x) // SpanOrArrayLayer
            {
                fixed (float* y_ptr = y) // SpanOrArrayLayer
                {
                    fixed (float* tangentX_ptr = tangentX) // SpanOrArrayLayer
                    {
                        fixed (float* tangentY_ptr = tangentY) // SpanOrArrayLayer
                        {
                            returnValue = glInstance.PointAlongPathNV(path, startSegment, numSegments, distance, x_ptr, y_ptr, tangentX_ptr, tangentY_ptr);
                        }
                    }
                }
            }
            return returnValue;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe byte PointAlongPathNV(this GL.NVExtension glInstance, uint path, int startSegment, int numSegments, float distance, float[] x, float[] y, float[] tangentX, float[] tangentY)
        {
            byte returnValue;
            fixed (float* x_ptr = x) // SpanOrArrayLayer
            {
                fixed (float* y_ptr = y) // SpanOrArrayLayer
                {
                    fixed (float* tangentX_ptr = tangentX) // SpanOrArrayLayer
                    {
                        fixed (float* tangentY_ptr = tangentY) // SpanOrArrayLayer
                        {
                            returnValue = glInstance.PointAlongPathNV(path, startSegment, numSegments, distance, x_ptr, y_ptr, tangentX_ptr, tangentY_ptr);
                        }
                    }
                }
            }
            return returnValue;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe byte PointAlongPathNV(this GL.NVExtension glInstance, uint path, int startSegment, int numSegments, float distance, ref float x, ref float y, ref float tangentX, ref float tangentY)
        {
            byte returnValue;
            fixed (float* x_ptr = &x) // RefInsteadOfPointerLayer
            fixed (float* y_ptr = &y) // RefInsteadOfPointerLayer
            fixed (float* tangentX_ptr = &tangentX) // RefInsteadOfPointerLayer
            fixed (float* tangentY_ptr = &tangentY) // RefInsteadOfPointerLayer
            {
                returnValue = glInstance.PointAlongPathNV(path, startSegment, numSegments, distance, x_ptr, y_ptr, tangentX_ptr, tangentY_ptr);
            }
            return returnValue;
        }

        // MatrixLoad3x2fNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MatrixLoad3x2fNV(this GL.NVExtension glInstance, GLEnum matrixMode, in float m)
        {
            fixed (float* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.MatrixLoad3x2fNV(matrixMode, m_ptr);
            }
        }

        // MatrixLoad3x3fNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MatrixLoad3x3fNV(this GL.NVExtension glInstance, GLEnum matrixMode, in float m)
        {
            fixed (float* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.MatrixLoad3x3fNV(matrixMode, m_ptr);
            }
        }

        // MatrixLoadTranspose3x3fNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MatrixLoadTranspose3x3fNV(this GL.NVExtension glInstance, GLEnum matrixMode, in float m)
        {
            fixed (float* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.MatrixLoadTranspose3x3fNV(matrixMode, m_ptr);
            }
        }

        // MatrixMult3x2fNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MatrixMult3x2fNV(this GL.NVExtension glInstance, GLEnum matrixMode, in float m)
        {
            fixed (float* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.MatrixMult3x2fNV(matrixMode, m_ptr);
            }
        }

        // MatrixMult3x3fNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MatrixMult3x3fNV(this GL.NVExtension glInstance, GLEnum matrixMode, in float m)
        {
            fixed (float* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.MatrixMult3x3fNV(matrixMode, m_ptr);
            }
        }

        // MatrixMultTranspose3x3fNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MatrixMultTranspose3x3fNV(this GL.NVExtension glInstance, GLEnum matrixMode, in float m)
        {
            fixed (float* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.MatrixMultTranspose3x3fNV(matrixMode, m_ptr);
            }
        }

        // StencilThenCoverFillPathInstancedNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void StencilThenCoverFillPathInstancedNV(this GL.NVExtension glInstance, int numPaths, GLEnum pathNameType, IntPtr paths, uint pathBase, GLEnum fillMode, uint mask, GLEnum coverMode, GLEnum transformType, in float transformValues)
        {
            fixed (float* transformValues_ptr = &transformValues) // RefInsteadOfPointerLayer
            {
                var paths_vptr = (void*)paths;
                glInstance.StencilThenCoverFillPathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, fillMode, mask, coverMode, transformType, transformValues_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void StencilThenCoverFillPathInstancedNV<T1>(this GL.NVExtension glInstance, int numPaths, GLEnum pathNameType, in T1 paths, uint pathBase, GLEnum fillMode, uint mask, GLEnum coverMode, GLEnum transformType, in float transformValues)
            where T1 : unmanaged
        {
            fixed (void* paths_ptr = &paths) // RefInsteadOfPointerLayer
            fixed (float* transformValues_ptr = &transformValues) // RefInsteadOfPointerLayer
            {
                glInstance.StencilThenCoverFillPathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, fillMode, mask, coverMode, transformType, transformValues_ptr);
            }
        }

        // StencilThenCoverStrokePathInstancedNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void StencilThenCoverStrokePathInstancedNV(this GL.NVExtension glInstance, int numPaths, GLEnum pathNameType, IntPtr paths, uint pathBase, int reference, uint mask, GLEnum coverMode, GLEnum transformType, in float transformValues)
        {
            fixed (float* transformValues_ptr = &transformValues) // RefInsteadOfPointerLayer
            {
                var paths_vptr = (void*)paths;
                glInstance.StencilThenCoverStrokePathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, reference, mask, coverMode, transformType, transformValues_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void StencilThenCoverStrokePathInstancedNV<T1>(this GL.NVExtension glInstance, int numPaths, GLEnum pathNameType, in T1 paths, uint pathBase, int reference, uint mask, GLEnum coverMode, GLEnum transformType, in float transformValues)
            where T1 : unmanaged
        {
            fixed (void* paths_ptr = &paths) // RefInsteadOfPointerLayer
            fixed (float* transformValues_ptr = &transformValues) // RefInsteadOfPointerLayer
            {
                glInstance.StencilThenCoverStrokePathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, reference, mask, coverMode, transformType, transformValues_ptr);
            }
        }

        // PathGlyphIndexRangeNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe GLEnum PathGlyphIndexRangeNV(this GL.NVExtension glInstance, GLEnum fontTarget, IntPtr fontName, PathFontStyle fontStyle, uint pathParameterTemplate, float emScale, Span<uint> baseAndCount)
        {
            GLEnum returnValue;
            fixed (uint* baseAndCount_ptr = baseAndCount) // SpanOrArrayLayer
            {
                var fontName_vptr = (void*)fontName;
                returnValue = glInstance.PathGlyphIndexRangeNV(fontTarget, fontName_vptr, fontStyle, pathParameterTemplate, emScale, baseAndCount_ptr);
            }
            return returnValue;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe GLEnum PathGlyphIndexRangeNV(this GL.NVExtension glInstance, GLEnum fontTarget, IntPtr fontName, PathFontStyle fontStyle, uint pathParameterTemplate, float emScale, uint[] baseAndCount)
        {
            GLEnum returnValue;
            fixed (uint* baseAndCount_ptr = baseAndCount) // SpanOrArrayLayer
            {
                var fontName_vptr = (void*)fontName;
                returnValue = glInstance.PathGlyphIndexRangeNV(fontTarget, fontName_vptr, fontStyle, pathParameterTemplate, emScale, baseAndCount_ptr);
            }
            return returnValue;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe GLEnum PathGlyphIndexRangeNV(this GL.NVExtension glInstance, GLEnum fontTarget, IntPtr fontName, PathFontStyle fontStyle, uint pathParameterTemplate, float emScale, ref uint baseAndCount)
        {
            GLEnum returnValue;
            fixed (uint* baseAndCount_ptr = &baseAndCount) // RefInsteadOfPointerLayer
            {
                var fontName_vptr = (void*)fontName;
                returnValue = glInstance.PathGlyphIndexRangeNV(fontTarget, fontName_vptr, fontStyle, pathParameterTemplate, emScale, baseAndCount_ptr);
            }
            return returnValue;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe GLEnum PathGlyphIndexRangeNV<T1>(this GL.NVExtension glInstance, GLEnum fontTarget, in T1 fontName, PathFontStyle fontStyle, uint pathParameterTemplate, float emScale, Span<uint> baseAndCount)
            where T1 : unmanaged
        {
            GLEnum returnValue;
            fixed (void* fontName_ptr = &fontName) // RefInsteadOfPointerLayer
            {
                fixed (uint* baseAndCount_ptr = baseAndCount) // SpanOrArrayLayer
                {
                    returnValue = glInstance.PathGlyphIndexRangeNV(fontTarget, fontName_ptr, fontStyle, pathParameterTemplate, emScale, baseAndCount_ptr);
                }
            }
            return returnValue;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe GLEnum PathGlyphIndexRangeNV<T1>(this GL.NVExtension glInstance, GLEnum fontTarget, in T1 fontName, PathFontStyle fontStyle, uint pathParameterTemplate, float emScale, uint[] baseAndCount)
            where T1 : unmanaged
        {
            GLEnum returnValue;
            fixed (void* fontName_ptr = &fontName) // RefInsteadOfPointerLayer
            {
                fixed (uint* baseAndCount_ptr = baseAndCount) // SpanOrArrayLayer
                {
                    returnValue = glInstance.PathGlyphIndexRangeNV(fontTarget, fontName_ptr, fontStyle, pathParameterTemplate, emScale, baseAndCount_ptr);
                }
            }
            return returnValue;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe GLEnum PathGlyphIndexRangeNV<T1>(this GL.NVExtension glInstance, GLEnum fontTarget, in T1 fontName, PathFontStyle fontStyle, uint pathParameterTemplate, float emScale, ref uint baseAndCount)
            where T1 : unmanaged
        {
            GLEnum returnValue;
            fixed (void* fontName_ptr = &fontName) // RefInsteadOfPointerLayer
            fixed (uint* baseAndCount_ptr = &baseAndCount) // RefInsteadOfPointerLayer
            {
                returnValue = glInstance.PathGlyphIndexRangeNV(fontTarget, fontName_ptr, fontStyle, pathParameterTemplate, emScale, baseAndCount_ptr);
            }
            return returnValue;
        }

        // PathGlyphIndexArrayNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe GLEnum PathGlyphIndexArrayNV(this GL.NVExtension glInstance, uint firstPathName, GLEnum fontTarget, IntPtr fontName, PathFontStyle fontStyle, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale)
        {
            GLEnum returnValue;
            var fontName_vptr = (void*)fontName;
            returnValue = glInstance.PathGlyphIndexArrayNV(firstPathName, fontTarget, fontName_vptr, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
            return returnValue;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe GLEnum PathGlyphIndexArrayNV<T1>(this GL.NVExtension glInstance, uint firstPathName, GLEnum fontTarget, in T1 fontName, PathFontStyle fontStyle, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale)
            where T1 : unmanaged
        {
            GLEnum returnValue;
            fixed (void* fontName_ptr = &fontName) // RefInsteadOfPointerLayer
            {
                returnValue = glInstance.PathGlyphIndexArrayNV(firstPathName, fontTarget, fontName_ptr, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
            }
            return returnValue;
        }

        // PathMemoryGlyphIndexArrayNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe GLEnum PathMemoryGlyphIndexArrayNV(this GL.NVExtension glInstance, uint firstPathName, GLEnum fontTarget, nint fontSize, IntPtr fontData, int faceIndex, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale)
        {
            GLEnum returnValue;
            var fontData_vptr = (void*)fontData;
            returnValue = glInstance.PathMemoryGlyphIndexArrayNV(firstPathName, fontTarget, fontSize, fontData_vptr, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
            return returnValue;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe GLEnum PathMemoryGlyphIndexArrayNV<T1>(this GL.NVExtension glInstance, uint firstPathName, GLEnum fontTarget, nint fontSize, in T1 fontData, int faceIndex, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale)
            where T1 : unmanaged
        {
            GLEnum returnValue;
            fixed (void* fontData_ptr = &fontData) // RefInsteadOfPointerLayer
            {
                returnValue = glInstance.PathMemoryGlyphIndexArrayNV(firstPathName, fontTarget, fontSize, fontData_ptr, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
            }
            return returnValue;
        }

        // ProgramPathFragmentInputGenNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramPathFragmentInputGenNV(this GL.NVExtension glInstance, ProgramHandle program, int location, GLEnum genMode, int components, in float coeffs)
        {
            fixed (float* coeffs_ptr = &coeffs) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramPathFragmentInputGenNV(program, location, genMode, components, coeffs_ptr);
            }
        }

        // GetProgramResourcefvNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramResourcefvNV(this GL.NVExtension glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, int propCount, in GLEnum props, Span<int> length, Span<float> parameters)
        {
            fixed (GLEnum* props_ptr = &props) // RefInsteadOfPointerLayer
            {
                fixed (int* length_ptr = length) // SpanOrArrayLayer
                {
                    var count = (int)(parameters.Length);
                    fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
                    {
                        glInstance.GetProgramResourcefvNV(program, programInterface, index, propCount, props_ptr, count, length_ptr, parameters_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramResourcefvNV(this GL.NVExtension glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, int propCount, in GLEnum props, int[] length, float[] parameters)
        {
            fixed (GLEnum* props_ptr = &props) // RefInsteadOfPointerLayer
            {
                fixed (int* length_ptr = length) // SpanOrArrayLayer
                {
                    var count = (int)(parameters.Length);
                    fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
                    {
                        glInstance.GetProgramResourcefvNV(program, programInterface, index, propCount, props_ptr, count, length_ptr, parameters_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramResourcefvNV(this GL.NVExtension glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, int propCount, in GLEnum props, int count, ref int length, ref float parameters)
        {
            fixed (GLEnum* props_ptr = &props) // RefInsteadOfPointerLayer
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetProgramResourcefvNV(program, programInterface, index, propCount, props_ptr, count, length_ptr, parameters_ptr);
            }
        }

        // PathColorGenNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathColorGenNV(this GL.NVExtension glInstance, PathColor color, PathGenMode genMode, PathColorFormat colorFormat, ReadOnlySpan<float> coeffs)
        {
            fixed (float* coeffs_ptr = coeffs) // SpanOrArrayLayer
            {
                glInstance.PathColorGenNV(color, genMode, colorFormat, coeffs_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathColorGenNV(this GL.NVExtension glInstance, PathColor color, PathGenMode genMode, PathColorFormat colorFormat, float[] coeffs)
        {
            fixed (float* coeffs_ptr = coeffs) // SpanOrArrayLayer
            {
                glInstance.PathColorGenNV(color, genMode, colorFormat, coeffs_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void PathColorGenNV(this GL.NVExtension glInstance, PathColor color, PathGenMode genMode, PathColorFormat colorFormat, in float coeffs)
        {
            fixed (float* coeffs_ptr = &coeffs) // RefInsteadOfPointerLayer
            {
                glInstance.PathColorGenNV(color, genMode, colorFormat, coeffs_ptr);
            }
        }

        // PathTexGenNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathTexGenNV(this GL.NVExtension glInstance, PathColor texCoordSet, PathGenMode genMode, int components, ReadOnlySpan<float> coeffs)
        {
            fixed (float* coeffs_ptr = coeffs) // SpanOrArrayLayer
            {
                glInstance.PathTexGenNV(texCoordSet, genMode, components, coeffs_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PathTexGenNV(this GL.NVExtension glInstance, PathColor texCoordSet, PathGenMode genMode, int components, float[] coeffs)
        {
            fixed (float* coeffs_ptr = coeffs) // SpanOrArrayLayer
            {
                glInstance.PathTexGenNV(texCoordSet, genMode, components, coeffs_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void PathTexGenNV(this GL.NVExtension glInstance, PathColor texCoordSet, PathGenMode genMode, int components, in float coeffs)
        {
            fixed (float* coeffs_ptr = &coeffs) // RefInsteadOfPointerLayer
            {
                glInstance.PathTexGenNV(texCoordSet, genMode, components, coeffs_ptr);
            }
        }

        // GetPathColorGenivNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathColorGenivNV(this GL.NVExtension glInstance, PathColor color, PathGenMode pname, Span<int> value)
        {
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.GetPathColorGenivNV(color, pname, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathColorGenivNV(this GL.NVExtension glInstance, PathColor color, PathGenMode pname, int[] value)
        {
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.GetPathColorGenivNV(color, pname, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetPathColorGenivNV(this GL.NVExtension glInstance, PathColor color, PathGenMode pname, ref int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.GetPathColorGenivNV(color, pname, value_ptr);
            }
        }

        // GetPathColorGenfvNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathColorGenfvNV(this GL.NVExtension glInstance, PathColor color, PathGenMode pname, Span<float> value)
        {
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.GetPathColorGenfvNV(color, pname, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathColorGenfvNV(this GL.NVExtension glInstance, PathColor color, PathGenMode pname, float[] value)
        {
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.GetPathColorGenfvNV(color, pname, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetPathColorGenfvNV(this GL.NVExtension glInstance, PathColor color, PathGenMode pname, ref float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.GetPathColorGenfvNV(color, pname, value_ptr);
            }
        }

        // GetPathTexGenivNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathTexGenivNV(this GL.NVExtension glInstance, TextureUnit texCoordSet, PathGenMode pname, Span<int> value)
        {
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.GetPathTexGenivNV(texCoordSet, pname, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathTexGenivNV(this GL.NVExtension glInstance, TextureUnit texCoordSet, PathGenMode pname, int[] value)
        {
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.GetPathTexGenivNV(texCoordSet, pname, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetPathTexGenivNV(this GL.NVExtension glInstance, TextureUnit texCoordSet, PathGenMode pname, ref int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.GetPathTexGenivNV(texCoordSet, pname, value_ptr);
            }
        }

        // GetPathTexGenfvNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathTexGenfvNV(this GL.NVExtension glInstance, TextureUnit texCoordSet, PathGenMode pname, Span<float> value)
        {
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.GetPathTexGenfvNV(texCoordSet, pname, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPathTexGenfvNV(this GL.NVExtension glInstance, TextureUnit texCoordSet, PathGenMode pname, float[] value)
        {
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.GetPathTexGenfvNV(texCoordSet, pname, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetPathTexGenfvNV(this GL.NVExtension glInstance, TextureUnit texCoordSet, PathGenMode pname, ref float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.GetPathTexGenfvNV(texCoordSet, pname, value_ptr);
            }
        }

        // MatrixLoadTransposefEXT overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MatrixLoadTransposefEXT(this GL.NVExtension glInstance, MatrixMode mode, ReadOnlySpan<float> m)
        {
            fixed (float* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MatrixLoadTransposefEXT(mode, m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MatrixLoadTransposefEXT(this GL.NVExtension glInstance, MatrixMode mode, float[] m)
        {
            fixed (float* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MatrixLoadTransposefEXT(mode, m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MatrixLoadTransposefEXT(this GL.NVExtension glInstance, MatrixMode mode, in float m)
        {
            fixed (float* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.MatrixLoadTransposefEXT(mode, m_ptr);
            }
        }

        // MatrixLoadTransposedEXT overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MatrixLoadTransposedEXT(this GL.NVExtension glInstance, MatrixMode mode, ReadOnlySpan<double> m)
        {
            fixed (double* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MatrixLoadTransposedEXT(mode, m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MatrixLoadTransposedEXT(this GL.NVExtension glInstance, MatrixMode mode, double[] m)
        {
            fixed (double* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MatrixLoadTransposedEXT(mode, m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MatrixLoadTransposedEXT(this GL.NVExtension glInstance, MatrixMode mode, in double m)
        {
            fixed (double* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.MatrixLoadTransposedEXT(mode, m_ptr);
            }
        }

        // MatrixLoadfEXT overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MatrixLoadfEXT(this GL.NVExtension glInstance, MatrixMode mode, ReadOnlySpan<float> m)
        {
            fixed (float* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MatrixLoadfEXT(mode, m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MatrixLoadfEXT(this GL.NVExtension glInstance, MatrixMode mode, float[] m)
        {
            fixed (float* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MatrixLoadfEXT(mode, m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MatrixLoadfEXT(this GL.NVExtension glInstance, MatrixMode mode, in float m)
        {
            fixed (float* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.MatrixLoadfEXT(mode, m_ptr);
            }
        }

        // MatrixLoaddEXT overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MatrixLoaddEXT(this GL.NVExtension glInstance, MatrixMode mode, ReadOnlySpan<double> m)
        {
            fixed (double* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MatrixLoaddEXT(mode, m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MatrixLoaddEXT(this GL.NVExtension glInstance, MatrixMode mode, double[] m)
        {
            fixed (double* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MatrixLoaddEXT(mode, m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MatrixLoaddEXT(this GL.NVExtension glInstance, MatrixMode mode, in double m)
        {
            fixed (double* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.MatrixLoaddEXT(mode, m_ptr);
            }
        }

        // MatrixMultTransposefEXT overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MatrixMultTransposefEXT(this GL.NVExtension glInstance, MatrixMode mode, ReadOnlySpan<float> m)
        {
            fixed (float* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MatrixMultTransposefEXT(mode, m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MatrixMultTransposefEXT(this GL.NVExtension glInstance, MatrixMode mode, float[] m)
        {
            fixed (float* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MatrixMultTransposefEXT(mode, m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MatrixMultTransposefEXT(this GL.NVExtension glInstance, MatrixMode mode, in float m)
        {
            fixed (float* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.MatrixMultTransposefEXT(mode, m_ptr);
            }
        }

        // MatrixMultTransposedEXT overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MatrixMultTransposedEXT(this GL.NVExtension glInstance, MatrixMode mode, ReadOnlySpan<double> m)
        {
            fixed (double* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MatrixMultTransposedEXT(mode, m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MatrixMultTransposedEXT(this GL.NVExtension glInstance, MatrixMode mode, double[] m)
        {
            fixed (double* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MatrixMultTransposedEXT(mode, m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MatrixMultTransposedEXT(this GL.NVExtension glInstance, MatrixMode mode, in double m)
        {
            fixed (double* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.MatrixMultTransposedEXT(mode, m_ptr);
            }
        }

        // MatrixMultfEXT overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MatrixMultfEXT(this GL.NVExtension glInstance, MatrixMode mode, ReadOnlySpan<float> m)
        {
            fixed (float* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MatrixMultfEXT(mode, m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MatrixMultfEXT(this GL.NVExtension glInstance, MatrixMode mode, float[] m)
        {
            fixed (float* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MatrixMultfEXT(mode, m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MatrixMultfEXT(this GL.NVExtension glInstance, MatrixMode mode, in float m)
        {
            fixed (float* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.MatrixMultfEXT(mode, m_ptr);
            }
        }

        // MatrixMultdEXT overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MatrixMultdEXT(this GL.NVExtension glInstance, MatrixMode mode, ReadOnlySpan<double> m)
        {
            fixed (double* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MatrixMultdEXT(mode, m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MatrixMultdEXT(this GL.NVExtension glInstance, MatrixMode mode, double[] m)
        {
            fixed (double* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MatrixMultdEXT(mode, m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MatrixMultdEXT(this GL.NVExtension glInstance, MatrixMode mode, in double m)
        {
            fixed (double* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.MatrixMultdEXT(mode, m_ptr);
            }
        }

        // FramebufferSampleLocationsfvNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void FramebufferSampleLocationsfvNV(this GL.NVExtension glInstance, FramebufferTarget target, uint start, int count, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.FramebufferSampleLocationsfvNV(target, start, count, v_ptr);
            }
        }

        // NamedFramebufferSampleLocationsfvNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void NamedFramebufferSampleLocationsfvNV(this GL.NVExtension glInstance, FramebufferHandle framebuffer, uint start, int count, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.NamedFramebufferSampleLocationsfvNV(framebuffer, start, count, v_ptr);
            }
        }

        // ScissorExclusiveArrayvNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ScissorExclusiveArrayvNV(this GL.NVExtension glInstance, uint first, int count, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ScissorExclusiveArrayvNV(first, count, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ScissorExclusiveArrayvNV(this GL.NVExtension glInstance, uint first, int count, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ScissorExclusiveArrayvNV(first, count, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ScissorExclusiveArrayvNV(this GL.NVExtension glInstance, uint first, int count, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.ScissorExclusiveArrayvNV(first, count, v_ptr);
            }
        }

        // GetShadingRateImagePaletteNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetShadingRateImagePaletteNV(this GL.NVExtension glInstance, uint viewport, uint entry, Span<GLEnum> rate)
        {
            fixed (GLEnum* rate_ptr = rate) // SpanOrArrayLayer
            {
                glInstance.GetShadingRateImagePaletteNV(viewport, entry, rate_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetShadingRateImagePaletteNV(this GL.NVExtension glInstance, uint viewport, uint entry, GLEnum[] rate)
        {
            fixed (GLEnum* rate_ptr = rate) // SpanOrArrayLayer
            {
                glInstance.GetShadingRateImagePaletteNV(viewport, entry, rate_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetShadingRateImagePaletteNV(this GL.NVExtension glInstance, uint viewport, uint entry, ref GLEnum rate)
        {
            fixed (GLEnum* rate_ptr = &rate) // RefInsteadOfPointerLayer
            {
                glInstance.GetShadingRateImagePaletteNV(viewport, entry, rate_ptr);
            }
        }

        // GetShadingRateSampleLocationivNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetShadingRateSampleLocationivNV(this GL.NVExtension glInstance, GLEnum rate, uint samples, uint index, Span<int> location)
        {
            fixed (int* location_ptr = location) // SpanOrArrayLayer
            {
                glInstance.GetShadingRateSampleLocationivNV(rate, samples, index, location_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetShadingRateSampleLocationivNV(this GL.NVExtension glInstance, GLEnum rate, uint samples, uint index, int[] location)
        {
            fixed (int* location_ptr = location) // SpanOrArrayLayer
            {
                glInstance.GetShadingRateSampleLocationivNV(rate, samples, index, location_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetShadingRateSampleLocationivNV(this GL.NVExtension glInstance, GLEnum rate, uint samples, uint index, ref int location)
        {
            fixed (int* location_ptr = &location) // RefInsteadOfPointerLayer
            {
                glInstance.GetShadingRateSampleLocationivNV(rate, samples, index, location_ptr);
            }
        }

        // ShadingRateImageBarrierNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void ShadingRateImageBarrierNV(this GL.NVExtension glInstance, bool synchronize)
        {
            var synchronize_byte = (byte)(synchronize ? 1 : 0);
            glInstance.ShadingRateImageBarrierNV(synchronize_byte);
        }

        // ShadingRateImagePaletteNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ShadingRateImagePaletteNV(this GL.NVExtension glInstance, uint viewport, uint first, ReadOnlySpan<GLEnum> rates)
        {
            var count = (int)(rates.Length);
            fixed (GLEnum* rates_ptr = rates) // SpanOrArrayLayer
            {
                glInstance.ShadingRateImagePaletteNV(viewport, first, count, rates_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ShadingRateImagePaletteNV(this GL.NVExtension glInstance, uint viewport, uint first, GLEnum[] rates)
        {
            var count = (int)(rates.Length);
            fixed (GLEnum* rates_ptr = rates) // SpanOrArrayLayer
            {
                glInstance.ShadingRateImagePaletteNV(viewport, first, count, rates_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ShadingRateImagePaletteNV(this GL.NVExtension glInstance, uint viewport, uint first, int count, in GLEnum rates)
        {
            fixed (GLEnum* rates_ptr = &rates) // RefInsteadOfPointerLayer
            {
                glInstance.ShadingRateImagePaletteNV(viewport, first, count, rates_ptr);
            }
        }

        // ShadingRateSampleOrderCustomNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ShadingRateSampleOrderCustomNV(this GL.NVExtension glInstance, GLEnum rate, uint samples, ReadOnlySpan<int> locations)
        {
            fixed (int* locations_ptr = locations) // SpanOrArrayLayer
            {
                glInstance.ShadingRateSampleOrderCustomNV(rate, samples, locations_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ShadingRateSampleOrderCustomNV(this GL.NVExtension glInstance, GLEnum rate, uint samples, int[] locations)
        {
            fixed (int* locations_ptr = locations) // SpanOrArrayLayer
            {
                glInstance.ShadingRateSampleOrderCustomNV(rate, samples, locations_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ShadingRateSampleOrderCustomNV(this GL.NVExtension glInstance, GLEnum rate, uint samples, in int locations)
        {
            fixed (int* locations_ptr = &locations) // RefInsteadOfPointerLayer
            {
                glInstance.ShadingRateSampleOrderCustomNV(rate, samples, locations_ptr);
            }
        }

        // ViewportArrayvNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ViewportArrayvNV(this GL.NVExtension glInstance, uint first, int count, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ViewportArrayvNV(first, count, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ViewportArrayvNV(this GL.NVExtension glInstance, uint first, int count, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ViewportArrayvNV(first, count, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ViewportArrayvNV(this GL.NVExtension glInstance, uint first, int count, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.ViewportArrayvNV(first, count, v_ptr);
            }
        }

        // ViewportIndexedfvNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ViewportIndexedfvNV(this GL.NVExtension glInstance, uint index, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ViewportIndexedfvNV(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ViewportIndexedfvNV(this GL.NVExtension glInstance, uint index, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ViewportIndexedfvNV(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ViewportIndexedfvNV(this GL.NVExtension glInstance, uint index, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.ViewportIndexedfvNV(index, v_ptr);
            }
        }

        // ScissorArrayvNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ScissorArrayvNV(this GL.NVExtension glInstance, uint first, int count, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ScissorArrayvNV(first, count, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ScissorArrayvNV(this GL.NVExtension glInstance, uint first, int count, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ScissorArrayvNV(first, count, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ScissorArrayvNV(this GL.NVExtension glInstance, uint first, int count, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.ScissorArrayvNV(first, count, v_ptr);
            }
        }

        // ScissorIndexedvNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ScissorIndexedvNV(this GL.NVExtension glInstance, uint index, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ScissorIndexedvNV(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ScissorIndexedvNV(this GL.NVExtension glInstance, uint index, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ScissorIndexedvNV(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ScissorIndexedvNV(this GL.NVExtension glInstance, uint index, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.ScissorIndexedvNV(index, v_ptr);
            }
        }

        // DepthRangeArrayfvNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DepthRangeArrayfvNV(this GL.NVExtension glInstance, uint first, int count, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.DepthRangeArrayfvNV(first, count, v_ptr);
            }
        }

        // GetFloati_vNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetFloati_vNV(this GL.NVExtension glInstance, GetPName target, uint index, Span<float> data)
        {
            fixed (float* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetFloati_vNV(target, index, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetFloati_vNV(this GL.NVExtension glInstance, GetPName target, uint index, float[] data)
        {
            fixed (float* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetFloati_vNV(target, index, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetFloati_vNV(this GL.NVExtension glInstance, GetPName target, uint index, ref float data)
        {
            fixed (float* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetFloati_vNV(target, index, data_ptr);
            }
        }
    }

#pragma warning restore IDE1006 // Naming Styles
}
