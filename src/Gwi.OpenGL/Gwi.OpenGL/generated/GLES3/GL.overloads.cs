// This file is auto generated, do not edit.
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Gwi.OpenGL.GLES3
{
#pragma warning disable IDE1006 // Naming Styles

    public static class GLOverloads
    {
        // BindAttribLocation overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe void BindAttribLocation(this GL glInstance, ProgramHandle program, uint index, string name)
        {
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            glInstance.BindAttribLocation(program, index, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
        }

        // BufferData overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void BufferData(this GL glInstance, BufferTargetARB target, nint size, IntPtr data, BufferUsageARB usage)
        {
            var data_vptr = (void*)data;
            glInstance.BufferData(target, size, data_vptr, usage);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BufferData<T1>(this GL glInstance, BufferTargetARB target, ReadOnlySpan<T1> data, BufferUsageARB usage)
            where T1 : unmanaged
        {
            var size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.BufferData(target, size, data_ptr, usage);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BufferData<T1>(this GL glInstance, BufferTargetARB target, T1[] data, BufferUsageARB usage)
            where T1 : unmanaged
        {
            var size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.BufferData(target, size, data_ptr, usage);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void BufferData<T1>(this GL glInstance, BufferTargetARB target, nint size, in T1 data, BufferUsageARB usage)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.BufferData(target, size, data_ptr, usage);
            }
        }

        // BufferSubData overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void BufferSubData(this GL glInstance, BufferTargetARB target, IntPtr offset, nint size, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.BufferSubData(target, offset, size, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BufferSubData<T1>(this GL glInstance, BufferTargetARB target, IntPtr offset, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            var size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.BufferSubData(target, offset, size, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BufferSubData<T1>(this GL glInstance, BufferTargetARB target, IntPtr offset, T1[] data)
            where T1 : unmanaged
        {
            var size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.BufferSubData(target, offset, size, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void BufferSubData<T1>(this GL glInstance, BufferTargetARB target, IntPtr offset, nint size, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.BufferSubData(target, offset, size, data_ptr);
            }
        }

        // ColorMask overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void ColorMask(this GL glInstance, bool red, bool green, bool blue, bool alpha)
        {
            var red_byte = (byte)(red ? 1 : 0);
            var green_byte = (byte)(green ? 1 : 0);
            var blue_byte = (byte)(blue ? 1 : 0);
            var alpha_byte = (byte)(alpha ? 1 : 0);
            glInstance.ColorMask(red_byte, green_byte, blue_byte, alpha_byte);
        }

        // CompressedTexImage2D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void CompressedTexImage2D(this GL glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexImage2D<T1>(this GL glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexImage2D<T1>(this GL glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, T1[] data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CompressedTexImage2D<T1>(this GL glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data_ptr);
            }
        }

        // CompressedTexSubImage2D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void CompressedTexSubImage2D(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexSubImage2D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexSubImage2D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, T1[] data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CompressedTexSubImage2D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data_ptr);
            }
        }

        // DeleteBuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void DeleteBuffer(this GL glInstance, in BufferHandle buffers)
        {
            int n = 1;
            fixed(BufferHandle* buffers_handle = &buffers) // DeleteOverloadLayer
                glInstance.DeleteBuffers(n, buffers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteBuffers(this GL glInstance, ReadOnlySpan<BufferHandle> buffers)
        {
            var n = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                glInstance.DeleteBuffers(n, buffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteBuffers(this GL glInstance, BufferHandle[] buffers)
        {
            var n = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                glInstance.DeleteBuffers(n, buffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteBuffers(this GL glInstance, int n, in BufferHandle buffers)
        {
            fixed (BufferHandle* buffers_ptr = &buffers) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteBuffers(n, buffers_ptr);
            }
        }

        // DeleteFramebuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void DeleteFramebuffer(this GL glInstance, in FramebufferHandle framebuffers)
        {
            int n = 1;
            fixed(FramebufferHandle* framebuffers_handle = &framebuffers) // DeleteOverloadLayer
                glInstance.DeleteFramebuffers(n, framebuffers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteFramebuffers(this GL glInstance, ReadOnlySpan<FramebufferHandle> framebuffers)
        {
            var n = (int)(framebuffers.Length);
            fixed (FramebufferHandle* framebuffers_ptr = framebuffers) // SpanOrArrayLayer
            {
                glInstance.DeleteFramebuffers(n, framebuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteFramebuffers(this GL glInstance, FramebufferHandle[] framebuffers)
        {
            var n = (int)(framebuffers.Length);
            fixed (FramebufferHandle* framebuffers_ptr = framebuffers) // SpanOrArrayLayer
            {
                glInstance.DeleteFramebuffers(n, framebuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteFramebuffers(this GL glInstance, int n, in FramebufferHandle framebuffers)
        {
            fixed (FramebufferHandle* framebuffers_ptr = &framebuffers) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteFramebuffers(n, framebuffers_ptr);
            }
        }

        // DeleteRenderbuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void DeleteRenderbuffer(this GL glInstance, in RenderbufferHandle renderbuffers)
        {
            int n = 1;
            fixed(RenderbufferHandle* renderbuffers_handle = &renderbuffers) // DeleteOverloadLayer
                glInstance.DeleteRenderbuffers(n, renderbuffers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteRenderbuffers(this GL glInstance, ReadOnlySpan<RenderbufferHandle> renderbuffers)
        {
            var n = (int)(renderbuffers.Length);
            fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers) // SpanOrArrayLayer
            {
                glInstance.DeleteRenderbuffers(n, renderbuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteRenderbuffers(this GL glInstance, RenderbufferHandle[] renderbuffers)
        {
            var n = (int)(renderbuffers.Length);
            fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers) // SpanOrArrayLayer
            {
                glInstance.DeleteRenderbuffers(n, renderbuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteRenderbuffers(this GL glInstance, int n, in RenderbufferHandle renderbuffers)
        {
            fixed (RenderbufferHandle* renderbuffers_ptr = &renderbuffers) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteRenderbuffers(n, renderbuffers_ptr);
            }
        }

        // DeleteTextures overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void DeleteTexture(this GL glInstance, in TextureHandle textures)
        {
            int n = 1;
            fixed(TextureHandle* textures_handle = &textures) // DeleteOverloadLayer
                glInstance.DeleteTextures(n, textures_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteTextures(this GL glInstance, ReadOnlySpan<TextureHandle> textures)
        {
            var n = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures) // SpanOrArrayLayer
            {
                glInstance.DeleteTextures(n, textures_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteTextures(this GL glInstance, TextureHandle[] textures)
        {
            var n = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures) // SpanOrArrayLayer
            {
                glInstance.DeleteTextures(n, textures_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteTextures(this GL glInstance, int n, in TextureHandle textures)
        {
            fixed (TextureHandle* textures_ptr = &textures) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteTextures(n, textures_ptr);
            }
        }

        // DepthMask overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void DepthMask(this GL glInstance, bool flag)
        {
            var flag_byte = (byte)(flag ? 1 : 0);
            glInstance.DepthMask(flag_byte);
        }

        // DrawElements overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void DrawElements(this GL glInstance, PrimitiveType mode, int count, DrawElementsType type, nint offset)
        {
            void* indices = (void*)offset;
            glInstance.DrawElements(mode, count, type, indices);
        }

        // GenBuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe BufferHandle GenBuffer(this GL glInstance)
        {
            BufferHandle buffers;
            int n = 1;
            Unsafe.SkipInit(out buffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            BufferHandle* buffers_handle = (BufferHandle*)Unsafe.AsPointer(ref buffers);
            glInstance.GenBuffers(n, buffers_handle);
            return buffers;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void GenBuffer(this GL glInstance, out BufferHandle buffers)
        {
            int n = 1;
            Unsafe.SkipInit(out buffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            BufferHandle* buffers_handle = (BufferHandle*)Unsafe.AsPointer(ref buffers);
            glInstance.GenBuffers(n, buffers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenBuffers(this GL glInstance, Span<BufferHandle> buffers)
        {
            var n = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                glInstance.GenBuffers(n, buffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenBuffers(this GL glInstance, BufferHandle[] buffers)
        {
            var n = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                glInstance.GenBuffers(n, buffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenBuffers(this GL glInstance, int n, ref BufferHandle buffers)
        {
            fixed (BufferHandle* buffers_ptr = &buffers) // RefInsteadOfPointerLayer
            {
                glInstance.GenBuffers(n, buffers_ptr);
            }
        }

        // GenFramebuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe FramebufferHandle GenFramebuffer(this GL glInstance)
        {
            FramebufferHandle framebuffers;
            int n = 1;
            Unsafe.SkipInit(out framebuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            FramebufferHandle* framebuffers_handle = (FramebufferHandle*)Unsafe.AsPointer(ref framebuffers);
            glInstance.GenFramebuffers(n, framebuffers_handle);
            return framebuffers;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void GenFramebuffer(this GL glInstance, out FramebufferHandle framebuffers)
        {
            int n = 1;
            Unsafe.SkipInit(out framebuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            FramebufferHandle* framebuffers_handle = (FramebufferHandle*)Unsafe.AsPointer(ref framebuffers);
            glInstance.GenFramebuffers(n, framebuffers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenFramebuffers(this GL glInstance, Span<FramebufferHandle> framebuffers)
        {
            var n = (int)(framebuffers.Length);
            fixed (FramebufferHandle* framebuffers_ptr = framebuffers) // SpanOrArrayLayer
            {
                glInstance.GenFramebuffers(n, framebuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenFramebuffers(this GL glInstance, FramebufferHandle[] framebuffers)
        {
            var n = (int)(framebuffers.Length);
            fixed (FramebufferHandle* framebuffers_ptr = framebuffers) // SpanOrArrayLayer
            {
                glInstance.GenFramebuffers(n, framebuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenFramebuffers(this GL glInstance, int n, ref FramebufferHandle framebuffers)
        {
            fixed (FramebufferHandle* framebuffers_ptr = &framebuffers) // RefInsteadOfPointerLayer
            {
                glInstance.GenFramebuffers(n, framebuffers_ptr);
            }
        }

        // GenRenderbuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe RenderbufferHandle GenRenderbuffer(this GL glInstance)
        {
            RenderbufferHandle renderbuffers;
            int n = 1;
            Unsafe.SkipInit(out renderbuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            RenderbufferHandle* renderbuffers_handle = (RenderbufferHandle*)Unsafe.AsPointer(ref renderbuffers);
            glInstance.GenRenderbuffers(n, renderbuffers_handle);
            return renderbuffers;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void GenRenderbuffer(this GL glInstance, out RenderbufferHandle renderbuffers)
        {
            int n = 1;
            Unsafe.SkipInit(out renderbuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            RenderbufferHandle* renderbuffers_handle = (RenderbufferHandle*)Unsafe.AsPointer(ref renderbuffers);
            glInstance.GenRenderbuffers(n, renderbuffers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenRenderbuffers(this GL glInstance, Span<RenderbufferHandle> renderbuffers)
        {
            var n = (int)(renderbuffers.Length);
            fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers) // SpanOrArrayLayer
            {
                glInstance.GenRenderbuffers(n, renderbuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenRenderbuffers(this GL glInstance, RenderbufferHandle[] renderbuffers)
        {
            var n = (int)(renderbuffers.Length);
            fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers) // SpanOrArrayLayer
            {
                glInstance.GenRenderbuffers(n, renderbuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenRenderbuffers(this GL glInstance, int n, ref RenderbufferHandle renderbuffers)
        {
            fixed (RenderbufferHandle* renderbuffers_ptr = &renderbuffers) // RefInsteadOfPointerLayer
            {
                glInstance.GenRenderbuffers(n, renderbuffers_ptr);
            }
        }

        // GenTextures overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe TextureHandle GenTexture(this GL glInstance)
        {
            TextureHandle textures;
            int n = 1;
            Unsafe.SkipInit(out textures);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TextureHandle* textures_handle = (TextureHandle*)Unsafe.AsPointer(ref textures);
            glInstance.GenTextures(n, textures_handle);
            return textures;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void GenTexture(this GL glInstance, out TextureHandle textures)
        {
            int n = 1;
            Unsafe.SkipInit(out textures);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TextureHandle* textures_handle = (TextureHandle*)Unsafe.AsPointer(ref textures);
            glInstance.GenTextures(n, textures_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenTextures(this GL glInstance, Span<TextureHandle> textures)
        {
            var n = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures) // SpanOrArrayLayer
            {
                glInstance.GenTextures(n, textures_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenTextures(this GL glInstance, TextureHandle[] textures)
        {
            var n = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures) // SpanOrArrayLayer
            {
                glInstance.GenTextures(n, textures_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenTextures(this GL glInstance, int n, ref TextureHandle textures)
        {
            fixed (TextureHandle* textures_ptr = &textures) // RefInsteadOfPointerLayer
            {
                glInstance.GenTextures(n, textures_ptr);
            }
        }

        // GetActiveAttrib overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveAttrib(this GL glInstance, ProgramHandle program, uint index, int bufSize, Span<int> length, Span<int> size, Span<AttributeType> type)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (AttributeType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        glInstance.GetActiveAttrib(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveAttrib(this GL glInstance, ProgramHandle program, uint index, int bufSize, Span<int> length, Span<int> size, Span<AttributeType> type, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (AttributeType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        glInstance.GetActiveAttrib(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveAttrib(this GL glInstance, ProgramHandle program, uint index, int bufSize, int[] length, int[] size, AttributeType[] type)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (AttributeType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        glInstance.GetActiveAttrib(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveAttrib(this GL glInstance, ProgramHandle program, uint index, int bufSize, int[] length, int[] size, AttributeType[] type, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (AttributeType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        glInstance.GetActiveAttrib(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveAttrib(this GL glInstance, ProgramHandle program, uint index, int bufSize, ref int length, ref int size, ref AttributeType type)
        {
            string name;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (int* size_ptr = &size) // RefInsteadOfPointerLayer
            fixed (AttributeType* type_ptr = &type) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveAttrib(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveAttrib(this GL glInstance, ProgramHandle program, uint index, int bufSize, ref int length, ref int size, ref AttributeType type, out string name)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (int* size_ptr = &size) // RefInsteadOfPointerLayer
            fixed (AttributeType* type_ptr = &type) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveAttrib(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // GetActiveUniform overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveUniform(this GL glInstance, ProgramHandle program, uint index, int bufSize, Span<int> length, Span<int> size, Span<UniformType> type)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (UniformType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        glInstance.GetActiveUniform(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniform(this GL glInstance, ProgramHandle program, uint index, int bufSize, Span<int> length, Span<int> size, Span<UniformType> type, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (UniformType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        glInstance.GetActiveUniform(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveUniform(this GL glInstance, ProgramHandle program, uint index, int bufSize, int[] length, int[] size, UniformType[] type)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (UniformType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        glInstance.GetActiveUniform(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniform(this GL glInstance, ProgramHandle program, uint index, int bufSize, int[] length, int[] size, UniformType[] type, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (UniformType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        glInstance.GetActiveUniform(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveUniform(this GL glInstance, ProgramHandle program, uint index, int bufSize, ref int length, ref int size, ref UniformType type)
        {
            string name;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (int* size_ptr = &size) // RefInsteadOfPointerLayer
            fixed (UniformType* type_ptr = &type) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniform(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveUniform(this GL glInstance, ProgramHandle program, uint index, int bufSize, ref int length, ref int size, ref UniformType type, out string name)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (int* size_ptr = &size) // RefInsteadOfPointerLayer
            fixed (UniformType* type_ptr = &type) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniform(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // GetAttachedShaders overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetAttachedShaders(this GL glInstance, ProgramHandle program, Span<int> count, Span<ShaderHandle> shaders)
        {
            fixed (int* count_ptr = count) // SpanOrArrayLayer
            {
                var maxCount = (int)(shaders.Length);
                fixed (ShaderHandle* shaders_ptr = shaders) // SpanOrArrayLayer
                {
                    glInstance.GetAttachedShaders(program, maxCount, count_ptr, shaders_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetAttachedShaders(this GL glInstance, ProgramHandle program, int[] count, ShaderHandle[] shaders)
        {
            fixed (int* count_ptr = count) // SpanOrArrayLayer
            {
                var maxCount = (int)(shaders.Length);
                fixed (ShaderHandle* shaders_ptr = shaders) // SpanOrArrayLayer
                {
                    glInstance.GetAttachedShaders(program, maxCount, count_ptr, shaders_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetAttachedShaders(this GL glInstance, ProgramHandle program, int maxCount, ref int count, ref ShaderHandle shaders)
        {
            fixed (int* count_ptr = &count) // RefInsteadOfPointerLayer
            fixed (ShaderHandle* shaders_ptr = &shaders) // RefInsteadOfPointerLayer
            {
                glInstance.GetAttachedShaders(program, maxCount, count_ptr, shaders_ptr);
            }
        }

        // GetAttribLocation overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe int GetAttribLocation(this GL glInstance, ProgramHandle program, string name)
        {
            int returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = glInstance.GetAttribLocation(program, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }

        // GetBooleanv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetBoolean(this GL glInstance, GetPName pname, Span<byte> data)
        {
            fixed (byte* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetBooleanv(pname, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetBoolean(this GL glInstance, GetPName pname, byte[] data)
        {
            fixed (byte* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetBooleanv(pname, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetBoolean(this GL glInstance, GetPName pname, ref byte data)
        {
            fixed (byte* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetBooleanv(pname, data_ptr);
            }
        }

        // GetBufferParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetBufferParameteri(this GL glInstance, BufferTargetARB target, BufferPNameARB pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetBufferParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetBufferParameteri(this GL glInstance, BufferTargetARB target, BufferPNameARB pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetBufferParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetBufferParameteri(this GL glInstance, BufferTargetARB target, BufferPNameARB pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetBufferParameteriv(target, pname, parameters_ptr);
            }
        }

        // GetFloatv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetFloat(this GL glInstance, GetPName pname, Span<float> data)
        {
            fixed (float* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetFloatv(pname, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetFloat(this GL glInstance, GetPName pname, float[] data)
        {
            fixed (float* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetFloatv(pname, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetFloat(this GL glInstance, GetPName pname, ref float data)
        {
            fixed (float* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetFloatv(pname, data_ptr);
            }
        }

        // GetFramebufferAttachmentParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetFramebufferAttachmentParameteri(this GL glInstance, FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetFramebufferAttachmentParameteriv(target, attachment, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetFramebufferAttachmentParameteri(this GL glInstance, FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetFramebufferAttachmentParameteriv(target, attachment, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetFramebufferAttachmentParameteri(this GL glInstance, FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetFramebufferAttachmentParameteriv(target, attachment, pname, parameters_ptr);
            }
        }

        // GetIntegerv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInteger(this GL glInstance, GetPName pname, Span<int> data)
        {
            fixed (int* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetIntegerv(pname, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInteger(this GL glInstance, GetPName pname, int[] data)
        {
            fixed (int* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetIntegerv(pname, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetInteger(this GL glInstance, GetPName pname, ref int data)
        {
            fixed (int* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetIntegerv(pname, data_ptr);
            }
        }

        // GetProgramiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgrami(this GL glInstance, ProgramHandle program, ProgramPropertyARB pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramiv(program, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgrami(this GL glInstance, ProgramHandle program, ProgramPropertyARB pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramiv(program, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgrami(this GL glInstance, ProgramHandle program, ProgramPropertyARB pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetProgramiv(program, pname, parameters_ptr);
            }
        }

        // GetProgramInfoLog overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetProgramInfoLog(this GL glInstance, ProgramHandle program, int bufSize, Span<int> length)
        {
            string infoLog;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramInfoLog(program, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramInfoLog(this GL glInstance, ProgramHandle program, int bufSize, Span<int> length, out string infoLog)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramInfoLog(program, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetProgramInfoLog(this GL glInstance, ProgramHandle program, int bufSize, int[] length)
        {
            string infoLog;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramInfoLog(program, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramInfoLog(this GL glInstance, ProgramHandle program, int bufSize, int[] length, out string infoLog)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramInfoLog(program, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetProgramInfoLog(this GL glInstance, ProgramHandle program, int bufSize, ref int length)
        {
            string infoLog;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramInfoLog(program, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramInfoLog(this GL glInstance, ProgramHandle program, int bufSize, ref int length, out string infoLog)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramInfoLog(program, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }

        // GetRenderbufferParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetRenderbufferParameteri(this GL glInstance, RenderbufferTarget target, RenderbufferParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetRenderbufferParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetRenderbufferParameteri(this GL glInstance, RenderbufferTarget target, RenderbufferParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetRenderbufferParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetRenderbufferParameteri(this GL glInstance, RenderbufferTarget target, RenderbufferParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetRenderbufferParameteriv(target, pname, parameters_ptr);
            }
        }

        // GetShaderiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetShaderi(this GL glInstance, ShaderHandle shader, ShaderParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetShaderiv(shader, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetShaderi(this GL glInstance, ShaderHandle shader, ShaderParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetShaderiv(shader, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetShaderi(this GL glInstance, ShaderHandle shader, ShaderParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetShaderiv(shader, pname, parameters_ptr);
            }
        }

        // GetShaderInfoLog overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetShaderInfoLog(this GL glInstance, ShaderHandle shader, int bufSize, Span<int> length)
        {
            string infoLog;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetShaderInfoLog(shader, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetShaderInfoLog(this GL glInstance, ShaderHandle shader, int bufSize, Span<int> length, out string infoLog)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetShaderInfoLog(shader, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetShaderInfoLog(this GL glInstance, ShaderHandle shader, int bufSize, int[] length)
        {
            string infoLog;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetShaderInfoLog(shader, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetShaderInfoLog(this GL glInstance, ShaderHandle shader, int bufSize, int[] length, out string infoLog)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetShaderInfoLog(shader, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetShaderInfoLog(this GL glInstance, ShaderHandle shader, int bufSize, ref int length)
        {
            string infoLog;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetShaderInfoLog(shader, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetShaderInfoLog(this GL glInstance, ShaderHandle shader, int bufSize, ref int length, out string infoLog)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetShaderInfoLog(shader, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }

        // GetShaderPrecisionFormat overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetShaderPrecisionFormat(this GL glInstance, ShaderType shadertype, PrecisionType precisiontype, Span<int> range, Span<int> precision)
        {
            fixed (int* range_ptr = range) // SpanOrArrayLayer
            {
                fixed (int* precision_ptr = precision) // SpanOrArrayLayer
                {
                    glInstance.GetShaderPrecisionFormat(shadertype, precisiontype, range_ptr, precision_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetShaderPrecisionFormat(this GL glInstance, ShaderType shadertype, PrecisionType precisiontype, int[] range, int[] precision)
        {
            fixed (int* range_ptr = range) // SpanOrArrayLayer
            {
                fixed (int* precision_ptr = precision) // SpanOrArrayLayer
                {
                    glInstance.GetShaderPrecisionFormat(shadertype, precisiontype, range_ptr, precision_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetShaderPrecisionFormat(this GL glInstance, ShaderType shadertype, PrecisionType precisiontype, ref int range, ref int precision)
        {
            fixed (int* range_ptr = &range) // RefInsteadOfPointerLayer
            fixed (int* precision_ptr = &precision) // RefInsteadOfPointerLayer
            {
                glInstance.GetShaderPrecisionFormat(shadertype, precisiontype, range_ptr, precision_ptr);
            }
        }

        // GetShaderSource overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetShaderSource(this GL glInstance, ShaderHandle shader, int bufSize, Span<int> length)
        {
            string source;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var source_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetShaderSource(shader, bufSize, length_ptr, source_ptr);
                source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)source_ptr);
            }
            return source;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetShaderSource(this GL glInstance, ShaderHandle shader, int bufSize, Span<int> length, out string source)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var source_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetShaderSource(shader, bufSize, length_ptr, source_ptr);
                source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)source_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetShaderSource(this GL glInstance, ShaderHandle shader, int bufSize, int[] length)
        {
            string source;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var source_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetShaderSource(shader, bufSize, length_ptr, source_ptr);
                source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)source_ptr);
            }
            return source;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetShaderSource(this GL glInstance, ShaderHandle shader, int bufSize, int[] length, out string source)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var source_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetShaderSource(shader, bufSize, length_ptr, source_ptr);
                source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)source_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetShaderSource(this GL glInstance, ShaderHandle shader, int bufSize, ref int length)
        {
            string source;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var source_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetShaderSource(shader, bufSize, length_ptr, source_ptr);
                source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)source_ptr);
            }
            return source;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetShaderSource(this GL glInstance, ShaderHandle shader, int bufSize, ref int length, out string source)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var source_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetShaderSource(shader, bufSize, length_ptr, source_ptr);
                source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)source_ptr);
            }
        }

        // GetString_ overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.StringReturnOverloader
        public static unsafe string? GetString(this GL glInstance, StringName name)
        {
            byte* returnValue;
            string? returnValue_str;
            returnValue = glInstance.GetString_(name);
            returnValue_str = Marshaller.PtrToString((nint)returnValue);
            return returnValue_str;
        }

        // GetTexParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexParameterf(this GL glInstance, TextureTarget target, GetTextureParameter pname, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexParameterfv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexParameterf(this GL glInstance, TextureTarget target, GetTextureParameter pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexParameterfv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTexParameterf(this GL glInstance, TextureTarget target, GetTextureParameter pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTexParameterfv(target, pname, parameters_ptr);
            }
        }

        // GetTexParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexParameteri(this GL glInstance, TextureTarget target, GetTextureParameter pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexParameteri(this GL glInstance, TextureTarget target, GetTextureParameter pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTexParameteri(this GL glInstance, TextureTarget target, GetTextureParameter pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTexParameteriv(target, pname, parameters_ptr);
            }
        }

        // GetUniformfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformf(this GL glInstance, ProgramHandle program, int location, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformfv(program, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformf(this GL glInstance, ProgramHandle program, int location, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformfv(program, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetUniformf(this GL glInstance, ProgramHandle program, int location, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetUniformfv(program, location, parameters_ptr);
            }
        }

        // GetUniformiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformi(this GL glInstance, ProgramHandle program, int location, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformiv(program, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformi(this GL glInstance, ProgramHandle program, int location, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformiv(program, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetUniformi(this GL glInstance, ProgramHandle program, int location, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetUniformiv(program, location, parameters_ptr);
            }
        }

        // GetUniformLocation overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe int GetUniformLocation(this GL glInstance, ProgramHandle program, string name)
        {
            int returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = glInstance.GetUniformLocation(program, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }

        // GetVertexAttribfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribf(this GL glInstance, uint index, VertexAttribPropertyARB pname, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribfv(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribf(this GL glInstance, uint index, VertexAttribPropertyARB pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribfv(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetVertexAttribf(this GL glInstance, uint index, VertexAttribPropertyARB pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetVertexAttribfv(index, pname, parameters_ptr);
            }
        }

        // GetVertexAttribiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribi(this GL glInstance, uint index, VertexAttribPropertyARB pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribiv(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribi(this GL glInstance, uint index, VertexAttribPropertyARB pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribiv(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetVertexAttribi(this GL glInstance, uint index, VertexAttribPropertyARB pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetVertexAttribiv(index, pname, parameters_ptr);
            }
        }

        // GetVertexAttribPointerv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void GetVertexAttribPointer(this GL glInstance, uint index, VertexAttribPointerPropertyARB pname, void** pointer) =>
            glInstance.GetVertexAttribPointerv(index, pname, pointer);

        // ReadPixels overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ReadPixels(this GL glInstance, int x, int y, int width, int height, PixelFormat format, PixelType type, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.ReadPixels(x, y, width, height, format, type, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ReadPixels<T1>(this GL glInstance, int x, int y, int width, int height, PixelFormat format, PixelType type, Span<T1> pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.ReadPixels(x, y, width, height, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ReadPixels<T1>(this GL glInstance, int x, int y, int width, int height, PixelFormat format, PixelType type, T1[] pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.ReadPixels(x, y, width, height, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ReadPixels<T1>(this GL glInstance, int x, int y, int width, int height, PixelFormat format, PixelType type, ref T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.ReadPixels(x, y, width, height, format, type, pixels_ptr);
            }
        }

        // SampleCoverage overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void SampleCoverage(this GL glInstance, float value, bool invert)
        {
            var invert_byte = (byte)(invert ? 1 : 0);
            glInstance.SampleCoverage(value, invert_byte);
        }

        // ShaderBinary overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ShaderBinary(this GL glInstance, ReadOnlySpan<ShaderHandle> shaders, ShaderBinaryFormat binaryFormat, IntPtr binary, int length)
        {
            var count = (int)(shaders.Length);
            fixed (ShaderHandle* shaders_ptr = shaders) // SpanOrArrayLayer
            {
                var binary_vptr = (void*)binary;
                glInstance.ShaderBinary(count, shaders_ptr, binaryFormat, binary_vptr, length);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ShaderBinary(this GL glInstance, ShaderHandle[] shaders, ShaderBinaryFormat binaryFormat, IntPtr binary, int length)
        {
            var count = (int)(shaders.Length);
            fixed (ShaderHandle* shaders_ptr = shaders) // SpanOrArrayLayer
            {
                var binary_vptr = (void*)binary;
                glInstance.ShaderBinary(count, shaders_ptr, binaryFormat, binary_vptr, length);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ShaderBinary(this GL glInstance, int count, in ShaderHandle shaders, ShaderBinaryFormat binaryFormat, IntPtr binary, int length)
        {
            fixed (ShaderHandle* shaders_ptr = &shaders) // RefInsteadOfPointerLayer
            {
                var binary_vptr = (void*)binary;
                glInstance.ShaderBinary(count, shaders_ptr, binaryFormat, binary_vptr, length);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ShaderBinary<T1>(this GL glInstance, ReadOnlySpan<ShaderHandle> shaders, ShaderBinaryFormat binaryFormat, ReadOnlySpan<T1> binary)
            where T1 : unmanaged
        {
            var count = (int)(shaders.Length);
            fixed (ShaderHandle* shaders_ptr = shaders) // SpanOrArrayLayer
            {
                var length = (int)(binary.Length * sizeof(T1));
                fixed (void* binary_ptr = binary) // SpanOrArrayLayer
                {
                    glInstance.ShaderBinary(count, shaders_ptr, binaryFormat, binary_ptr, length);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ShaderBinary<T1>(this GL glInstance, ShaderHandle[] shaders, ShaderBinaryFormat binaryFormat, T1[] binary)
            where T1 : unmanaged
        {
            var count = (int)(shaders.Length);
            fixed (ShaderHandle* shaders_ptr = shaders) // SpanOrArrayLayer
            {
                var length = (int)(binary.Length * sizeof(T1));
                fixed (void* binary_ptr = binary) // SpanOrArrayLayer
                {
                    glInstance.ShaderBinary(count, shaders_ptr, binaryFormat, binary_ptr, length);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ShaderBinary<T1>(this GL glInstance, int count, in ShaderHandle shaders, ShaderBinaryFormat binaryFormat, in T1 binary, int length)
            where T1 : unmanaged
        {
            fixed (ShaderHandle* shaders_ptr = &shaders) // RefInsteadOfPointerLayer
            fixed (void* binary_ptr = &binary) // RefInsteadOfPointerLayer
            {
                glInstance.ShaderBinary(count, shaders_ptr, binaryFormat, binary_ptr, length);
            }
        }

        // ShaderSource overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ShaderSource(this GL glInstance, ShaderHandle shader, int count, byte** str, ReadOnlySpan<int> length)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                glInstance.ShaderSource(shader, count, str, length_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ShaderSource(this GL glInstance, ShaderHandle shader, int count, byte** str, int[] length)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                glInstance.ShaderSource(shader, count, str, length_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ShaderSource(this GL glInstance, ShaderHandle shader, int count, byte** str, in int length)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                glInstance.ShaderSource(shader, count, str, length_ptr);
            }
        }

        // TexImage2D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void TexImage2D(this GL glInstance, TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.TexImage2D(target, level, internalformat, width, height, border, format, type, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexImage2D<T1>(this GL glInstance, TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.TexImage2D(target, level, internalformat, width, height, border, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexImage2D<T1>(this GL glInstance, TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, T1[] pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.TexImage2D(target, level, internalformat, width, height, border, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexImage2D<T1>(this GL glInstance, TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.TexImage2D(target, level, internalformat, width, height, border, format, type, pixels_ptr);
            }
        }

        // TexParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexParameterf(this GL glInstance, TextureTarget target, TextureParameterName pname, ReadOnlySpan<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexParameterfv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexParameterf(this GL glInstance, TextureTarget target, TextureParameterName pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexParameterfv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexParameterf(this GL glInstance, TextureTarget target, TextureParameterName pname, in float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.TexParameterfv(target, pname, parameters_ptr);
            }
        }

        // TexParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexParameteri(this GL glInstance, TextureTarget target, TextureParameterName pname, ReadOnlySpan<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexParameteri(this GL glInstance, TextureTarget target, TextureParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexParameteri(this GL glInstance, TextureTarget target, TextureParameterName pname, in int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.TexParameteriv(target, pname, parameters_ptr);
            }
        }

        // TexSubImage2D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void TexSubImage2D(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.TexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexSubImage2D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.TexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexSubImage2D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, T1[] pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.TexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexSubImage2D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.TexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
            }
        }

        // Uniform1fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1fv(this GL glInstance, int location, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 1);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1fv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1fv(this GL glInstance, int location, float[] value)
        {
            var count = (int)(value.Length / 1);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1fv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform1fv(this GL glInstance, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform1fv(location, count, value_ptr);
            }
        }

        // Uniform1iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1iv(this GL glInstance, int location, ReadOnlySpan<int> value)
        {
            var count = (int)(value.Length / 1);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1iv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1iv(this GL glInstance, int location, int[] value)
        {
            var count = (int)(value.Length / 1);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1iv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform1iv(this GL glInstance, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform1iv(location, count, value_ptr);
            }
        }

        // Uniform2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2fv(this GL glInstance, int location, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 2);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2fv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2fv(this GL glInstance, int location, float[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2fv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform2fv(this GL glInstance, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform2fv(location, count, value_ptr);
            }
        }

        // Uniform2iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2iv(this GL glInstance, int location, ReadOnlySpan<int> value)
        {
            var count = (int)(value.Length / 2);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2iv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2iv(this GL glInstance, int location, int[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2iv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform2iv(this GL glInstance, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform2iv(location, count, value_ptr);
            }
        }

        // Uniform3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3fv(this GL glInstance, int location, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 3);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3fv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3fv(this GL glInstance, int location, float[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3fv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform3fv(this GL glInstance, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform3fv(location, count, value_ptr);
            }
        }

        // Uniform3iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3iv(this GL glInstance, int location, ReadOnlySpan<int> value)
        {
            var count = (int)(value.Length / 3);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3iv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3iv(this GL glInstance, int location, int[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3iv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform3iv(this GL glInstance, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform3iv(location, count, value_ptr);
            }
        }

        // Uniform4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4fv(this GL glInstance, int location, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 4);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4fv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4fv(this GL glInstance, int location, float[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4fv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform4fv(this GL glInstance, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform4fv(location, count, value_ptr);
            }
        }

        // Uniform4iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4iv(this GL glInstance, int location, ReadOnlySpan<int> value)
        {
            var count = (int)(value.Length / 4);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4iv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4iv(this GL glInstance, int location, int[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4iv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform4iv(this GL glInstance, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform4iv(location, count, value_ptr);
            }
        }

        // UniformMatrix2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2fv(this GL glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 4);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2fv(this GL glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix2fv(this GL glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2fv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3fv(this GL glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 9);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3fv(this GL glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 9);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix3fv(this GL glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3fv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4fv(this GL glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 16);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4fv(this GL glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 16);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix4fv(this GL glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4fv(location, count, transpose_byte, value_ptr);
            }
        }

        // VertexAttrib1fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib1fv(this GL glInstance, uint index, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib1fv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib1fv(this GL glInstance, uint index, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib1fv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib1fv(this GL glInstance, uint index, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib1fv(index, v_ptr);
            }
        }

        // VertexAttrib2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib2fv(this GL glInstance, uint index, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib2fv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib2fv(this GL glInstance, uint index, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib2fv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib2fv(this GL glInstance, uint index, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib2fv(index, v_ptr);
            }
        }

        // VertexAttrib3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib3fv(this GL glInstance, uint index, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib3fv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib3fv(this GL glInstance, uint index, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib3fv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib3fv(this GL glInstance, uint index, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib3fv(index, v_ptr);
            }
        }

        // VertexAttrib4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4fv(this GL glInstance, uint index, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4fv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4fv(this GL glInstance, uint index, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4fv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4fv(this GL glInstance, uint index, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4fv(index, v_ptr);
            }
        }

        // VertexAttribPointer overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void VertexAttribPointer(this GL glInstance, uint index, int size, VertexAttribPointerType type, bool normalized, int stride, nint offset)
        {
            void* pointer = (void*)offset;
            var normalized_byte = (byte)(normalized ? 1 : 0);
            glInstance.VertexAttribPointer(index, size, type, normalized_byte, stride, pointer);
        }

        // DrawRangeElements overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void DrawRangeElements(this GL glInstance, PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, nint offset)
        {
            void* indices = (void*)offset;
            glInstance.DrawRangeElements(mode, start, end, count, type, indices);
        }

        // TexImage3D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void TexImage3D(this GL glInstance, TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.TexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexImage3D<T1>(this GL glInstance, TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.TexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexImage3D<T1>(this GL glInstance, TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, T1[] pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.TexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexImage3D<T1>(this GL glInstance, TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.TexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels_ptr);
            }
        }

        // TexSubImage3D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void TexSubImage3D(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexSubImage3D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexSubImage3D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, T1[] pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexSubImage3D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_ptr);
            }
        }

        // CompressedTexImage3D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void CompressedTexImage3D(this GL glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.CompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexImage3D<T1>(this GL glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexImage3D<T1>(this GL glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, T1[] data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CompressedTexImage3D<T1>(this GL glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.CompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data_ptr);
            }
        }

        // CompressedTexSubImage3D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void CompressedTexSubImage3D(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexSubImage3D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexSubImage3D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, T1[] data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CompressedTexSubImage3D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_ptr);
            }
        }

        // GenQueries overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe QueryHandle GenQuerie(this GL glInstance)
        {
            QueryHandle ids;
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            QueryHandle* ids_handle = (QueryHandle*)Unsafe.AsPointer(ref ids);
            glInstance.GenQueries(n, ids_handle);
            return ids;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void GenQuerie(this GL glInstance, out QueryHandle ids)
        {
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            QueryHandle* ids_handle = (QueryHandle*)Unsafe.AsPointer(ref ids);
            glInstance.GenQueries(n, ids_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenQueries(this GL glInstance, Span<QueryHandle> ids)
        {
            var n = (int)(ids.Length);
            fixed (QueryHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.GenQueries(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenQueries(this GL glInstance, QueryHandle[] ids)
        {
            var n = (int)(ids.Length);
            fixed (QueryHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.GenQueries(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenQueries(this GL glInstance, int n, ref QueryHandle ids)
        {
            fixed (QueryHandle* ids_ptr = &ids) // RefInsteadOfPointerLayer
            {
                glInstance.GenQueries(n, ids_ptr);
            }
        }

        // DeleteQueries overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void DeleteQuerie(this GL glInstance, in QueryHandle ids)
        {
            int n = 1;
            fixed(QueryHandle* ids_handle = &ids) // DeleteOverloadLayer
                glInstance.DeleteQueries(n, ids_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteQueries(this GL glInstance, ReadOnlySpan<QueryHandle> ids)
        {
            var n = (int)(ids.Length);
            fixed (QueryHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.DeleteQueries(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteQueries(this GL glInstance, QueryHandle[] ids)
        {
            var n = (int)(ids.Length);
            fixed (QueryHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.DeleteQueries(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteQueries(this GL glInstance, int n, in QueryHandle ids)
        {
            fixed (QueryHandle* ids_ptr = &ids) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteQueries(n, ids_ptr);
            }
        }

        // GetQueryiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryi(this GL glInstance, QueryTarget target, QueryParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryiv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryi(this GL glInstance, QueryTarget target, QueryParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryiv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetQueryi(this GL glInstance, QueryTarget target, QueryParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetQueryiv(target, pname, parameters_ptr);
            }
        }

        // GetQueryObjectuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryObjectui(this GL glInstance, QueryHandle id, QueryObjectParameterName pname, Span<uint> parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryObjectuiv(id, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryObjectui(this GL glInstance, QueryHandle id, QueryObjectParameterName pname, uint[] parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryObjectuiv(id, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetQueryObjectui(this GL glInstance, QueryHandle id, QueryObjectParameterName pname, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetQueryObjectuiv(id, pname, parameters_ptr);
            }
        }

        // GetBufferPointerv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void GetBufferPointer(this GL glInstance, BufferTargetARB target, BufferPointerNameARB pname, void** parameters) =>
            glInstance.GetBufferPointerv(target, pname, parameters);

        // DrawBuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DrawBuffers(this GL glInstance, ReadOnlySpan<DrawBufferMode> bufs)
        {
            var n = (int)(bufs.Length);
            fixed (DrawBufferMode* bufs_ptr = bufs) // SpanOrArrayLayer
            {
                glInstance.DrawBuffers(n, bufs_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DrawBuffers(this GL glInstance, DrawBufferMode[] bufs)
        {
            var n = (int)(bufs.Length);
            fixed (DrawBufferMode* bufs_ptr = bufs) // SpanOrArrayLayer
            {
                glInstance.DrawBuffers(n, bufs_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DrawBuffers(this GL glInstance, int n, in DrawBufferMode bufs)
        {
            fixed (DrawBufferMode* bufs_ptr = &bufs) // RefInsteadOfPointerLayer
            {
                glInstance.DrawBuffers(n, bufs_ptr);
            }
        }

        // UniformMatrix2x3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2x3fv(this GL glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 6);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x3fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2x3fv(this GL glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 6);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x3fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix2x3fv(this GL glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x3fv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix3x2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3x2fv(this GL glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 6);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x2fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3x2fv(this GL glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 6);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x2fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix3x2fv(this GL glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x2fv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix2x4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2x4fv(this GL glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 8);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x4fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2x4fv(this GL glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 8);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x4fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix2x4fv(this GL glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x4fv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix4x2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4x2fv(this GL glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 8);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x2fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4x2fv(this GL glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 8);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x2fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix4x2fv(this GL glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x2fv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix3x4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3x4fv(this GL glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 12);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x4fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3x4fv(this GL glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 12);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x4fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix3x4fv(this GL glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x4fv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix4x3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4x3fv(this GL glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 12);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x3fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4x3fv(this GL glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 12);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x3fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix4x3fv(this GL glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x3fv(location, count, transpose_byte, value_ptr);
            }
        }

        // DeleteVertexArrays overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void DeleteVertexArray(this GL glInstance, in VertexArrayHandle arrays)
        {
            int n = 1;
            fixed(VertexArrayHandle* arrays_handle = &arrays) // DeleteOverloadLayer
                glInstance.DeleteVertexArrays(n, arrays_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteVertexArrays(this GL glInstance, ReadOnlySpan<VertexArrayHandle> arrays)
        {
            var n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays) // SpanOrArrayLayer
            {
                glInstance.DeleteVertexArrays(n, arrays_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteVertexArrays(this GL glInstance, VertexArrayHandle[] arrays)
        {
            var n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays) // SpanOrArrayLayer
            {
                glInstance.DeleteVertexArrays(n, arrays_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteVertexArrays(this GL glInstance, int n, in VertexArrayHandle arrays)
        {
            fixed (VertexArrayHandle* arrays_ptr = &arrays) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteVertexArrays(n, arrays_ptr);
            }
        }

        // GenVertexArrays overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe VertexArrayHandle GenVertexArray(this GL glInstance)
        {
            VertexArrayHandle arrays;
            int n = 1;
            Unsafe.SkipInit(out arrays);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            VertexArrayHandle* arrays_handle = (VertexArrayHandle*)Unsafe.AsPointer(ref arrays);
            glInstance.GenVertexArrays(n, arrays_handle);
            return arrays;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void GenVertexArray(this GL glInstance, out VertexArrayHandle arrays)
        {
            int n = 1;
            Unsafe.SkipInit(out arrays);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            VertexArrayHandle* arrays_handle = (VertexArrayHandle*)Unsafe.AsPointer(ref arrays);
            glInstance.GenVertexArrays(n, arrays_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenVertexArrays(this GL glInstance, Span<VertexArrayHandle> arrays)
        {
            var n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays) // SpanOrArrayLayer
            {
                glInstance.GenVertexArrays(n, arrays_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenVertexArrays(this GL glInstance, VertexArrayHandle[] arrays)
        {
            var n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays) // SpanOrArrayLayer
            {
                glInstance.GenVertexArrays(n, arrays_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenVertexArrays(this GL glInstance, int n, ref VertexArrayHandle arrays)
        {
            fixed (VertexArrayHandle* arrays_ptr = &arrays) // RefInsteadOfPointerLayer
            {
                glInstance.GenVertexArrays(n, arrays_ptr);
            }
        }

        // GetIntegeri_v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInteger(this GL glInstance, GetPName target, uint index, Span<int> data)
        {
            fixed (int* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetIntegeri_v(target, index, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInteger(this GL glInstance, GetPName target, uint index, int[] data)
        {
            fixed (int* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetIntegeri_v(target, index, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetInteger(this GL glInstance, GetPName target, uint index, ref int data)
        {
            fixed (int* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetIntegeri_v(target, index, data_ptr);
            }
        }

        // GetTransformFeedbackVarying overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetTransformFeedbackVarying(this GL glInstance, ProgramHandle program, uint index, int bufSize, Span<int> length, Span<int> size, Span<AttributeType> type)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (AttributeType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        glInstance.GetTransformFeedbackVarying(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTransformFeedbackVarying(this GL glInstance, ProgramHandle program, uint index, int bufSize, Span<int> length, Span<int> size, Span<AttributeType> type, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (AttributeType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        glInstance.GetTransformFeedbackVarying(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetTransformFeedbackVarying(this GL glInstance, ProgramHandle program, uint index, int bufSize, int[] length, int[] size, AttributeType[] type)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (AttributeType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        glInstance.GetTransformFeedbackVarying(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTransformFeedbackVarying(this GL glInstance, ProgramHandle program, uint index, int bufSize, int[] length, int[] size, AttributeType[] type, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (AttributeType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        glInstance.GetTransformFeedbackVarying(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetTransformFeedbackVarying(this GL glInstance, ProgramHandle program, uint index, int bufSize, ref int length, ref int size, ref AttributeType type)
        {
            string name;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (int* size_ptr = &size) // RefInsteadOfPointerLayer
            fixed (AttributeType* type_ptr = &type) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetTransformFeedbackVarying(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTransformFeedbackVarying(this GL glInstance, ProgramHandle program, uint index, int bufSize, ref int length, ref int size, ref AttributeType type, out string name)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (int* size_ptr = &size) // RefInsteadOfPointerLayer
            fixed (AttributeType* type_ptr = &type) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetTransformFeedbackVarying(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // VertexAttribIPointer overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void VertexAttribIPointer(this GL glInstance, uint index, int size, VertexAttribIType type, int stride, nint offset)
        {
            void* pointer = (void*)offset;
            glInstance.VertexAttribIPointer(index, size, type, stride, pointer);
        }

        // GetVertexAttribIiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribIi(this GL glInstance, uint index, VertexAttribEnum pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribIiv(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribIi(this GL glInstance, uint index, VertexAttribEnum pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribIiv(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetVertexAttribIi(this GL glInstance, uint index, VertexAttribEnum pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetVertexAttribIiv(index, pname, parameters_ptr);
            }
        }

        // GetVertexAttribIuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribIui(this GL glInstance, uint index, VertexAttribEnum pname, Span<uint> parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribIuiv(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribIui(this GL glInstance, uint index, VertexAttribEnum pname, uint[] parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribIuiv(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetVertexAttribIui(this GL glInstance, uint index, VertexAttribEnum pname, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetVertexAttribIuiv(index, pname, parameters_ptr);
            }
        }

        // VertexAttribI4iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI4iv(this GL glInstance, uint index, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI4iv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI4iv(this GL glInstance, uint index, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI4iv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribI4iv(this GL glInstance, uint index, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttribI4iv(index, v_ptr);
            }
        }

        // VertexAttribI4uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI4ui(this GL glInstance, uint index, ReadOnlySpan<uint> v)
        {
            fixed (uint* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI4uiv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI4ui(this GL glInstance, uint index, uint[] v)
        {
            fixed (uint* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI4uiv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribI4ui(this GL glInstance, uint index, in uint v)
        {
            fixed (uint* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttribI4uiv(index, v_ptr);
            }
        }

        // GetUniformuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformui(this GL glInstance, ProgramHandle program, int location, Span<uint> parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformuiv(program, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformui(this GL glInstance, ProgramHandle program, int location, uint[] parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformuiv(program, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetUniformui(this GL glInstance, ProgramHandle program, int location, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetUniformuiv(program, location, parameters_ptr);
            }
        }

        // GetFragDataLocation overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe int GetFragDataLocation(this GL glInstance, ProgramHandle program, string name)
        {
            int returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = glInstance.GetFragDataLocation(program, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }

        // Uniform1uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1ui(this GL glInstance, int location, ReadOnlySpan<uint> value)
        {
            var count = (int)(value.Length / 1);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1uiv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1ui(this GL glInstance, int location, uint[] value)
        {
            var count = (int)(value.Length / 1);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1uiv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform1ui(this GL glInstance, int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform1uiv(location, count, value_ptr);
            }
        }

        // Uniform2uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2ui(this GL glInstance, int location, ReadOnlySpan<uint> value)
        {
            var count = (int)(value.Length / 2);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2uiv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2ui(this GL glInstance, int location, uint[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2uiv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform2ui(this GL glInstance, int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform2uiv(location, count, value_ptr);
            }
        }

        // Uniform3uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3ui(this GL glInstance, int location, ReadOnlySpan<uint> value)
        {
            var count = (int)(value.Length / 3);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3uiv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3ui(this GL glInstance, int location, uint[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3uiv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform3ui(this GL glInstance, int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform3uiv(location, count, value_ptr);
            }
        }

        // Uniform4uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4ui(this GL glInstance, int location, ReadOnlySpan<uint> value)
        {
            var count = (int)(value.Length / 4);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4uiv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4ui(this GL glInstance, int location, uint[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4uiv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform4ui(this GL glInstance, int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform4uiv(location, count, value_ptr);
            }
        }

        // ClearBufferiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearBufferi(this GL glInstance, Buffer buffer, int drawbuffer, ReadOnlySpan<int> value)
        {
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ClearBufferiv(buffer, drawbuffer, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearBufferi(this GL glInstance, Buffer buffer, int drawbuffer, int[] value)
        {
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ClearBufferiv(buffer, drawbuffer, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClearBufferi(this GL glInstance, Buffer buffer, int drawbuffer, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ClearBufferiv(buffer, drawbuffer, value_ptr);
            }
        }

        // ClearBufferuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearBufferui(this GL glInstance, Buffer buffer, int drawbuffer, ReadOnlySpan<uint> value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ClearBufferuiv(buffer, drawbuffer, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearBufferui(this GL glInstance, Buffer buffer, int drawbuffer, uint[] value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ClearBufferuiv(buffer, drawbuffer, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClearBufferui(this GL glInstance, Buffer buffer, int drawbuffer, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ClearBufferuiv(buffer, drawbuffer, value_ptr);
            }
        }

        // ClearBufferfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearBufferf(this GL glInstance, Buffer buffer, int drawbuffer, ReadOnlySpan<float> value)
        {
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ClearBufferfv(buffer, drawbuffer, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearBufferf(this GL glInstance, Buffer buffer, int drawbuffer, float[] value)
        {
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ClearBufferfv(buffer, drawbuffer, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClearBufferf(this GL glInstance, Buffer buffer, int drawbuffer, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ClearBufferfv(buffer, drawbuffer, value_ptr);
            }
        }

        // ClearBufferfi overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void ClearBuffer(this GL glInstance, Buffer buffer, int drawbuffer, float depth, int stencil) =>
            glInstance.ClearBufferfi(buffer, drawbuffer, depth, stencil);

        // GetStringi_ overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.StringReturnOverloader
        public static unsafe string? GetStringi(this GL glInstance, StringName name, uint index)
        {
            byte* returnValue;
            string? returnValue_str;
            returnValue = glInstance.GetStringi_(name, index);
            returnValue_str = Marshaller.PtrToString((nint)returnValue);
            return returnValue_str;
        }

        // GetUniformIndices overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformIndices(this GL glInstance, ProgramHandle program, int uniformCount, byte** uniformNames, Span<uint> uniformIndices)
        {
            fixed (uint* uniformIndices_ptr = uniformIndices) // SpanOrArrayLayer
            {
                glInstance.GetUniformIndices(program, uniformCount, uniformNames, uniformIndices_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformIndices(this GL glInstance, ProgramHandle program, int uniformCount, byte** uniformNames, uint[] uniformIndices)
        {
            fixed (uint* uniformIndices_ptr = uniformIndices) // SpanOrArrayLayer
            {
                glInstance.GetUniformIndices(program, uniformCount, uniformNames, uniformIndices_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetUniformIndices(this GL glInstance, ProgramHandle program, int uniformCount, byte** uniformNames, ref uint uniformIndices)
        {
            fixed (uint* uniformIndices_ptr = &uniformIndices) // RefInsteadOfPointerLayer
            {
                glInstance.GetUniformIndices(program, uniformCount, uniformNames, uniformIndices_ptr);
            }
        }

        // GetActiveUniformsiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniformsi(this GL glInstance, ProgramHandle program, ReadOnlySpan<uint> uniformIndices, UniformPName pname, Span<int> parameters)
        {
            var uniformCount = (int)(uniformIndices.Length);
            fixed (uint* uniformIndices_ptr = uniformIndices) // SpanOrArrayLayer
            {
                fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
                {
                    glInstance.GetActiveUniformsiv(program, uniformCount, uniformIndices_ptr, pname, parameters_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniformsi(this GL glInstance, ProgramHandle program, uint[] uniformIndices, UniformPName pname, int[] parameters)
        {
            var uniformCount = (int)(uniformIndices.Length);
            fixed (uint* uniformIndices_ptr = uniformIndices) // SpanOrArrayLayer
            {
                fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
                {
                    glInstance.GetActiveUniformsiv(program, uniformCount, uniformIndices_ptr, pname, parameters_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveUniformsi(this GL glInstance, ProgramHandle program, int uniformCount, in uint uniformIndices, UniformPName pname, ref int parameters)
        {
            fixed (uint* uniformIndices_ptr = &uniformIndices) // RefInsteadOfPointerLayer
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetActiveUniformsiv(program, uniformCount, uniformIndices_ptr, pname, parameters_ptr);
            }
        }

        // GetUniformBlockIndex overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe uint GetUniformBlockIndex(this GL glInstance, ProgramHandle program, string uniformBlockName)
        {
            uint returnValue;
            byte* uniformBlockName_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(uniformBlockName);
            returnValue = glInstance.GetUniformBlockIndex(program, uniformBlockName_ptr);
            Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            return returnValue;
        }

        // GetActiveUniformBlockiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniformBlocki(this GL glInstance, ProgramHandle program, uint uniformBlockIndex, UniformBlockPName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetActiveUniformBlockiv(program, uniformBlockIndex, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniformBlocki(this GL glInstance, ProgramHandle program, uint uniformBlockIndex, UniformBlockPName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetActiveUniformBlockiv(program, uniformBlockIndex, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveUniformBlocki(this GL glInstance, ProgramHandle program, uint uniformBlockIndex, UniformBlockPName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetActiveUniformBlockiv(program, uniformBlockIndex, pname, parameters_ptr);
            }
        }

        // GetActiveUniformBlockName overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveUniformBlockName(this GL glInstance, ProgramHandle program, uint uniformBlockIndex, int bufSize, Span<int> length)
        {
            string uniformBlockName;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            }
            return uniformBlockName;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniformBlockName(this GL glInstance, ProgramHandle program, uint uniformBlockIndex, int bufSize, Span<int> length, out string uniformBlockName)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveUniformBlockName(this GL glInstance, ProgramHandle program, uint uniformBlockIndex, int bufSize, int[] length)
        {
            string uniformBlockName;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            }
            return uniformBlockName;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniformBlockName(this GL glInstance, ProgramHandle program, uint uniformBlockIndex, int bufSize, int[] length, out string uniformBlockName)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveUniformBlockName(this GL glInstance, ProgramHandle program, uint uniformBlockIndex, int bufSize, ref int length)
        {
            string uniformBlockName;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            }
            return uniformBlockName;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveUniformBlockName(this GL glInstance, ProgramHandle program, uint uniformBlockIndex, int bufSize, ref int length, out string uniformBlockName)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            }
        }

        // DrawElementsInstanced overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void DrawElementsInstanced(this GL glInstance, PrimitiveType mode, int count, DrawElementsType type, nint offset, int instancecount)
        {
            void* indices = (void*)offset;
            glInstance.DrawElementsInstanced(mode, count, type, indices, instancecount);
        }

        // GetInteger64v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInteger64(this GL glInstance, GetPName pname, Span<long> data)
        {
            fixed (long* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetInteger64v(pname, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInteger64(this GL glInstance, GetPName pname, long[] data)
        {
            fixed (long* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetInteger64v(pname, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetInteger64(this GL glInstance, GetPName pname, ref long data)
        {
            fixed (long* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetInteger64v(pname, data_ptr);
            }
        }

        // GetSynciv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSynci(this GL glInstance, GLSync sync, SyncParameterName pname, Span<int> length, Span<int> values)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var count = (int)(values.Length);
                fixed (int* values_ptr = values) // SpanOrArrayLayer
                {
                    glInstance.GetSynciv(sync, pname, count, length_ptr, values_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSynci(this GL glInstance, GLSync sync, SyncParameterName pname, int[] length, int[] values)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var count = (int)(values.Length);
                fixed (int* values_ptr = values) // SpanOrArrayLayer
                {
                    glInstance.GetSynciv(sync, pname, count, length_ptr, values_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetSynci(this GL glInstance, GLSync sync, SyncParameterName pname, int count, ref int length, ref int values)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (int* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                glInstance.GetSynciv(sync, pname, count, length_ptr, values_ptr);
            }
        }

        // GetInteger64i_v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInteger64(this GL glInstance, GetPName target, uint index, Span<long> data)
        {
            fixed (long* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetInteger64i_v(target, index, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInteger64(this GL glInstance, GetPName target, uint index, long[] data)
        {
            fixed (long* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetInteger64i_v(target, index, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetInteger64(this GL glInstance, GetPName target, uint index, ref long data)
        {
            fixed (long* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetInteger64i_v(target, index, data_ptr);
            }
        }

        // GetBufferParameteri64v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetBufferParameteri64(this GL glInstance, BufferTargetARB target, BufferPNameARB pname, Span<long> parameters)
        {
            fixed (long* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetBufferParameteri64v(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetBufferParameteri64(this GL glInstance, BufferTargetARB target, BufferPNameARB pname, long[] parameters)
        {
            fixed (long* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetBufferParameteri64v(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetBufferParameteri64(this GL glInstance, BufferTargetARB target, BufferPNameARB pname, ref long parameters)
        {
            fixed (long* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetBufferParameteri64v(target, pname, parameters_ptr);
            }
        }

        // GenSamplers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe SamplerHandle GenSampler(this GL glInstance)
        {
            SamplerHandle samplers;
            int count = 1;
            Unsafe.SkipInit(out samplers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            SamplerHandle* samplers_handle = (SamplerHandle*)Unsafe.AsPointer(ref samplers);
            glInstance.GenSamplers(count, samplers_handle);
            return samplers;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void GenSampler(this GL glInstance, out SamplerHandle samplers)
        {
            int count = 1;
            Unsafe.SkipInit(out samplers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            SamplerHandle* samplers_handle = (SamplerHandle*)Unsafe.AsPointer(ref samplers);
            glInstance.GenSamplers(count, samplers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenSamplers(this GL glInstance, Span<SamplerHandle> samplers)
        {
            var count = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers) // SpanOrArrayLayer
            {
                glInstance.GenSamplers(count, samplers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenSamplers(this GL glInstance, SamplerHandle[] samplers)
        {
            var count = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers) // SpanOrArrayLayer
            {
                glInstance.GenSamplers(count, samplers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenSamplers(this GL glInstance, int count, ref SamplerHandle samplers)
        {
            fixed (SamplerHandle* samplers_ptr = &samplers) // RefInsteadOfPointerLayer
            {
                glInstance.GenSamplers(count, samplers_ptr);
            }
        }

        // DeleteSamplers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void DeleteSampler(this GL glInstance, in SamplerHandle samplers)
        {
            int count = 1;
            fixed(SamplerHandle* samplers_handle = &samplers) // DeleteOverloadLayer
                glInstance.DeleteSamplers(count, samplers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteSamplers(this GL glInstance, ReadOnlySpan<SamplerHandle> samplers)
        {
            var count = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers) // SpanOrArrayLayer
            {
                glInstance.DeleteSamplers(count, samplers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteSamplers(this GL glInstance, SamplerHandle[] samplers)
        {
            var count = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers) // SpanOrArrayLayer
            {
                glInstance.DeleteSamplers(count, samplers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteSamplers(this GL glInstance, int count, in SamplerHandle samplers)
        {
            fixed (SamplerHandle* samplers_ptr = &samplers) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteSamplers(count, samplers_ptr);
            }
        }

        // SamplerParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SamplerParameteri(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, ReadOnlySpan<int> param)
        {
            fixed (int* param_ptr = param) // SpanOrArrayLayer
            {
                glInstance.SamplerParameteriv(sampler, pname, param_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SamplerParameteri(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, int[] param)
        {
            fixed (int* param_ptr = param) // SpanOrArrayLayer
            {
                glInstance.SamplerParameteriv(sampler, pname, param_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SamplerParameteri(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, in int param)
        {
            fixed (int* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.SamplerParameteriv(sampler, pname, param_ptr);
            }
        }

        // SamplerParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SamplerParameterf(this GL glInstance, SamplerHandle sampler, SamplerParameterF pname, ReadOnlySpan<float> param)
        {
            fixed (float* param_ptr = param) // SpanOrArrayLayer
            {
                glInstance.SamplerParameterfv(sampler, pname, param_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SamplerParameterf(this GL glInstance, SamplerHandle sampler, SamplerParameterF pname, float[] param)
        {
            fixed (float* param_ptr = param) // SpanOrArrayLayer
            {
                glInstance.SamplerParameterfv(sampler, pname, param_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SamplerParameterf(this GL glInstance, SamplerHandle sampler, SamplerParameterF pname, in float param)
        {
            fixed (float* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.SamplerParameterfv(sampler, pname, param_ptr);
            }
        }

        // GetSamplerParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSamplerParameteri(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetSamplerParameteriv(sampler, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSamplerParameteri(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetSamplerParameteriv(sampler, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetSamplerParameteri(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetSamplerParameteriv(sampler, pname, parameters_ptr);
            }
        }

        // GetSamplerParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSamplerParameterf(this GL glInstance, SamplerHandle sampler, SamplerParameterF pname, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetSamplerParameterfv(sampler, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSamplerParameterf(this GL glInstance, SamplerHandle sampler, SamplerParameterF pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetSamplerParameterfv(sampler, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetSamplerParameterf(this GL glInstance, SamplerHandle sampler, SamplerParameterF pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetSamplerParameterfv(sampler, pname, parameters_ptr);
            }
        }

        // DeleteTransformFeedbacks overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void DeleteTransformFeedback(this GL glInstance, in TransformFeedbackHandle ids)
        {
            int n = 1;
            fixed(TransformFeedbackHandle* ids_handle = &ids) // DeleteOverloadLayer
                glInstance.DeleteTransformFeedbacks(n, ids_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteTransformFeedbacks(this GL glInstance, ReadOnlySpan<TransformFeedbackHandle> ids)
        {
            var n = (int)(ids.Length);
            fixed (TransformFeedbackHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.DeleteTransformFeedbacks(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteTransformFeedbacks(this GL glInstance, TransformFeedbackHandle[] ids)
        {
            var n = (int)(ids.Length);
            fixed (TransformFeedbackHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.DeleteTransformFeedbacks(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteTransformFeedbacks(this GL glInstance, int n, in TransformFeedbackHandle ids)
        {
            fixed (TransformFeedbackHandle* ids_ptr = &ids) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteTransformFeedbacks(n, ids_ptr);
            }
        }

        // GenTransformFeedbacks overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe TransformFeedbackHandle GenTransformFeedback(this GL glInstance)
        {
            TransformFeedbackHandle ids;
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TransformFeedbackHandle* ids_handle = (TransformFeedbackHandle*)Unsafe.AsPointer(ref ids);
            glInstance.GenTransformFeedbacks(n, ids_handle);
            return ids;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void GenTransformFeedback(this GL glInstance, out TransformFeedbackHandle ids)
        {
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TransformFeedbackHandle* ids_handle = (TransformFeedbackHandle*)Unsafe.AsPointer(ref ids);
            glInstance.GenTransformFeedbacks(n, ids_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenTransformFeedbacks(this GL glInstance, Span<TransformFeedbackHandle> ids)
        {
            var n = (int)(ids.Length);
            fixed (TransformFeedbackHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.GenTransformFeedbacks(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenTransformFeedbacks(this GL glInstance, TransformFeedbackHandle[] ids)
        {
            var n = (int)(ids.Length);
            fixed (TransformFeedbackHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.GenTransformFeedbacks(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenTransformFeedbacks(this GL glInstance, int n, ref TransformFeedbackHandle ids)
        {
            fixed (TransformFeedbackHandle* ids_ptr = &ids) // RefInsteadOfPointerLayer
            {
                glInstance.GenTransformFeedbacks(n, ids_ptr);
            }
        }

        // GetProgramBinary overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramBinary(this GL glInstance, ProgramHandle program, int bufSize, Span<int> length, Span<GLEnum> binaryFormat, IntPtr binary)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (GLEnum* binaryFormat_ptr = binaryFormat) // SpanOrArrayLayer
                {
                    var binary_vptr = (void*)binary;
                    glInstance.GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_vptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramBinary(this GL glInstance, ProgramHandle program, int bufSize, int[] length, GLEnum[] binaryFormat, IntPtr binary)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (GLEnum* binaryFormat_ptr = binaryFormat) // SpanOrArrayLayer
                {
                    var binary_vptr = (void*)binary;
                    glInstance.GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_vptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramBinary(this GL glInstance, ProgramHandle program, int bufSize, ref int length, ref GLEnum binaryFormat, IntPtr binary)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (GLEnum* binaryFormat_ptr = &binaryFormat) // RefInsteadOfPointerLayer
            {
                var binary_vptr = (void*)binary;
                glInstance.GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_vptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramBinary<T1>(this GL glInstance, ProgramHandle program, Span<int> length, Span<GLEnum> binaryFormat, Span<T1> binary)
            where T1 : unmanaged
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (GLEnum* binaryFormat_ptr = binaryFormat) // SpanOrArrayLayer
                {
                    var bufSize = (int)(binary.Length * sizeof(T1));
                    fixed (void* binary_ptr = binary) // SpanOrArrayLayer
                    {
                        glInstance.GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramBinary<T1>(this GL glInstance, ProgramHandle program, int[] length, GLEnum[] binaryFormat, T1[] binary)
            where T1 : unmanaged
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (GLEnum* binaryFormat_ptr = binaryFormat) // SpanOrArrayLayer
                {
                    var bufSize = (int)(binary.Length * sizeof(T1));
                    fixed (void* binary_ptr = binary) // SpanOrArrayLayer
                    {
                        glInstance.GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramBinary<T1>(this GL glInstance, ProgramHandle program, int bufSize, ref int length, ref GLEnum binaryFormat, ref T1 binary)
            where T1 : unmanaged
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (GLEnum* binaryFormat_ptr = &binaryFormat) // RefInsteadOfPointerLayer
            fixed (void* binary_ptr = &binary) // RefInsteadOfPointerLayer
            {
                glInstance.GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_ptr);
            }
        }

        // ProgramBinary overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ProgramBinary(this GL glInstance, ProgramHandle program, GLEnum binaryFormat, IntPtr binary, int length)
        {
            var binary_vptr = (void*)binary;
            glInstance.ProgramBinary(program, binaryFormat, binary_vptr, length);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramBinary<T1>(this GL glInstance, ProgramHandle program, GLEnum binaryFormat, ReadOnlySpan<T1> binary)
            where T1 : unmanaged
        {
            var length = (int)(binary.Length * sizeof(T1));
            fixed (void* binary_ptr = binary) // SpanOrArrayLayer
            {
                glInstance.ProgramBinary(program, binaryFormat, binary_ptr, length);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramBinary<T1>(this GL glInstance, ProgramHandle program, GLEnum binaryFormat, T1[] binary)
            where T1 : unmanaged
        {
            var length = (int)(binary.Length * sizeof(T1));
            fixed (void* binary_ptr = binary) // SpanOrArrayLayer
            {
                glInstance.ProgramBinary(program, binaryFormat, binary_ptr, length);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramBinary<T1>(this GL glInstance, ProgramHandle program, GLEnum binaryFormat, in T1 binary, int length)
            where T1 : unmanaged
        {
            fixed (void* binary_ptr = &binary) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramBinary(program, binaryFormat, binary_ptr, length);
            }
        }

        // InvalidateFramebuffer overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void InvalidateFramebuffer(this GL glInstance, FramebufferTarget target, ReadOnlySpan<InvalidateFramebufferAttachment> attachments)
        {
            var numAttachments = (int)(attachments.Length);
            fixed (InvalidateFramebufferAttachment* attachments_ptr = attachments) // SpanOrArrayLayer
            {
                glInstance.InvalidateFramebuffer(target, numAttachments, attachments_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void InvalidateFramebuffer(this GL glInstance, FramebufferTarget target, InvalidateFramebufferAttachment[] attachments)
        {
            var numAttachments = (int)(attachments.Length);
            fixed (InvalidateFramebufferAttachment* attachments_ptr = attachments) // SpanOrArrayLayer
            {
                glInstance.InvalidateFramebuffer(target, numAttachments, attachments_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void InvalidateFramebuffer(this GL glInstance, FramebufferTarget target, int numAttachments, in InvalidateFramebufferAttachment attachments)
        {
            fixed (InvalidateFramebufferAttachment* attachments_ptr = &attachments) // RefInsteadOfPointerLayer
            {
                glInstance.InvalidateFramebuffer(target, numAttachments, attachments_ptr);
            }
        }

        // InvalidateSubFramebuffer overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void InvalidateSubFramebuffer(this GL glInstance, FramebufferTarget target, ReadOnlySpan<InvalidateFramebufferAttachment> attachments, int x, int y, int width, int height)
        {
            var numAttachments = (int)(attachments.Length);
            fixed (InvalidateFramebufferAttachment* attachments_ptr = attachments) // SpanOrArrayLayer
            {
                glInstance.InvalidateSubFramebuffer(target, numAttachments, attachments_ptr, x, y, width, height);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void InvalidateSubFramebuffer(this GL glInstance, FramebufferTarget target, InvalidateFramebufferAttachment[] attachments, int x, int y, int width, int height)
        {
            var numAttachments = (int)(attachments.Length);
            fixed (InvalidateFramebufferAttachment* attachments_ptr = attachments) // SpanOrArrayLayer
            {
                glInstance.InvalidateSubFramebuffer(target, numAttachments, attachments_ptr, x, y, width, height);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void InvalidateSubFramebuffer(this GL glInstance, FramebufferTarget target, int numAttachments, in InvalidateFramebufferAttachment attachments, int x, int y, int width, int height)
        {
            fixed (InvalidateFramebufferAttachment* attachments_ptr = &attachments) // RefInsteadOfPointerLayer
            {
                glInstance.InvalidateSubFramebuffer(target, numAttachments, attachments_ptr, x, y, width, height);
            }
        }

        // GetInternalformativ overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInternalformati(this GL glInstance, TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, Span<int> parameters)
        {
            var count = (int)(parameters.Length);
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetInternalformativ(target, internalformat, pname, count, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInternalformati(this GL glInstance, TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int[] parameters)
        {
            var count = (int)(parameters.Length);
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetInternalformativ(target, internalformat, pname, count, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetInternalformati(this GL glInstance, TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetInternalformativ(target, internalformat, pname, count, parameters_ptr);
            }
        }

        // DrawArraysIndirect overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void DrawArraysIndirect(this GL glInstance, PrimitiveType mode, IntPtr indirect)
        {
            var indirect_vptr = (void*)indirect;
            glInstance.DrawArraysIndirect(mode, indirect_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DrawArraysIndirect<T1>(this GL glInstance, PrimitiveType mode, in T1 indirect)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = &indirect) // RefInsteadOfPointerLayer
            {
                glInstance.DrawArraysIndirect(mode, indirect_ptr);
            }
        }

        // DrawElementsIndirect overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void DrawElementsIndirect(this GL glInstance, PrimitiveType mode, DrawElementsType type, IntPtr indirect)
        {
            var indirect_vptr = (void*)indirect;
            glInstance.DrawElementsIndirect(mode, type, indirect_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DrawElementsIndirect<T1>(this GL glInstance, PrimitiveType mode, DrawElementsType type, in T1 indirect)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = &indirect) // RefInsteadOfPointerLayer
            {
                glInstance.DrawElementsIndirect(mode, type, indirect_ptr);
            }
        }

        // GetFramebufferParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetFramebufferParameteri(this GL glInstance, FramebufferTarget target, FramebufferAttachmentParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetFramebufferParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetFramebufferParameteri(this GL glInstance, FramebufferTarget target, FramebufferAttachmentParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetFramebufferParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetFramebufferParameteri(this GL glInstance, FramebufferTarget target, FramebufferAttachmentParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetFramebufferParameteriv(target, pname, parameters_ptr);
            }
        }

        // GetProgramInterfaceiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramInterfacei(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, ProgramInterfacePName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramInterfaceiv(program, programInterface, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramInterfacei(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, ProgramInterfacePName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramInterfaceiv(program, programInterface, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramInterfacei(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, ProgramInterfacePName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetProgramInterfaceiv(program, programInterface, pname, parameters_ptr);
            }
        }

        // GetProgramResourceIndex overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe uint GetProgramResourceIndex(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, string name)
        {
            uint returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = glInstance.GetProgramResourceIndex(program, programInterface, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }

        // GetProgramResourceName overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetProgramResourceName(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, Span<int> length)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramResourceName(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, Span<int> length, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetProgramResourceName(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, int[] length)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramResourceName(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, int[] length, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetProgramResourceName(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, ref int length)
        {
            string name;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramResourceName(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, ref int length, out string name)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // GetProgramResourceiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramResourcei(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, ReadOnlySpan<ProgramResourceProperty> props, Span<int> length, Span<int> parameters)
        {
            var propCount = (int)(props.Length);
            fixed (ProgramResourceProperty* props_ptr = props) // SpanOrArrayLayer
            {
                fixed (int* length_ptr = length) // SpanOrArrayLayer
                {
                    var count = (int)(parameters.Length);
                    fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
                    {
                        glInstance.GetProgramResourceiv(program, programInterface, index, propCount, props_ptr, count, length_ptr, parameters_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramResourcei(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, ProgramResourceProperty[] props, int[] length, int[] parameters)
        {
            var propCount = (int)(props.Length);
            fixed (ProgramResourceProperty* props_ptr = props) // SpanOrArrayLayer
            {
                fixed (int* length_ptr = length) // SpanOrArrayLayer
                {
                    var count = (int)(parameters.Length);
                    fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
                    {
                        glInstance.GetProgramResourceiv(program, programInterface, index, propCount, props_ptr, count, length_ptr, parameters_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramResourcei(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, int propCount, in ProgramResourceProperty props, int count, ref int length, ref int parameters)
        {
            fixed (ProgramResourceProperty* props_ptr = &props) // RefInsteadOfPointerLayer
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetProgramResourceiv(program, programInterface, index, propCount, props_ptr, count, length_ptr, parameters_ptr);
            }
        }

        // GetProgramResourceLocation overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe int GetProgramResourceLocation(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, string name)
        {
            int returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = glInstance.GetProgramResourceLocation(program, programInterface, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }

        // CreateShaderProgramv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe ProgramHandle CreateShaderProgram(this GL glInstance, ShaderType type, int count, byte** strings)
        {
            ProgramHandle returnValue;
            returnValue = glInstance.CreateShaderProgramv(type, count, strings);
            return returnValue;
        }

        // DeleteProgramPipelines overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void DeleteProgramPipeline(this GL glInstance, in ProgramPipelineHandle pipelines)
        {
            int n = 1;
            fixed(ProgramPipelineHandle* pipelines_handle = &pipelines) // DeleteOverloadLayer
                glInstance.DeleteProgramPipelines(n, pipelines_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteProgramPipelines(this GL glInstance, ReadOnlySpan<ProgramPipelineHandle> pipelines)
        {
            var n = (int)(pipelines.Length);
            fixed (ProgramPipelineHandle* pipelines_ptr = pipelines) // SpanOrArrayLayer
            {
                glInstance.DeleteProgramPipelines(n, pipelines_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteProgramPipelines(this GL glInstance, ProgramPipelineHandle[] pipelines)
        {
            var n = (int)(pipelines.Length);
            fixed (ProgramPipelineHandle* pipelines_ptr = pipelines) // SpanOrArrayLayer
            {
                glInstance.DeleteProgramPipelines(n, pipelines_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteProgramPipelines(this GL glInstance, int n, in ProgramPipelineHandle pipelines)
        {
            fixed (ProgramPipelineHandle* pipelines_ptr = &pipelines) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteProgramPipelines(n, pipelines_ptr);
            }
        }

        // GenProgramPipelines overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe ProgramPipelineHandle GenProgramPipeline(this GL glInstance)
        {
            ProgramPipelineHandle pipelines;
            int n = 1;
            Unsafe.SkipInit(out pipelines);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            ProgramPipelineHandle* pipelines_handle = (ProgramPipelineHandle*)Unsafe.AsPointer(ref pipelines);
            glInstance.GenProgramPipelines(n, pipelines_handle);
            return pipelines;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void GenProgramPipeline(this GL glInstance, out ProgramPipelineHandle pipelines)
        {
            int n = 1;
            Unsafe.SkipInit(out pipelines);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            ProgramPipelineHandle* pipelines_handle = (ProgramPipelineHandle*)Unsafe.AsPointer(ref pipelines);
            glInstance.GenProgramPipelines(n, pipelines_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenProgramPipelines(this GL glInstance, Span<ProgramPipelineHandle> pipelines)
        {
            var n = (int)(pipelines.Length);
            fixed (ProgramPipelineHandle* pipelines_ptr = pipelines) // SpanOrArrayLayer
            {
                glInstance.GenProgramPipelines(n, pipelines_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenProgramPipelines(this GL glInstance, ProgramPipelineHandle[] pipelines)
        {
            var n = (int)(pipelines.Length);
            fixed (ProgramPipelineHandle* pipelines_ptr = pipelines) // SpanOrArrayLayer
            {
                glInstance.GenProgramPipelines(n, pipelines_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenProgramPipelines(this GL glInstance, int n, ref ProgramPipelineHandle pipelines)
        {
            fixed (ProgramPipelineHandle* pipelines_ptr = &pipelines) // RefInsteadOfPointerLayer
            {
                glInstance.GenProgramPipelines(n, pipelines_ptr);
            }
        }

        // GetProgramPipelineiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramPipelinei(this GL glInstance, ProgramPipelineHandle pipeline, PipelineParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramPipelineiv(pipeline, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramPipelinei(this GL glInstance, ProgramPipelineHandle pipeline, PipelineParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramPipelineiv(pipeline, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramPipelinei(this GL glInstance, ProgramPipelineHandle pipeline, PipelineParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetProgramPipelineiv(pipeline, pname, parameters_ptr);
            }
        }

        // ProgramUniform1iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1iv(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<int> value)
        {
            var count = (int)(value.Length);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1iv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1iv(this GL glInstance, ProgramHandle program, int location, int[] value)
        {
            var count = (int)(value.Length);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1iv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform1iv(this GL glInstance, ProgramHandle program, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform1iv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform2iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2iv(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<int> value)
        {
            var count = (int)(value.Length / 2);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2iv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2iv(this GL glInstance, ProgramHandle program, int location, int[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2iv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform2iv(this GL glInstance, ProgramHandle program, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform2iv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform3iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3iv(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<int> value)
        {
            var count = (int)(value.Length / 3);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3iv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3iv(this GL glInstance, ProgramHandle program, int location, int[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3iv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform3iv(this GL glInstance, ProgramHandle program, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform3iv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform4iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4iv(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<int> value)
        {
            var count = (int)(value.Length / 4);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4iv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4iv(this GL glInstance, ProgramHandle program, int location, int[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4iv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform4iv(this GL glInstance, ProgramHandle program, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform4iv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform1uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1ui(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<uint> value)
        {
            var count = (int)(value.Length);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1uiv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1ui(this GL glInstance, ProgramHandle program, int location, uint[] value)
        {
            var count = (int)(value.Length);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1uiv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform1ui(this GL glInstance, ProgramHandle program, int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform1uiv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform2uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2ui(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<uint> value)
        {
            var count = (int)(value.Length / 2);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2uiv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2ui(this GL glInstance, ProgramHandle program, int location, uint[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2uiv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform2ui(this GL glInstance, ProgramHandle program, int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform2uiv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform3uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3ui(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<uint> value)
        {
            var count = (int)(value.Length / 3);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3uiv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3ui(this GL glInstance, ProgramHandle program, int location, uint[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3uiv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform3ui(this GL glInstance, ProgramHandle program, int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform3uiv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform4uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4ui(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<uint> value)
        {
            var count = (int)(value.Length / 4);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4uiv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4ui(this GL glInstance, ProgramHandle program, int location, uint[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4uiv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform4ui(this GL glInstance, ProgramHandle program, int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform4uiv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform1fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1fv(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1fv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1fv(this GL glInstance, ProgramHandle program, int location, float[] value)
        {
            var count = (int)(value.Length);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1fv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform1fv(this GL glInstance, ProgramHandle program, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform1fv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2fv(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 2);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2fv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2fv(this GL glInstance, ProgramHandle program, int location, float[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2fv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform2fv(this GL glInstance, ProgramHandle program, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform2fv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3fv(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 3);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3fv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3fv(this GL glInstance, ProgramHandle program, int location, float[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3fv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform3fv(this GL glInstance, ProgramHandle program, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform3fv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4fv(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 4);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4fv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4fv(this GL glInstance, ProgramHandle program, int location, float[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4fv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform4fv(this GL glInstance, ProgramHandle program, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform4fv(program, location, count, value_ptr);
            }
        }

        // ProgramUniformMatrix2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2fv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 4);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2fv(this GL glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix2fv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3fv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 9);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3fv(this GL glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 9);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix3fv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4fv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 16);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4fv(this GL glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 16);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix4fv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix2x3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2x3fv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 6);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2x3fv(this GL glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 6);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix2x3fv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix3x2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3x2fv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 6);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3x2fv(this GL glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 6);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix3x2fv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix2x4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2x4fv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 8);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2x4fv(this GL glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 8);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix2x4fv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix4x2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4x2fv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 8);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4x2fv(this GL glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 8);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix4x2fv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix3x4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3x4fv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 12);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3x4fv(this GL glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 12);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix3x4fv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix4x3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4x3fv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 12);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4x3fv(this GL glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 12);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix4x3fv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // GetProgramPipelineInfoLog overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetProgramPipelineInfoLog(this GL glInstance, ProgramPipelineHandle pipeline, int bufSize, Span<int> length)
        {
            string infoLog;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramPipelineInfoLog(this GL glInstance, ProgramPipelineHandle pipeline, int bufSize, Span<int> length, out string infoLog)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetProgramPipelineInfoLog(this GL glInstance, ProgramPipelineHandle pipeline, int bufSize, int[] length)
        {
            string infoLog;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramPipelineInfoLog(this GL glInstance, ProgramPipelineHandle pipeline, int bufSize, int[] length, out string infoLog)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetProgramPipelineInfoLog(this GL glInstance, ProgramPipelineHandle pipeline, int bufSize, ref int length)
        {
            string infoLog;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramPipelineInfoLog(this GL glInstance, ProgramPipelineHandle pipeline, int bufSize, ref int length, out string infoLog)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }

        // BindImageTexture overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void BindImageTexture(this GL glInstance, uint unit, TextureHandle texture, int level, bool layered, int layer, BufferAccessARB access, InternalFormat format)
        {
            var layered_byte = (byte)(layered ? 1 : 0);
            glInstance.BindImageTexture(unit, texture, level, layered_byte, layer, access, format);
        }

        // GetBooleani_v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetBoolean(this GL glInstance, BufferTargetARB target, uint index, Span<byte> data)
        {
            fixed (byte* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetBooleani_v(target, index, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetBoolean(this GL glInstance, BufferTargetARB target, uint index, byte[] data)
        {
            fixed (byte* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetBooleani_v(target, index, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetBoolean(this GL glInstance, BufferTargetARB target, uint index, ref byte data)
        {
            fixed (byte* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetBooleani_v(target, index, data_ptr);
            }
        }

        // TexStorage2DMultisample overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void TexStorage2DMultisample(this GL glInstance, TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations)
        {
            var fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
            glInstance.TexStorage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations_byte);
        }

        // GetMultisamplefv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetMultisamplef(this GL glInstance, GetMultisamplePNameNV pname, uint index, Span<float> val)
        {
            fixed (float* val_ptr = val) // SpanOrArrayLayer
            {
                glInstance.GetMultisamplefv(pname, index, val_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetMultisamplef(this GL glInstance, GetMultisamplePNameNV pname, uint index, float[] val)
        {
            fixed (float* val_ptr = val) // SpanOrArrayLayer
            {
                glInstance.GetMultisamplefv(pname, index, val_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetMultisamplef(this GL glInstance, GetMultisamplePNameNV pname, uint index, ref float val)
        {
            fixed (float* val_ptr = &val) // RefInsteadOfPointerLayer
            {
                glInstance.GetMultisamplefv(pname, index, val_ptr);
            }
        }

        // GetTexLevelParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexLevelParameteri(this GL glInstance, TextureTarget target, int level, GetTextureParameter pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexLevelParameteriv(target, level, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexLevelParameteri(this GL glInstance, TextureTarget target, int level, GetTextureParameter pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexLevelParameteriv(target, level, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTexLevelParameteri(this GL glInstance, TextureTarget target, int level, GetTextureParameter pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTexLevelParameteriv(target, level, pname, parameters_ptr);
            }
        }

        // GetTexLevelParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexLevelParameterf(this GL glInstance, TextureTarget target, int level, GetTextureParameter pname, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexLevelParameterfv(target, level, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexLevelParameterf(this GL glInstance, TextureTarget target, int level, GetTextureParameter pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexLevelParameterfv(target, level, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTexLevelParameterf(this GL glInstance, TextureTarget target, int level, GetTextureParameter pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTexLevelParameterfv(target, level, pname, parameters_ptr);
            }
        }

        // VertexAttribFormat overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void VertexAttribFormat(this GL glInstance, uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset)
        {
            var normalized_byte = (byte)(normalized ? 1 : 0);
            glInstance.VertexAttribFormat(attribindex, size, type, normalized_byte, relativeoffset);
        }

        // DebugMessageControl overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DebugMessageControl(this GL glInstance, DebugSource source, DebugType type, DebugSeverity severity, ReadOnlySpan<uint> ids, bool enabled)
        {
            var count = (int)(ids.Length);
            fixed (uint* ids_ptr = ids) // SpanOrArrayLayer
            {
                var enabled_byte = (byte)(enabled ? 1 : 0);
                glInstance.DebugMessageControl(source, type, severity, count, ids_ptr, enabled_byte);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DebugMessageControl(this GL glInstance, DebugSource source, DebugType type, DebugSeverity severity, uint[] ids, bool enabled)
        {
            var count = (int)(ids.Length);
            fixed (uint* ids_ptr = ids) // SpanOrArrayLayer
            {
                var enabled_byte = (byte)(enabled ? 1 : 0);
                glInstance.DebugMessageControl(source, type, severity, count, ids_ptr, enabled_byte);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DebugMessageControl(this GL glInstance, DebugSource source, DebugType type, DebugSeverity severity, int count, in uint ids, bool enabled)
        {
            fixed (uint* ids_ptr = &ids) // RefInsteadOfPointerLayer
            {
                var enabled_byte = (byte)(enabled ? 1 : 0);
                glInstance.DebugMessageControl(source, type, severity, count, ids_ptr, enabled_byte);
            }
        }

        // DebugMessageInsert overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe void DebugMessageInsert(this GL glInstance, DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, string buf)
        {
            byte* buf_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(buf);
            glInstance.DebugMessageInsert(source, type, id, severity, length, buf_ptr);
            Marshal.FreeCoTaskMem((IntPtr)buf_ptr);
        }

        // DebugMessageCallback overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void DebugMessageCallback(this GL glInstance, GLDebugProc callback, IntPtr userParam)
        {
            var userParam_vptr = (void*)userParam;
            IntPtr callback_ptr = Marshal.GetFunctionPointerForDelegate(callback);
            glInstance.DebugMessageCallback(callback_ptr, userParam_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DebugMessageCallback<T1>(this GL glInstance, GLDebugProc callback, in T1 userParam)
            where T1 : unmanaged
        {
            fixed (void* userParam_ptr = &userParam) // RefInsteadOfPointerLayer
            {
                IntPtr callback_ptr = Marshal.GetFunctionPointerForDelegate(callback);
                glInstance.DebugMessageCallback(callback_ptr, userParam_ptr);
            }
        }

        // GetDebugMessageLog overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe uint GetDebugMessageLog(this GL glInstance, uint count, int bufSize, Span<DebugSource> sources, Span<DebugType> types, Span<uint> ids, Span<DebugSeverity> severities, Span<int> lengths, out string messageLog)
        {
            uint returnValue;
            fixed (DebugSource* sources_ptr = sources) // SpanOrArrayLayer
            {
                fixed (DebugType* types_ptr = types) // SpanOrArrayLayer
                {
                    fixed (uint* ids_ptr = ids) // SpanOrArrayLayer
                    {
                        fixed (DebugSeverity* severities_ptr = severities) // SpanOrArrayLayer
                        {
                            fixed (int* lengths_ptr = lengths) // SpanOrArrayLayer
                            {
                                var messageLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                                returnValue = glInstance.GetDebugMessageLog(count, bufSize, sources_ptr, types_ptr, ids_ptr, severities_ptr, lengths_ptr, messageLog_ptr);
                                messageLog = Marshal.PtrToStringUTF8((IntPtr)messageLog_ptr)!;
                                Marshal.FreeCoTaskMem((IntPtr)messageLog_ptr);
                            }
                        }
                    }
                }
            }
            return returnValue;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe uint GetDebugMessageLog(this GL glInstance, uint count, int bufSize, DebugSource[] sources, DebugType[] types, uint[] ids, DebugSeverity[] severities, int[] lengths, out string messageLog)
        {
            uint returnValue;
            fixed (DebugSource* sources_ptr = sources) // SpanOrArrayLayer
            {
                fixed (DebugType* types_ptr = types) // SpanOrArrayLayer
                {
                    fixed (uint* ids_ptr = ids) // SpanOrArrayLayer
                    {
                        fixed (DebugSeverity* severities_ptr = severities) // SpanOrArrayLayer
                        {
                            fixed (int* lengths_ptr = lengths) // SpanOrArrayLayer
                            {
                                var messageLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                                returnValue = glInstance.GetDebugMessageLog(count, bufSize, sources_ptr, types_ptr, ids_ptr, severities_ptr, lengths_ptr, messageLog_ptr);
                                messageLog = Marshal.PtrToStringUTF8((IntPtr)messageLog_ptr)!;
                                Marshal.FreeCoTaskMem((IntPtr)messageLog_ptr);
                            }
                        }
                    }
                }
            }
            return returnValue;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe uint GetDebugMessageLog(this GL glInstance, uint count, int bufSize, ref DebugSource sources, ref DebugType types, ref uint ids, ref DebugSeverity severities, ref int lengths, out string messageLog)
        {
            uint returnValue;
            fixed (DebugSource* sources_ptr = &sources) // RefInsteadOfPointerLayer
            fixed (DebugType* types_ptr = &types) // RefInsteadOfPointerLayer
            fixed (uint* ids_ptr = &ids) // RefInsteadOfPointerLayer
            fixed (DebugSeverity* severities_ptr = &severities) // RefInsteadOfPointerLayer
            fixed (int* lengths_ptr = &lengths) // RefInsteadOfPointerLayer
            {
                var messageLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                returnValue = glInstance.GetDebugMessageLog(count, bufSize, sources_ptr, types_ptr, ids_ptr, severities_ptr, lengths_ptr, messageLog_ptr);
                messageLog = Marshal.PtrToStringUTF8((IntPtr)messageLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)messageLog_ptr);
            }
            return returnValue;
        }

        // PushDebugGroup overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe void PushDebugGroup(this GL glInstance, DebugSource source, uint id, int length, string message)
        {
            byte* message_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(message);
            glInstance.PushDebugGroup(source, id, length, message_ptr);
            Marshal.FreeCoTaskMem((IntPtr)message_ptr);
        }

        // ObjectLabel overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe void ObjectLabel(this GL glInstance, ObjectIdentifier identifier, uint name, int length, string label)
        {
            byte* label_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(label);
            glInstance.ObjectLabel(identifier, name, length, label_ptr);
            Marshal.FreeCoTaskMem((IntPtr)label_ptr);
        }

        // GetObjectLabel overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetObjectLabel(this GL glInstance, ObjectIdentifier identifier, uint name, int bufSize, Span<int> length)
        {
            string label;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetObjectLabel(identifier, name, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            return label;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetObjectLabel(this GL glInstance, ObjectIdentifier identifier, uint name, int bufSize, Span<int> length, out string label)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetObjectLabel(identifier, name, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetObjectLabel(this GL glInstance, ObjectIdentifier identifier, uint name, int bufSize, int[] length)
        {
            string label;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetObjectLabel(identifier, name, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            return label;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetObjectLabel(this GL glInstance, ObjectIdentifier identifier, uint name, int bufSize, int[] length, out string label)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetObjectLabel(identifier, name, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetObjectLabel(this GL glInstance, ObjectIdentifier identifier, uint name, int bufSize, ref int length)
        {
            string label;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetObjectLabel(identifier, name, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            return label;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetObjectLabel(this GL glInstance, ObjectIdentifier identifier, uint name, int bufSize, ref int length, out string label)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetObjectLabel(identifier, name, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
        }

        // ObjectPtrLabel overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ObjectPtrLabel(this GL glInstance, IntPtr ptr, int length, string label)
        {
            byte* label_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(label);
            var ptr_vptr = (void*)ptr;
            glInstance.ObjectPtrLabel(ptr_vptr, length, label_ptr);
            Marshal.FreeCoTaskMem((IntPtr)label_ptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ObjectPtrLabel<T1>(this GL glInstance, in T1 ptr, int length, string label)
            where T1 : unmanaged
        {
            fixed (void* ptr_ptr = &ptr) // RefInsteadOfPointerLayer
            {
                byte* label_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(label);
                glInstance.ObjectPtrLabel(ptr_ptr, length, label_ptr);
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
        }

        // GetObjectPtrLabel overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetObjectPtrLabel(this GL glInstance, IntPtr ptr, int bufSize, Span<int> length)
        {
            string label;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                var ptr_vptr = (void*)ptr;
                glInstance.GetObjectPtrLabel(ptr_vptr, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            return label;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetObjectPtrLabel(this GL glInstance, IntPtr ptr, int bufSize, Span<int> length, out string label)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                var ptr_vptr = (void*)ptr;
                glInstance.GetObjectPtrLabel(ptr_vptr, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetObjectPtrLabel(this GL glInstance, IntPtr ptr, int bufSize, int[] length)
        {
            string label;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                var ptr_vptr = (void*)ptr;
                glInstance.GetObjectPtrLabel(ptr_vptr, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            return label;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetObjectPtrLabel(this GL glInstance, IntPtr ptr, int bufSize, int[] length, out string label)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                var ptr_vptr = (void*)ptr;
                glInstance.GetObjectPtrLabel(ptr_vptr, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetObjectPtrLabel(this GL glInstance, IntPtr ptr, int bufSize, ref int length)
        {
            string label;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                var ptr_vptr = (void*)ptr;
                glInstance.GetObjectPtrLabel(ptr_vptr, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            return label;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetObjectPtrLabel(this GL glInstance, IntPtr ptr, int bufSize, ref int length, out string label)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                var ptr_vptr = (void*)ptr;
                glInstance.GetObjectPtrLabel(ptr_vptr, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetObjectPtrLabel<T1>(this GL glInstance, in T1 ptr, int bufSize, Span<int> length)
            where T1 : unmanaged
        {
            string label;
            fixed (void* ptr_ptr = &ptr) // RefInsteadOfPointerLayer
            {
                fixed (int* length_ptr = length) // SpanOrArrayLayer
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    glInstance.GetObjectPtrLabel(ptr_ptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
            return label;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetObjectPtrLabel<T1>(this GL glInstance, in T1 ptr, int bufSize, Span<int> length, out string label)
            where T1 : unmanaged
        {
            fixed (void* ptr_ptr = &ptr) // RefInsteadOfPointerLayer
            {
                fixed (int* length_ptr = length) // SpanOrArrayLayer
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    glInstance.GetObjectPtrLabel(ptr_ptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetObjectPtrLabel<T1>(this GL glInstance, in T1 ptr, int bufSize, int[] length)
            where T1 : unmanaged
        {
            string label;
            fixed (void* ptr_ptr = &ptr) // RefInsteadOfPointerLayer
            {
                fixed (int* length_ptr = length) // SpanOrArrayLayer
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    glInstance.GetObjectPtrLabel(ptr_ptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
            return label;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetObjectPtrLabel<T1>(this GL glInstance, in T1 ptr, int bufSize, int[] length, out string label)
            where T1 : unmanaged
        {
            fixed (void* ptr_ptr = &ptr) // RefInsteadOfPointerLayer
            {
                fixed (int* length_ptr = length) // SpanOrArrayLayer
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    glInstance.GetObjectPtrLabel(ptr_ptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetObjectPtrLabel<T1>(this GL glInstance, in T1 ptr, int bufSize, ref int length)
            where T1 : unmanaged
        {
            string label;
            fixed (void* ptr_ptr = &ptr) // RefInsteadOfPointerLayer
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetObjectPtrLabel(ptr_ptr, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            return label;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetObjectPtrLabel<T1>(this GL glInstance, in T1 ptr, int bufSize, ref int length, out string label)
            where T1 : unmanaged
        {
            fixed (void* ptr_ptr = &ptr) // RefInsteadOfPointerLayer
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetObjectPtrLabel(ptr_ptr, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
        }

        // GetPointerv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void GetPointer(this GL glInstance, GetPointervPName pname, void** parameters) =>
            glInstance.GetPointerv(pname, parameters);

        // ColorMaski overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void ColorMaski(this GL glInstance, uint index, bool r, bool g, bool b, bool a)
        {
            var r_byte = (byte)(r ? 1 : 0);
            var g_byte = (byte)(g ? 1 : 0);
            var b_byte = (byte)(b ? 1 : 0);
            var a_byte = (byte)(a ? 1 : 0);
            glInstance.ColorMaski(index, r_byte, g_byte, b_byte, a_byte);
        }

        // DrawElementsBaseVertex overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void DrawElementsBaseVertex(this GL glInstance, PrimitiveType mode, int count, DrawElementsType type, nint offset, int basevertex)
        {
            void* indices = (void*)offset;
            glInstance.DrawElementsBaseVertex(mode, count, type, indices, basevertex);
        }

        // DrawRangeElementsBaseVertex overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void DrawRangeElementsBaseVertex(this GL glInstance, PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, nint offset, int basevertex)
        {
            void* indices = (void*)offset;
            glInstance.DrawRangeElementsBaseVertex(mode, start, end, count, type, indices, basevertex);
        }

        // DrawElementsInstancedBaseVertex overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void DrawElementsInstancedBaseVertex(this GL glInstance, PrimitiveType mode, int count, DrawElementsType type, nint offset, int instancecount, int basevertex)
        {
            void* indices = (void*)offset;
            glInstance.DrawElementsInstancedBaseVertex(mode, count, type, indices, instancecount, basevertex);
        }

        // ReadnPixels overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ReadnPixels(this GL glInstance, int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.ReadnPixels(x, y, width, height, format, type, bufSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ReadnPixels<T1>(this GL glInstance, int x, int y, int width, int height, PixelFormat format, PixelType type, Span<T1> data)
            where T1 : unmanaged
        {
            var bufSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.ReadnPixels(x, y, width, height, format, type, bufSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ReadnPixels<T1>(this GL glInstance, int x, int y, int width, int height, PixelFormat format, PixelType type, T1[] data)
            where T1 : unmanaged
        {
            var bufSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.ReadnPixels(x, y, width, height, format, type, bufSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ReadnPixels<T1>(this GL glInstance, int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, ref T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.ReadnPixels(x, y, width, height, format, type, bufSize, data_ptr);
            }
        }

        // GetnUniformfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformf(this GL glInstance, ProgramHandle program, int location, Span<float> parameters)
        {
            var bufSize = (int)(parameters.Length * 4);
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformfv(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformf(this GL glInstance, ProgramHandle program, int location, float[] parameters)
        {
            var bufSize = (int)(parameters.Length * 4);
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformfv(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnUniformf(this GL glInstance, ProgramHandle program, int location, int bufSize, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetnUniformfv(program, location, bufSize, parameters_ptr);
            }
        }

        // GetnUniformiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformi(this GL glInstance, ProgramHandle program, int location, Span<int> parameters)
        {
            var bufSize = (int)(parameters.Length * 4);
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformiv(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformi(this GL glInstance, ProgramHandle program, int location, int[] parameters)
        {
            var bufSize = (int)(parameters.Length * 4);
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformiv(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnUniformi(this GL glInstance, ProgramHandle program, int location, int bufSize, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetnUniformiv(program, location, bufSize, parameters_ptr);
            }
        }

        // GetnUniformuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformui(this GL glInstance, ProgramHandle program, int location, Span<uint> parameters)
        {
            var bufSize = (int)(parameters.Length * 4);
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformuiv(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformui(this GL glInstance, ProgramHandle program, int location, uint[] parameters)
        {
            var bufSize = (int)(parameters.Length * 4);
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformuiv(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnUniformui(this GL glInstance, ProgramHandle program, int location, int bufSize, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetnUniformuiv(program, location, bufSize, parameters_ptr);
            }
        }

        // TexParameterIiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexParameterIi(this GL glInstance, TextureTarget target, TextureParameterName pname, ReadOnlySpan<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexParameterIiv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexParameterIi(this GL glInstance, TextureTarget target, TextureParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexParameterIiv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexParameterIi(this GL glInstance, TextureTarget target, TextureParameterName pname, in int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.TexParameterIiv(target, pname, parameters_ptr);
            }
        }

        // TexParameterIuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexParameterIui(this GL glInstance, TextureTarget target, TextureParameterName pname, ReadOnlySpan<uint> parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexParameterIuiv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexParameterIui(this GL glInstance, TextureTarget target, TextureParameterName pname, uint[] parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexParameterIuiv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexParameterIui(this GL glInstance, TextureTarget target, TextureParameterName pname, in uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.TexParameterIuiv(target, pname, parameters_ptr);
            }
        }

        // GetTexParameterIiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexParameterIi(this GL glInstance, TextureTarget target, GetTextureParameter pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexParameterIiv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexParameterIi(this GL glInstance, TextureTarget target, GetTextureParameter pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexParameterIiv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTexParameterIi(this GL glInstance, TextureTarget target, GetTextureParameter pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTexParameterIiv(target, pname, parameters_ptr);
            }
        }

        // GetTexParameterIuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexParameterIui(this GL glInstance, TextureTarget target, GetTextureParameter pname, Span<uint> parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexParameterIuiv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexParameterIui(this GL glInstance, TextureTarget target, GetTextureParameter pname, uint[] parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexParameterIuiv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTexParameterIui(this GL glInstance, TextureTarget target, GetTextureParameter pname, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTexParameterIuiv(target, pname, parameters_ptr);
            }
        }

        // SamplerParameterIiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SamplerParameterIi(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, ReadOnlySpan<int> param)
        {
            fixed (int* param_ptr = param) // SpanOrArrayLayer
            {
                glInstance.SamplerParameterIiv(sampler, pname, param_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SamplerParameterIi(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, int[] param)
        {
            fixed (int* param_ptr = param) // SpanOrArrayLayer
            {
                glInstance.SamplerParameterIiv(sampler, pname, param_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SamplerParameterIi(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, in int param)
        {
            fixed (int* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.SamplerParameterIiv(sampler, pname, param_ptr);
            }
        }

        // SamplerParameterIuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SamplerParameterIui(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, ReadOnlySpan<uint> param)
        {
            fixed (uint* param_ptr = param) // SpanOrArrayLayer
            {
                glInstance.SamplerParameterIuiv(sampler, pname, param_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SamplerParameterIui(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, uint[] param)
        {
            fixed (uint* param_ptr = param) // SpanOrArrayLayer
            {
                glInstance.SamplerParameterIuiv(sampler, pname, param_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SamplerParameterIui(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, in uint param)
        {
            fixed (uint* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.SamplerParameterIuiv(sampler, pname, param_ptr);
            }
        }

        // GetSamplerParameterIiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSamplerParameterIi(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetSamplerParameterIiv(sampler, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSamplerParameterIi(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetSamplerParameterIiv(sampler, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetSamplerParameterIi(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetSamplerParameterIiv(sampler, pname, parameters_ptr);
            }
        }

        // GetSamplerParameterIuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSamplerParameterIui(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, Span<uint> parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetSamplerParameterIuiv(sampler, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSamplerParameterIui(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, uint[] parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetSamplerParameterIuiv(sampler, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetSamplerParameterIui(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetSamplerParameterIuiv(sampler, pname, parameters_ptr);
            }
        }

        // TexStorage3DMultisample overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void TexStorage3DMultisample(this GL glInstance, TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
        {
            var fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
            glInstance.TexStorage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations_byte);
        }
    }

#pragma warning restore IDE1006 // Naming Styles
}
