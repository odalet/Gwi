// This file is auto generated, do not edit.
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Gwi.OpenGL.GLCompat
{
#pragma warning disable IDE1006 // Naming Styles

    public static class APPLEOverloads
    {
        // ElementPointerAPPLE overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ElementPointerAPPLE(this GL.APPLEExtension glInstance, ElementPointerTypeATI type, IntPtr pointer)
        {
            var pointer_vptr = (void*)pointer;
            glInstance.ElementPointerAPPLE(type, pointer_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ElementPointerAPPLE<T1>(this GL.APPLEExtension glInstance, ElementPointerTypeATI type, ReadOnlySpan<T1> pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.ElementPointerAPPLE(type, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ElementPointerAPPLE<T1>(this GL.APPLEExtension glInstance, ElementPointerTypeATI type, T1[] pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.ElementPointerAPPLE(type, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ElementPointerAPPLE<T1>(this GL.APPLEExtension glInstance, ElementPointerTypeATI type, in T1 pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = &pointer) // RefInsteadOfPointerLayer
            {
                glInstance.ElementPointerAPPLE(type, pointer_ptr);
            }
        }

        // MultiDrawElementArrayAPPLE overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiDrawElementArrayAPPLE(this GL.APPLEExtension glInstance, PrimitiveType mode, ReadOnlySpan<int> first, ReadOnlySpan<int> count, int primcount)
        {
            fixed (int* first_ptr = first) // SpanOrArrayLayer
            {
                fixed (int* count_ptr = count) // SpanOrArrayLayer
                {
                    glInstance.MultiDrawElementArrayAPPLE(mode, first_ptr, count_ptr, primcount);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiDrawElementArrayAPPLE(this GL.APPLEExtension glInstance, PrimitiveType mode, int[] first, int[] count, int primcount)
        {
            fixed (int* first_ptr = first) // SpanOrArrayLayer
            {
                fixed (int* count_ptr = count) // SpanOrArrayLayer
                {
                    glInstance.MultiDrawElementArrayAPPLE(mode, first_ptr, count_ptr, primcount);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiDrawElementArrayAPPLE(this GL.APPLEExtension glInstance, PrimitiveType mode, in int first, in int count, int primcount)
        {
            fixed (int* first_ptr = &first) // RefInsteadOfPointerLayer
            fixed (int* count_ptr = &count) // RefInsteadOfPointerLayer
            {
                glInstance.MultiDrawElementArrayAPPLE(mode, first_ptr, count_ptr, primcount);
            }
        }

        // MultiDrawRangeElementArrayAPPLE overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiDrawRangeElementArrayAPPLE(this GL.APPLEExtension glInstance, PrimitiveType mode, uint start, uint end, ReadOnlySpan<int> first, ReadOnlySpan<int> count, int primcount)
        {
            fixed (int* first_ptr = first) // SpanOrArrayLayer
            {
                fixed (int* count_ptr = count) // SpanOrArrayLayer
                {
                    glInstance.MultiDrawRangeElementArrayAPPLE(mode, start, end, first_ptr, count_ptr, primcount);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiDrawRangeElementArrayAPPLE(this GL.APPLEExtension glInstance, PrimitiveType mode, uint start, uint end, int[] first, int[] count, int primcount)
        {
            fixed (int* first_ptr = first) // SpanOrArrayLayer
            {
                fixed (int* count_ptr = count) // SpanOrArrayLayer
                {
                    glInstance.MultiDrawRangeElementArrayAPPLE(mode, start, end, first_ptr, count_ptr, primcount);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiDrawRangeElementArrayAPPLE(this GL.APPLEExtension glInstance, PrimitiveType mode, uint start, uint end, in int first, in int count, int primcount)
        {
            fixed (int* first_ptr = &first) // RefInsteadOfPointerLayer
            fixed (int* count_ptr = &count) // RefInsteadOfPointerLayer
            {
                glInstance.MultiDrawRangeElementArrayAPPLE(mode, start, end, first_ptr, count_ptr, primcount);
            }
        }

        // GenFencesAPPLE overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenFencesAPPLE(this GL.APPLEExtension glInstance, Span<uint> fences)
        {
            var n = (int)(fences.Length);
            fixed (uint* fences_ptr = fences) // SpanOrArrayLayer
            {
                glInstance.GenFencesAPPLE(n, fences_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenFencesAPPLE(this GL.APPLEExtension glInstance, uint[] fences)
        {
            var n = (int)(fences.Length);
            fixed (uint* fences_ptr = fences) // SpanOrArrayLayer
            {
                glInstance.GenFencesAPPLE(n, fences_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenFencesAPPLE(this GL.APPLEExtension glInstance, int n, ref uint fences)
        {
            fixed (uint* fences_ptr = &fences) // RefInsteadOfPointerLayer
            {
                glInstance.GenFencesAPPLE(n, fences_ptr);
            }
        }

        // DeleteFencesAPPLE overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteFencesAPPLE(this GL.APPLEExtension glInstance, ReadOnlySpan<uint> fences)
        {
            var n = (int)(fences.Length);
            fixed (uint* fences_ptr = fences) // SpanOrArrayLayer
            {
                glInstance.DeleteFencesAPPLE(n, fences_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteFencesAPPLE(this GL.APPLEExtension glInstance, uint[] fences)
        {
            var n = (int)(fences.Length);
            fixed (uint* fences_ptr = fences) // SpanOrArrayLayer
            {
                glInstance.DeleteFencesAPPLE(n, fences_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteFencesAPPLE(this GL.APPLEExtension glInstance, int n, in uint fences)
        {
            fixed (uint* fences_ptr = &fences) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteFencesAPPLE(n, fences_ptr);
            }
        }

        // GetObjectParameterivAPPLE overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetObjectParameterivAPPLE(this GL.APPLEExtension glInstance, GLEnum objectType, uint name, GLEnum pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetObjectParameterivAPPLE(objectType, name, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetObjectParameterivAPPLE(this GL.APPLEExtension glInstance, GLEnum objectType, uint name, GLEnum pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetObjectParameterivAPPLE(objectType, name, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetObjectParameterivAPPLE(this GL.APPLEExtension glInstance, GLEnum objectType, uint name, GLEnum pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetObjectParameterivAPPLE(objectType, name, pname, parameters_ptr);
            }
        }

        // TextureRangeAPPLE overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void TextureRangeAPPLE(this GL.APPLEExtension glInstance, GLEnum target, int length, IntPtr pointer)
        {
            var pointer_vptr = (void*)pointer;
            glInstance.TextureRangeAPPLE(target, length, pointer_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TextureRangeAPPLE<T1>(this GL.APPLEExtension glInstance, GLEnum target, ReadOnlySpan<T1> pointer)
            where T1 : unmanaged
        {
            var length = (int)(pointer.Length * sizeof(T1));
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.TextureRangeAPPLE(target, length, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TextureRangeAPPLE<T1>(this GL.APPLEExtension glInstance, GLEnum target, T1[] pointer)
            where T1 : unmanaged
        {
            var length = (int)(pointer.Length * sizeof(T1));
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.TextureRangeAPPLE(target, length, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TextureRangeAPPLE<T1>(this GL.APPLEExtension glInstance, GLEnum target, int length, in T1 pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = &pointer) // RefInsteadOfPointerLayer
            {
                glInstance.TextureRangeAPPLE(target, length, pointer_ptr);
            }
        }

        // DeleteVertexArraysAPPLE overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteVertexArraysAPPLE(this GL.APPLEExtension glInstance, ReadOnlySpan<VertexArrayHandle> arrays)
        {
            var n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays) // SpanOrArrayLayer
            {
                glInstance.DeleteVertexArraysAPPLE(n, arrays_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteVertexArraysAPPLE(this GL.APPLEExtension glInstance, VertexArrayHandle[] arrays)
        {
            var n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays) // SpanOrArrayLayer
            {
                glInstance.DeleteVertexArraysAPPLE(n, arrays_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteVertexArraysAPPLE(this GL.APPLEExtension glInstance, int n, in VertexArrayHandle arrays)
        {
            fixed (VertexArrayHandle* arrays_ptr = &arrays) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteVertexArraysAPPLE(n, arrays_ptr);
            }
        }

        // GenVertexArraysAPPLE overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenVertexArraysAPPLE(this GL.APPLEExtension glInstance, Span<VertexArrayHandle> arrays)
        {
            var n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays) // SpanOrArrayLayer
            {
                glInstance.GenVertexArraysAPPLE(n, arrays_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenVertexArraysAPPLE(this GL.APPLEExtension glInstance, VertexArrayHandle[] arrays)
        {
            var n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays) // SpanOrArrayLayer
            {
                glInstance.GenVertexArraysAPPLE(n, arrays_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenVertexArraysAPPLE(this GL.APPLEExtension glInstance, int n, ref VertexArrayHandle arrays)
        {
            fixed (VertexArrayHandle* arrays_ptr = &arrays) // RefInsteadOfPointerLayer
            {
                glInstance.GenVertexArraysAPPLE(n, arrays_ptr);
            }
        }

        // VertexArrayRangeAPPLE overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void VertexArrayRangeAPPLE(this GL.APPLEExtension glInstance, int length, IntPtr pointer)
        {
            var pointer_vptr = (void*)pointer;
            glInstance.VertexArrayRangeAPPLE(length, pointer_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexArrayRangeAPPLE<T1>(this GL.APPLEExtension glInstance, Span<T1> pointer)
            where T1 : unmanaged
        {
            var length = (int)(pointer.Length * sizeof(T1));
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.VertexArrayRangeAPPLE(length, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexArrayRangeAPPLE<T1>(this GL.APPLEExtension glInstance, T1[] pointer)
            where T1 : unmanaged
        {
            var length = (int)(pointer.Length * sizeof(T1));
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.VertexArrayRangeAPPLE(length, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexArrayRangeAPPLE<T1>(this GL.APPLEExtension glInstance, int length, ref T1 pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = &pointer) // RefInsteadOfPointerLayer
            {
                glInstance.VertexArrayRangeAPPLE(length, pointer_ptr);
            }
        }

        // FlushVertexArrayRangeAPPLE overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void FlushVertexArrayRangeAPPLE(this GL.APPLEExtension glInstance, int length, IntPtr pointer)
        {
            var pointer_vptr = (void*)pointer;
            glInstance.FlushVertexArrayRangeAPPLE(length, pointer_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void FlushVertexArrayRangeAPPLE<T1>(this GL.APPLEExtension glInstance, Span<T1> pointer)
            where T1 : unmanaged
        {
            var length = (int)(pointer.Length * sizeof(T1));
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.FlushVertexArrayRangeAPPLE(length, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void FlushVertexArrayRangeAPPLE<T1>(this GL.APPLEExtension glInstance, T1[] pointer)
            where T1 : unmanaged
        {
            var length = (int)(pointer.Length * sizeof(T1));
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.FlushVertexArrayRangeAPPLE(length, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void FlushVertexArrayRangeAPPLE<T1>(this GL.APPLEExtension glInstance, int length, ref T1 pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = &pointer) // RefInsteadOfPointerLayer
            {
                glInstance.FlushVertexArrayRangeAPPLE(length, pointer_ptr);
            }
        }

        // MapVertexAttrib1dAPPLE overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MapVertexAttrib1dAPPLE(this GL.APPLEExtension glInstance, uint index, uint size, double u1, double u2, int stride, int order, ReadOnlySpan<double> points)
        {
            fixed (double* points_ptr = points) // SpanOrArrayLayer
            {
                glInstance.MapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MapVertexAttrib1dAPPLE(this GL.APPLEExtension glInstance, uint index, uint size, double u1, double u2, int stride, int order, double[] points)
        {
            fixed (double* points_ptr = points) // SpanOrArrayLayer
            {
                glInstance.MapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MapVertexAttrib1dAPPLE(this GL.APPLEExtension glInstance, uint index, uint size, double u1, double u2, int stride, int order, in double points)
        {
            fixed (double* points_ptr = &points) // RefInsteadOfPointerLayer
            {
                glInstance.MapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points_ptr);
            }
        }

        // MapVertexAttrib1fAPPLE overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MapVertexAttrib1fAPPLE(this GL.APPLEExtension glInstance, uint index, uint size, float u1, float u2, int stride, int order, ReadOnlySpan<float> points)
        {
            fixed (float* points_ptr = points) // SpanOrArrayLayer
            {
                glInstance.MapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MapVertexAttrib1fAPPLE(this GL.APPLEExtension glInstance, uint index, uint size, float u1, float u2, int stride, int order, float[] points)
        {
            fixed (float* points_ptr = points) // SpanOrArrayLayer
            {
                glInstance.MapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MapVertexAttrib1fAPPLE(this GL.APPLEExtension glInstance, uint index, uint size, float u1, float u2, int stride, int order, in float points)
        {
            fixed (float* points_ptr = &points) // RefInsteadOfPointerLayer
            {
                glInstance.MapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points_ptr);
            }
        }

        // MapVertexAttrib2dAPPLE overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MapVertexAttrib2dAPPLE(this GL.APPLEExtension glInstance, uint index, uint size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, ReadOnlySpan<double> points)
        {
            fixed (double* points_ptr = points) // SpanOrArrayLayer
            {
                glInstance.MapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MapVertexAttrib2dAPPLE(this GL.APPLEExtension glInstance, uint index, uint size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double[] points)
        {
            fixed (double* points_ptr = points) // SpanOrArrayLayer
            {
                glInstance.MapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MapVertexAttrib2dAPPLE(this GL.APPLEExtension glInstance, uint index, uint size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, in double points)
        {
            fixed (double* points_ptr = &points) // RefInsteadOfPointerLayer
            {
                glInstance.MapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_ptr);
            }
        }

        // MapVertexAttrib2fAPPLE overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MapVertexAttrib2fAPPLE(this GL.APPLEExtension glInstance, uint index, uint size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, ReadOnlySpan<float> points)
        {
            fixed (float* points_ptr = points) // SpanOrArrayLayer
            {
                glInstance.MapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MapVertexAttrib2fAPPLE(this GL.APPLEExtension glInstance, uint index, uint size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float[] points)
        {
            fixed (float* points_ptr = points) // SpanOrArrayLayer
            {
                glInstance.MapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MapVertexAttrib2fAPPLE(this GL.APPLEExtension glInstance, uint index, uint size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, in float points)
        {
            fixed (float* points_ptr = &points) // RefInsteadOfPointerLayer
            {
                glInstance.MapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_ptr);
            }
        }
    }

#pragma warning restore IDE1006 // Naming Styles
}
