// This file is auto generated, do not edit.
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Gwi.OpenGL.GL4
{
#pragma warning disable IDE1006 // Naming Styles

    public static class ARBOverloads
    {
        // ShaderBinary overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ShaderBinary(this GL.ARBExtension glInstance, ReadOnlySpan<ShaderHandle> shaders, ShaderBinaryFormat binaryFormat, IntPtr binary, int length)
        {
            var count = (int)(shaders.Length);
            fixed (ShaderHandle* shaders_ptr = shaders) // SpanOrArrayLayer
            {
                var binary_vptr = (void*)binary;
                glInstance.ShaderBinary(count, shaders_ptr, binaryFormat, binary_vptr, length);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ShaderBinary(this GL.ARBExtension glInstance, ShaderHandle[] shaders, ShaderBinaryFormat binaryFormat, IntPtr binary, int length)
        {
            var count = (int)(shaders.Length);
            fixed (ShaderHandle* shaders_ptr = shaders) // SpanOrArrayLayer
            {
                var binary_vptr = (void*)binary;
                glInstance.ShaderBinary(count, shaders_ptr, binaryFormat, binary_vptr, length);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ShaderBinary(this GL.ARBExtension glInstance, int count, in ShaderHandle shaders, ShaderBinaryFormat binaryFormat, IntPtr binary, int length)
        {
            fixed (ShaderHandle* shaders_ptr = &shaders) // RefInsteadOfPointerLayer
            {
                var binary_vptr = (void*)binary;
                glInstance.ShaderBinary(count, shaders_ptr, binaryFormat, binary_vptr, length);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ShaderBinary<T1>(this GL.ARBExtension glInstance, ReadOnlySpan<ShaderHandle> shaders, ShaderBinaryFormat binaryFormat, ReadOnlySpan<T1> binary)
            where T1 : unmanaged
        {
            var count = (int)(shaders.Length);
            fixed (ShaderHandle* shaders_ptr = shaders) // SpanOrArrayLayer
            {
                var length = (int)(binary.Length * sizeof(T1));
                fixed (void* binary_ptr = binary) // SpanOrArrayLayer
                {
                    glInstance.ShaderBinary(count, shaders_ptr, binaryFormat, binary_ptr, length);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ShaderBinary<T1>(this GL.ARBExtension glInstance, ShaderHandle[] shaders, ShaderBinaryFormat binaryFormat, T1[] binary)
            where T1 : unmanaged
        {
            var count = (int)(shaders.Length);
            fixed (ShaderHandle* shaders_ptr = shaders) // SpanOrArrayLayer
            {
                var length = (int)(binary.Length * sizeof(T1));
                fixed (void* binary_ptr = binary) // SpanOrArrayLayer
                {
                    glInstance.ShaderBinary(count, shaders_ptr, binaryFormat, binary_ptr, length);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ShaderBinary<T1>(this GL.ARBExtension glInstance, int count, in ShaderHandle shaders, ShaderBinaryFormat binaryFormat, in T1 binary, int length)
            where T1 : unmanaged
        {
            fixed (ShaderHandle* shaders_ptr = &shaders) // RefInsteadOfPointerLayer
            fixed (void* binary_ptr = &binary) // RefInsteadOfPointerLayer
            {
                glInstance.ShaderBinary(count, shaders_ptr, binaryFormat, binary_ptr, length);
            }
        }

        // GetShaderPrecisionFormat overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetShaderPrecisionFormat(this GL.ARBExtension glInstance, ShaderType shadertype, PrecisionType precisiontype, Span<int> range, Span<int> precision)
        {
            fixed (int* range_ptr = range) // SpanOrArrayLayer
            {
                fixed (int* precision_ptr = precision) // SpanOrArrayLayer
                {
                    glInstance.GetShaderPrecisionFormat(shadertype, precisiontype, range_ptr, precision_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetShaderPrecisionFormat(this GL.ARBExtension glInstance, ShaderType shadertype, PrecisionType precisiontype, int[] range, int[] precision)
        {
            fixed (int* range_ptr = range) // SpanOrArrayLayer
            {
                fixed (int* precision_ptr = precision) // SpanOrArrayLayer
                {
                    glInstance.GetShaderPrecisionFormat(shadertype, precisiontype, range_ptr, precision_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetShaderPrecisionFormat(this GL.ARBExtension glInstance, ShaderType shadertype, PrecisionType precisiontype, ref int range, ref int precision)
        {
            fixed (int* range_ptr = &range) // RefInsteadOfPointerLayer
            fixed (int* precision_ptr = &precision) // RefInsteadOfPointerLayer
            {
                glInstance.GetShaderPrecisionFormat(shadertype, precisiontype, range_ptr, precision_ptr);
            }
        }

        // DrawElementsInstancedBaseInstance overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void DrawElementsInstancedBaseInstance(this GL.ARBExtension glInstance, PrimitiveType mode, int count, PrimitiveType type, nint offset, int instancecount, uint baseinstance)
        {
            void* indices = (void*)offset;
            glInstance.DrawElementsInstancedBaseInstance(mode, count, type, indices, instancecount, baseinstance);
        }

        // DrawElementsInstancedBaseVertexBaseInstance overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void DrawElementsInstancedBaseVertexBaseInstance(this GL.ARBExtension glInstance, PrimitiveType mode, int count, DrawElementsType type, nint offset, int instancecount, int basevertex, uint baseinstance)
        {
            void* indices = (void*)offset;
            glInstance.DrawElementsInstancedBaseVertexBaseInstance(mode, count, type, indices, instancecount, basevertex, baseinstance);
        }

        // GetImageHandleARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe ulong GetImageHandleARB(this GL.ARBExtension glInstance, TextureHandle texture, int level, bool layered, int layer, PixelFormat format)
        {
            ulong returnValue;
            var layered_byte = (byte)(layered ? 1 : 0);
            returnValue = glInstance.GetImageHandleARB(texture, level, layered_byte, layer, format);
            return returnValue;
        }

        // UniformHandleui64vARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformHandleui64vARB(this GL.ARBExtension glInstance, int location, ReadOnlySpan<ulong> value)
        {
            var count = (int)(value.Length);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.UniformHandleui64vARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformHandleui64vARB(this GL.ARBExtension glInstance, int location, ulong[] value)
        {
            var count = (int)(value.Length);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.UniformHandleui64vARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformHandleui64vARB(this GL.ARBExtension glInstance, int location, int count, in ulong value)
        {
            fixed (ulong* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.UniformHandleui64vARB(location, count, value_ptr);
            }
        }

        // ProgramUniformHandleui64vARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformHandleui64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<ulong> values)
        {
            var count = (int)(values.Length);
            fixed (ulong* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.ProgramUniformHandleui64vARB(program, location, count, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformHandleui64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, ulong[] values)
        {
            var count = (int)(values.Length);
            fixed (ulong* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.ProgramUniformHandleui64vARB(program, location, count, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformHandleui64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in ulong values)
        {
            fixed (ulong* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniformHandleui64vARB(program, location, count, values_ptr);
            }
        }

        // VertexAttribL1ui64vARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribL1ui64vARB(this GL.ARBExtension glInstance, uint index, in ulong v)
        {
            fixed (ulong* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttribL1ui64vARB(index, v_ptr);
            }
        }

        // GetVertexAttribLui64vARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetVertexAttribLui64vARB(this GL.ARBExtension glInstance, uint index, VertexAttribEnum pname, ref ulong parameters)
        {
            fixed (ulong* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetVertexAttribLui64vARB(index, pname, parameters_ptr);
            }
        }

        // BindFragDataLocationIndexed overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe void BindFragDataLocationIndexed(this GL.ARBExtension glInstance, ProgramHandle program, uint colorNumber, uint index, string name)
        {
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            glInstance.BindFragDataLocationIndexed(program, colorNumber, index, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
        }

        // GetFragDataIndex overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe int GetFragDataIndex(this GL.ARBExtension glInstance, ProgramHandle program, string name)
        {
            int returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = glInstance.GetFragDataIndex(program, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }

        // BufferStorage overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void BufferStorage(this GL.ARBExtension glInstance, BufferStorageTarget target, nint size, IntPtr data, BufferStorageMask flags)
        {
            var data_vptr = (void*)data;
            glInstance.BufferStorage(target, size, data_vptr, flags);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BufferStorage<T1>(this GL.ARBExtension glInstance, BufferStorageTarget target, ReadOnlySpan<T1> data, BufferStorageMask flags)
            where T1 : unmanaged
        {
            var size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.BufferStorage(target, size, data_ptr, flags);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BufferStorage<T1>(this GL.ARBExtension glInstance, BufferStorageTarget target, T1[] data, BufferStorageMask flags)
            where T1 : unmanaged
        {
            var size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.BufferStorage(target, size, data_ptr, flags);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void BufferStorage<T1>(this GL.ARBExtension glInstance, BufferStorageTarget target, nint size, in T1 data, BufferStorageMask flags)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.BufferStorage(target, size, data_ptr, flags);
            }
        }

        // CreateSyncFromCLeventARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe GLSync CreateSyncFromCLeventARB(this GL.ARBExtension glInstance, ref CLContext context, ref CLEvent @event, GLEnum flags)
        {
            GLSync returnValue;
            fixed (CLContext* context_ptr = &context) // RefInsteadOfPointerLayer
            fixed (CLEvent* @event_ptr = &@event) // RefInsteadOfPointerLayer
            {
                returnValue = glInstance.CreateSyncFromCLeventARB(context_ptr, @event_ptr, flags);
            }
            return returnValue;
        }

        // ClearBufferData overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ClearBufferData(this GL.ARBExtension glInstance, BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.ClearBufferData(target, internalformat, format, type, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearBufferData<T1>(this GL.ARBExtension glInstance, BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.ClearBufferData(target, internalformat, format, type, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearBufferData<T1>(this GL.ARBExtension glInstance, BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, T1[] data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.ClearBufferData(target, internalformat, format, type, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClearBufferData<T1>(this GL.ARBExtension glInstance, BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.ClearBufferData(target, internalformat, format, type, data_ptr);
            }
        }

        // ClearBufferSubData overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ClearBufferSubData(this GL.ARBExtension glInstance, BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.ClearBufferSubData(target, internalformat, offset, size, format, type, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearBufferSubData<T1>(this GL.ARBExtension glInstance, BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.ClearBufferSubData(target, internalformat, offset, size, format, type, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearBufferSubData<T1>(this GL.ARBExtension glInstance, BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, T1[] data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.ClearBufferSubData(target, internalformat, offset, size, format, type, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClearBufferSubData<T1>(this GL.ARBExtension glInstance, BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.ClearBufferSubData(target, internalformat, offset, size, format, type, data_ptr);
            }
        }

        // ClearTexImage overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ClearTexImage(this GL.ARBExtension glInstance, TextureHandle texture, int level, PixelFormat format, PixelType type, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.ClearTexImage(texture, level, format, type, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearTexImage<T1>(this GL.ARBExtension glInstance, TextureHandle texture, int level, PixelFormat format, PixelType type, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.ClearTexImage(texture, level, format, type, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearTexImage<T1>(this GL.ARBExtension glInstance, TextureHandle texture, int level, PixelFormat format, PixelType type, T1[] data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.ClearTexImage(texture, level, format, type, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClearTexImage<T1>(this GL.ARBExtension glInstance, TextureHandle texture, int level, PixelFormat format, PixelType type, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.ClearTexImage(texture, level, format, type, data_ptr);
            }
        }

        // ClearTexSubImage overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ClearTexSubImage(this GL.ARBExtension glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.ClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearTexSubImage<T1>(this GL.ARBExtension glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.ClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearTexSubImage<T1>(this GL.ARBExtension glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, T1[] data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.ClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClearTexSubImage<T1>(this GL.ARBExtension glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.ClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data_ptr);
            }
        }

        // DebugMessageControlARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DebugMessageControlARB(this GL.ARBExtension glInstance, DebugSource source, DebugType type, DebugSeverity severity, ReadOnlySpan<uint> ids, bool enabled)
        {
            var count = (int)(ids.Length);
            fixed (uint* ids_ptr = ids) // SpanOrArrayLayer
            {
                var enabled_byte = (byte)(enabled ? 1 : 0);
                glInstance.DebugMessageControlARB(source, type, severity, count, ids_ptr, enabled_byte);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DebugMessageControlARB(this GL.ARBExtension glInstance, DebugSource source, DebugType type, DebugSeverity severity, uint[] ids, bool enabled)
        {
            var count = (int)(ids.Length);
            fixed (uint* ids_ptr = ids) // SpanOrArrayLayer
            {
                var enabled_byte = (byte)(enabled ? 1 : 0);
                glInstance.DebugMessageControlARB(source, type, severity, count, ids_ptr, enabled_byte);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DebugMessageControlARB(this GL.ARBExtension glInstance, DebugSource source, DebugType type, DebugSeverity severity, int count, in uint ids, bool enabled)
        {
            fixed (uint* ids_ptr = &ids) // RefInsteadOfPointerLayer
            {
                var enabled_byte = (byte)(enabled ? 1 : 0);
                glInstance.DebugMessageControlARB(source, type, severity, count, ids_ptr, enabled_byte);
            }
        }

        // DebugMessageInsertARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe void DebugMessageInsertARB(this GL.ARBExtension glInstance, DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, string buf)
        {
            byte* buf_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(buf);
            glInstance.DebugMessageInsertARB(source, type, id, severity, length, buf_ptr);
            Marshal.FreeCoTaskMem((IntPtr)buf_ptr);
        }

        // DebugMessageCallbackARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void DebugMessageCallbackARB(this GL.ARBExtension glInstance, GLDebugProcARB callback, IntPtr userParam)
        {
            var userParam_vptr = (void*)userParam;
            IntPtr callback_ptr = Marshal.GetFunctionPointerForDelegate(callback);
            glInstance.DebugMessageCallbackARB(callback_ptr, userParam_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DebugMessageCallbackARB<T1>(this GL.ARBExtension glInstance, GLDebugProcARB callback, ReadOnlySpan<T1> userParam)
            where T1 : unmanaged
        {
            fixed (void* userParam_ptr = userParam) // SpanOrArrayLayer
            {
                IntPtr callback_ptr = Marshal.GetFunctionPointerForDelegate(callback);
                glInstance.DebugMessageCallbackARB(callback_ptr, userParam_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DebugMessageCallbackARB<T1>(this GL.ARBExtension glInstance, GLDebugProcARB callback, T1[] userParam)
            where T1 : unmanaged
        {
            fixed (void* userParam_ptr = userParam) // SpanOrArrayLayer
            {
                IntPtr callback_ptr = Marshal.GetFunctionPointerForDelegate(callback);
                glInstance.DebugMessageCallbackARB(callback_ptr, userParam_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DebugMessageCallbackARB<T1>(this GL.ARBExtension glInstance, GLDebugProcARB callback, in T1 userParam)
            where T1 : unmanaged
        {
            fixed (void* userParam_ptr = &userParam) // RefInsteadOfPointerLayer
            {
                IntPtr callback_ptr = Marshal.GetFunctionPointerForDelegate(callback);
                glInstance.DebugMessageCallbackARB(callback_ptr, userParam_ptr);
            }
        }

        // GetDebugMessageLogARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe uint GetDebugMessageLogARB(this GL.ARBExtension glInstance, uint count, int bufSize, Span<DebugSource> sources, Span<DebugType> types, Span<uint> ids, Span<DebugSeverity> severities, Span<int> lengths, out string messageLog)
        {
            uint returnValue;
            fixed (DebugSource* sources_ptr = sources) // SpanOrArrayLayer
            {
                fixed (DebugType* types_ptr = types) // SpanOrArrayLayer
                {
                    fixed (uint* ids_ptr = ids) // SpanOrArrayLayer
                    {
                        fixed (DebugSeverity* severities_ptr = severities) // SpanOrArrayLayer
                        {
                            fixed (int* lengths_ptr = lengths) // SpanOrArrayLayer
                            {
                                var messageLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                                returnValue = glInstance.GetDebugMessageLogARB(count, bufSize, sources_ptr, types_ptr, ids_ptr, severities_ptr, lengths_ptr, messageLog_ptr);
                                messageLog = Marshal.PtrToStringUTF8((IntPtr)messageLog_ptr)!;
                                Marshal.FreeCoTaskMem((IntPtr)messageLog_ptr);
                            }
                        }
                    }
                }
            }
            return returnValue;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe uint GetDebugMessageLogARB(this GL.ARBExtension glInstance, uint count, int bufSize, DebugSource[] sources, DebugType[] types, uint[] ids, DebugSeverity[] severities, int[] lengths, out string messageLog)
        {
            uint returnValue;
            fixed (DebugSource* sources_ptr = sources) // SpanOrArrayLayer
            {
                fixed (DebugType* types_ptr = types) // SpanOrArrayLayer
                {
                    fixed (uint* ids_ptr = ids) // SpanOrArrayLayer
                    {
                        fixed (DebugSeverity* severities_ptr = severities) // SpanOrArrayLayer
                        {
                            fixed (int* lengths_ptr = lengths) // SpanOrArrayLayer
                            {
                                var messageLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                                returnValue = glInstance.GetDebugMessageLogARB(count, bufSize, sources_ptr, types_ptr, ids_ptr, severities_ptr, lengths_ptr, messageLog_ptr);
                                messageLog = Marshal.PtrToStringUTF8((IntPtr)messageLog_ptr)!;
                                Marshal.FreeCoTaskMem((IntPtr)messageLog_ptr);
                            }
                        }
                    }
                }
            }
            return returnValue;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe uint GetDebugMessageLogARB(this GL.ARBExtension glInstance, uint count, int bufSize, ref DebugSource sources, ref DebugType types, ref uint ids, ref DebugSeverity severities, ref int lengths, out string messageLog)
        {
            uint returnValue;
            fixed (DebugSource* sources_ptr = &sources) // RefInsteadOfPointerLayer
            fixed (DebugType* types_ptr = &types) // RefInsteadOfPointerLayer
            fixed (uint* ids_ptr = &ids) // RefInsteadOfPointerLayer
            fixed (DebugSeverity* severities_ptr = &severities) // RefInsteadOfPointerLayer
            fixed (int* lengths_ptr = &lengths) // RefInsteadOfPointerLayer
            {
                var messageLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                returnValue = glInstance.GetDebugMessageLogARB(count, bufSize, sources_ptr, types_ptr, ids_ptr, severities_ptr, lengths_ptr, messageLog_ptr);
                messageLog = Marshal.PtrToStringUTF8((IntPtr)messageLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)messageLog_ptr);
            }
            return returnValue;
        }

        // CreateTransformFeedbacks overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe TransformFeedbackHandle CreateTransformFeedback(this GL.ARBExtension glInstance)
        {
            TransformFeedbackHandle ids;
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TransformFeedbackHandle* ids_handle = (TransformFeedbackHandle*)Unsafe.AsPointer(ref ids);
            glInstance.CreateTransformFeedbacks(n, ids_handle);
            return ids;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void CreateTransformFeedback(this GL.ARBExtension glInstance, out TransformFeedbackHandle ids)
        {
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TransformFeedbackHandle* ids_handle = (TransformFeedbackHandle*)Unsafe.AsPointer(ref ids);
            glInstance.CreateTransformFeedbacks(n, ids_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateTransformFeedbacks(this GL.ARBExtension glInstance, Span<TransformFeedbackHandle> ids)
        {
            var n = (int)(ids.Length);
            fixed (TransformFeedbackHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.CreateTransformFeedbacks(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateTransformFeedbacks(this GL.ARBExtension glInstance, TransformFeedbackHandle[] ids)
        {
            var n = (int)(ids.Length);
            fixed (TransformFeedbackHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.CreateTransformFeedbacks(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CreateTransformFeedbacks(this GL.ARBExtension glInstance, int n, ref TransformFeedbackHandle ids)
        {
            fixed (TransformFeedbackHandle* ids_ptr = &ids) // RefInsteadOfPointerLayer
            {
                glInstance.CreateTransformFeedbacks(n, ids_ptr);
            }
        }

        // GetTransformFeedbackiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTransformFeedbacki(this GL.ARBExtension glInstance, TransformFeedbackHandle xfb, TransformFeedbackPName pname, ref int param)
        {
            fixed (int* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.GetTransformFeedbackiv(xfb, pname, param_ptr);
            }
        }

        // GetTransformFeedbacki_v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTransformFeedback(this GL.ARBExtension glInstance, TransformFeedbackHandle xfb, TransformFeedbackPName pname, uint index, ref int param)
        {
            fixed (int* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.GetTransformFeedbacki_v(xfb, pname, index, param_ptr);
            }
        }

        // GetTransformFeedbacki64_v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTransformFeedbacki64_(this GL.ARBExtension glInstance, TransformFeedbackHandle xfb, TransformFeedbackPName pname, uint index, ref long param)
        {
            fixed (long* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.GetTransformFeedbacki64_v(xfb, pname, index, param_ptr);
            }
        }

        // CreateBuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe BufferHandle CreateBuffer(this GL.ARBExtension glInstance)
        {
            BufferHandle buffers;
            int n = 1;
            Unsafe.SkipInit(out buffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            BufferHandle* buffers_handle = (BufferHandle*)Unsafe.AsPointer(ref buffers);
            glInstance.CreateBuffers(n, buffers_handle);
            return buffers;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void CreateBuffer(this GL.ARBExtension glInstance, out BufferHandle buffers)
        {
            int n = 1;
            Unsafe.SkipInit(out buffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            BufferHandle* buffers_handle = (BufferHandle*)Unsafe.AsPointer(ref buffers);
            glInstance.CreateBuffers(n, buffers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateBuffers(this GL.ARBExtension glInstance, Span<BufferHandle> buffers)
        {
            var n = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                glInstance.CreateBuffers(n, buffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateBuffers(this GL.ARBExtension glInstance, BufferHandle[] buffers)
        {
            var n = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                glInstance.CreateBuffers(n, buffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CreateBuffers(this GL.ARBExtension glInstance, int n, ref BufferHandle buffers)
        {
            fixed (BufferHandle* buffers_ptr = &buffers) // RefInsteadOfPointerLayer
            {
                glInstance.CreateBuffers(n, buffers_ptr);
            }
        }

        // NamedBufferStorage overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void NamedBufferStorage(this GL.ARBExtension glInstance, BufferHandle buffer, nint size, IntPtr data, BufferStorageMask flags)
        {
            var data_vptr = (void*)data;
            glInstance.NamedBufferStorage(buffer, size, data_vptr, flags);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void NamedBufferStorage<T1>(this GL.ARBExtension glInstance, BufferHandle buffer, ReadOnlySpan<T1> data, BufferStorageMask flags)
            where T1 : unmanaged
        {
            var size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.NamedBufferStorage(buffer, size, data_ptr, flags);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void NamedBufferStorage<T1>(this GL.ARBExtension glInstance, BufferHandle buffer, T1[] data, BufferStorageMask flags)
            where T1 : unmanaged
        {
            var size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.NamedBufferStorage(buffer, size, data_ptr, flags);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void NamedBufferStorage<T1>(this GL.ARBExtension glInstance, BufferHandle buffer, nint size, in T1 data, BufferStorageMask flags)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.NamedBufferStorage(buffer, size, data_ptr, flags);
            }
        }

        // NamedBufferData overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void NamedBufferData(this GL.ARBExtension glInstance, BufferHandle buffer, nint size, IntPtr data, VertexBufferObjectUsage usage)
        {
            var data_vptr = (void*)data;
            glInstance.NamedBufferData(buffer, size, data_vptr, usage);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void NamedBufferData<T1>(this GL.ARBExtension glInstance, BufferHandle buffer, nint size, in T1 data, VertexBufferObjectUsage usage)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.NamedBufferData(buffer, size, data_ptr, usage);
            }
        }

        // NamedBufferSubData overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void NamedBufferSubData(this GL.ARBExtension glInstance, BufferHandle buffer, IntPtr offset, nint size, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.NamedBufferSubData(buffer, offset, size, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void NamedBufferSubData<T1>(this GL.ARBExtension glInstance, BufferHandle buffer, IntPtr offset, nint size, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.NamedBufferSubData(buffer, offset, size, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void NamedBufferSubData<T1>(this GL.ARBExtension glInstance, BufferHandle buffer, IntPtr offset, nint size, T1[] data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.NamedBufferSubData(buffer, offset, size, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void NamedBufferSubData<T1>(this GL.ARBExtension glInstance, BufferHandle buffer, IntPtr offset, nint size, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.NamedBufferSubData(buffer, offset, size, data_ptr);
            }
        }

        // ClearNamedBufferData overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ClearNamedBufferData(this GL.ARBExtension glInstance, BufferHandle buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.ClearNamedBufferData(buffer, internalformat, format, type, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClearNamedBufferData<T1>(this GL.ARBExtension glInstance, BufferHandle buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.ClearNamedBufferData(buffer, internalformat, format, type, data_ptr);
            }
        }

        // ClearNamedBufferSubData overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ClearNamedBufferSubData(this GL.ARBExtension glInstance, BufferHandle buffer, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.ClearNamedBufferSubData(buffer, internalformat, offset, size, format, type, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClearNamedBufferSubData<T1>(this GL.ARBExtension glInstance, BufferHandle buffer, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.ClearNamedBufferSubData(buffer, internalformat, offset, size, format, type, data_ptr);
            }
        }

        // GetNamedBufferParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetNamedBufferParameteri(this GL.ARBExtension glInstance, BufferHandle buffer, BufferPNameARB pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetNamedBufferParameteriv(buffer, pname, parameters_ptr);
            }
        }

        // GetNamedBufferParameteri64v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetNamedBufferParameteri64(this GL.ARBExtension glInstance, BufferHandle buffer, BufferPNameARB pname, ref long parameters)
        {
            fixed (long* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetNamedBufferParameteri64v(buffer, pname, parameters_ptr);
            }
        }

        // GetNamedBufferPointerv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void GetNamedBufferPointer(this GL.ARBExtension glInstance, BufferHandle buffer, BufferPointerNameARB pname, void** parameters) =>
            glInstance.GetNamedBufferPointerv(buffer, pname, parameters);

        // GetNamedBufferSubData overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetNamedBufferSubData(this GL.ARBExtension glInstance, BufferHandle buffer, IntPtr offset, nint size, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.GetNamedBufferSubData(buffer, offset, size, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetNamedBufferSubData<T1>(this GL.ARBExtension glInstance, BufferHandle buffer, IntPtr offset, nint size, ref T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetNamedBufferSubData(buffer, offset, size, data_ptr);
            }
        }

        // CreateFramebuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe FramebufferHandle CreateFramebuffer(this GL.ARBExtension glInstance)
        {
            FramebufferHandle framebuffers;
            int n = 1;
            Unsafe.SkipInit(out framebuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            FramebufferHandle* framebuffers_handle = (FramebufferHandle*)Unsafe.AsPointer(ref framebuffers);
            glInstance.CreateFramebuffers(n, framebuffers_handle);
            return framebuffers;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void CreateFramebuffer(this GL.ARBExtension glInstance, out FramebufferHandle framebuffers)
        {
            int n = 1;
            Unsafe.SkipInit(out framebuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            FramebufferHandle* framebuffers_handle = (FramebufferHandle*)Unsafe.AsPointer(ref framebuffers);
            glInstance.CreateFramebuffers(n, framebuffers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateFramebuffers(this GL.ARBExtension glInstance, Span<FramebufferHandle> framebuffers)
        {
            var n = (int)(framebuffers.Length);
            fixed (FramebufferHandle* framebuffers_ptr = framebuffers) // SpanOrArrayLayer
            {
                glInstance.CreateFramebuffers(n, framebuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateFramebuffers(this GL.ARBExtension glInstance, FramebufferHandle[] framebuffers)
        {
            var n = (int)(framebuffers.Length);
            fixed (FramebufferHandle* framebuffers_ptr = framebuffers) // SpanOrArrayLayer
            {
                glInstance.CreateFramebuffers(n, framebuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CreateFramebuffers(this GL.ARBExtension glInstance, int n, ref FramebufferHandle framebuffers)
        {
            fixed (FramebufferHandle* framebuffers_ptr = &framebuffers) // RefInsteadOfPointerLayer
            {
                glInstance.CreateFramebuffers(n, framebuffers_ptr);
            }
        }

        // NamedFramebufferDrawBuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void NamedFramebufferDrawBuffers(this GL.ARBExtension glInstance, FramebufferHandle framebuffer, int n, in ColorBuffer bufs)
        {
            fixed (ColorBuffer* bufs_ptr = &bufs) // RefInsteadOfPointerLayer
            {
                glInstance.NamedFramebufferDrawBuffers(framebuffer, n, bufs_ptr);
            }
        }

        // InvalidateNamedFramebufferData overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void InvalidateNamedFramebufferData(this GL.ARBExtension glInstance, FramebufferHandle framebuffer, int numAttachments, in FramebufferAttachment attachments)
        {
            fixed (FramebufferAttachment* attachments_ptr = &attachments) // RefInsteadOfPointerLayer
            {
                glInstance.InvalidateNamedFramebufferData(framebuffer, numAttachments, attachments_ptr);
            }
        }

        // InvalidateNamedFramebufferSubData overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void InvalidateNamedFramebufferSubData(this GL.ARBExtension glInstance, FramebufferHandle framebuffer, int numAttachments, in FramebufferAttachment attachments, int x, int y, int width, int height)
        {
            fixed (FramebufferAttachment* attachments_ptr = &attachments) // RefInsteadOfPointerLayer
            {
                glInstance.InvalidateNamedFramebufferSubData(framebuffer, numAttachments, attachments_ptr, x, y, width, height);
            }
        }

        // ClearNamedFramebufferiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClearNamedFramebufferi(this GL.ARBExtension glInstance, FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, value_ptr);
            }
        }

        // ClearNamedFramebufferuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClearNamedFramebufferui(this GL.ARBExtension glInstance, FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, value_ptr);
            }
        }

        // ClearNamedFramebufferfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClearNamedFramebufferf(this GL.ARBExtension glInstance, FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, value_ptr);
            }
        }

        // ClearNamedFramebufferfi overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void ClearNamedFramebuffer(this GL.ARBExtension glInstance, FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, float depth, int stencil) =>
            glInstance.ClearNamedFramebufferfi(framebuffer, buffer, drawbuffer, depth, stencil);

        // GetNamedFramebufferParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetNamedFramebufferParameteri(this GL.ARBExtension glInstance, FramebufferHandle framebuffer, GetFramebufferParameter pname, ref int param)
        {
            fixed (int* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.GetNamedFramebufferParameteriv(framebuffer, pname, param_ptr);
            }
        }

        // GetNamedFramebufferAttachmentParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetNamedFramebufferAttachmentParameteri(this GL.ARBExtension glInstance, FramebufferHandle framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, parameters_ptr);
            }
        }

        // CreateRenderbuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe RenderbufferHandle CreateRenderbuffer(this GL.ARBExtension glInstance)
        {
            RenderbufferHandle renderbuffers;
            int n = 1;
            Unsafe.SkipInit(out renderbuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            RenderbufferHandle* renderbuffers_handle = (RenderbufferHandle*)Unsafe.AsPointer(ref renderbuffers);
            glInstance.CreateRenderbuffers(n, renderbuffers_handle);
            return renderbuffers;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void CreateRenderbuffer(this GL.ARBExtension glInstance, out RenderbufferHandle renderbuffers)
        {
            int n = 1;
            Unsafe.SkipInit(out renderbuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            RenderbufferHandle* renderbuffers_handle = (RenderbufferHandle*)Unsafe.AsPointer(ref renderbuffers);
            glInstance.CreateRenderbuffers(n, renderbuffers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateRenderbuffers(this GL.ARBExtension glInstance, Span<RenderbufferHandle> renderbuffers)
        {
            var n = (int)(renderbuffers.Length);
            fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers) // SpanOrArrayLayer
            {
                glInstance.CreateRenderbuffers(n, renderbuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateRenderbuffers(this GL.ARBExtension glInstance, RenderbufferHandle[] renderbuffers)
        {
            var n = (int)(renderbuffers.Length);
            fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers) // SpanOrArrayLayer
            {
                glInstance.CreateRenderbuffers(n, renderbuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CreateRenderbuffers(this GL.ARBExtension glInstance, int n, ref RenderbufferHandle renderbuffers)
        {
            fixed (RenderbufferHandle* renderbuffers_ptr = &renderbuffers) // RefInsteadOfPointerLayer
            {
                glInstance.CreateRenderbuffers(n, renderbuffers_ptr);
            }
        }

        // GetNamedRenderbufferParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetNamedRenderbufferParameteri(this GL.ARBExtension glInstance, RenderbufferHandle renderbuffer, RenderbufferParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetNamedRenderbufferParameteriv(renderbuffer, pname, parameters_ptr);
            }
        }

        // CreateTextures overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe TextureHandle CreateTexture(this GL.ARBExtension glInstance, TextureTarget target)
        {
            TextureHandle textures;
            int n = 1;
            Unsafe.SkipInit(out textures);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TextureHandle* textures_handle = (TextureHandle*)Unsafe.AsPointer(ref textures);
            glInstance.CreateTextures(target, n, textures_handle);
            return textures;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void CreateTexture(this GL.ARBExtension glInstance, TextureTarget target, out TextureHandle textures)
        {
            int n = 1;
            Unsafe.SkipInit(out textures);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TextureHandle* textures_handle = (TextureHandle*)Unsafe.AsPointer(ref textures);
            glInstance.CreateTextures(target, n, textures_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateTextures(this GL.ARBExtension glInstance, TextureTarget target, Span<TextureHandle> textures)
        {
            var n = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures) // SpanOrArrayLayer
            {
                glInstance.CreateTextures(target, n, textures_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateTextures(this GL.ARBExtension glInstance, TextureTarget target, TextureHandle[] textures)
        {
            var n = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures) // SpanOrArrayLayer
            {
                glInstance.CreateTextures(target, n, textures_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CreateTextures(this GL.ARBExtension glInstance, TextureTarget target, int n, ref TextureHandle textures)
        {
            fixed (TextureHandle* textures_ptr = &textures) // RefInsteadOfPointerLayer
            {
                glInstance.CreateTextures(target, n, textures_ptr);
            }
        }

        // TextureStorage2DMultisample overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void TextureStorage2DMultisample(this GL.ARBExtension glInstance, TextureHandle texture, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations)
        {
            var fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
            glInstance.TextureStorage2DMultisample(texture, samples, internalformat, width, height, fixedsamplelocations_byte);
        }

        // TextureStorage3DMultisample overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void TextureStorage3DMultisample(this GL.ARBExtension glInstance, TextureHandle texture, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
        {
            var fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
            glInstance.TextureStorage3DMultisample(texture, samples, internalformat, width, height, depth, fixedsamplelocations_byte);
        }

        // TextureSubImage1D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void TextureSubImage1D(this GL.ARBExtension glInstance, TextureHandle texture, int level, int xoffset, int width, PixelFormat format, PixelType type, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.TextureSubImage1D(texture, level, xoffset, width, format, type, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TextureSubImage1D<T1>(this GL.ARBExtension glInstance, TextureHandle texture, int level, int xoffset, int width, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.TextureSubImage1D(texture, level, xoffset, width, format, type, pixels_ptr);
            }
        }

        // TextureSubImage2D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void TextureSubImage2D(this GL.ARBExtension glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.TextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, type, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TextureSubImage2D<T1>(this GL.ARBExtension glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.TextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
            }
        }

        // TextureSubImage3D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void TextureSubImage3D(this GL.ARBExtension glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.TextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TextureSubImage3D<T1>(this GL.ARBExtension glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.TextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_ptr);
            }
        }

        // CompressedTextureSubImage1D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void CompressedTextureSubImage1D(this GL.ARBExtension glInstance, TextureHandle texture, int level, int xoffset, int width, InternalFormat format, int imageSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.CompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CompressedTextureSubImage1D<T1>(this GL.ARBExtension glInstance, TextureHandle texture, int level, int xoffset, int width, InternalFormat format, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.CompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, data_ptr);
            }
        }

        // CompressedTextureSubImage2D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void CompressedTextureSubImage2D(this GL.ARBExtension glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.CompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CompressedTextureSubImage2D<T1>(this GL.ARBExtension glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.CompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, data_ptr);
            }
        }

        // CompressedTextureSubImage3D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void CompressedTextureSubImage3D(this GL.ARBExtension glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.CompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CompressedTextureSubImage3D<T1>(this GL.ARBExtension glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.CompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_ptr);
            }
        }

        // TextureParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TextureParameterf(this GL.ARBExtension glInstance, TextureHandle texture, TextureParameterName pname, in float param)
        {
            fixed (float* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.TextureParameterfv(texture, pname, param_ptr);
            }
        }

        // TextureParameterIiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TextureParameterIi(this GL.ARBExtension glInstance, TextureHandle texture, TextureParameterName pname, in int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.TextureParameterIiv(texture, pname, parameters_ptr);
            }
        }

        // TextureParameterIuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TextureParameterIui(this GL.ARBExtension glInstance, TextureHandle texture, TextureParameterName pname, in uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.TextureParameterIuiv(texture, pname, parameters_ptr);
            }
        }

        // TextureParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TextureParameteri(this GL.ARBExtension glInstance, TextureHandle texture, TextureParameterName pname, in int param)
        {
            fixed (int* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.TextureParameteriv(texture, pname, param_ptr);
            }
        }

        // GetTextureImage overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetTextureImage(this GL.ARBExtension glInstance, TextureHandle texture, int level, PixelFormat format, PixelType type, int bufSize, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.GetTextureImage(texture, level, format, type, bufSize, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTextureImage<T1>(this GL.ARBExtension glInstance, TextureHandle texture, int level, PixelFormat format, PixelType type, int bufSize, ref T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.GetTextureImage(texture, level, format, type, bufSize, pixels_ptr);
            }
        }

        // GetCompressedTextureImage overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetCompressedTextureImage(this GL.ARBExtension glInstance, TextureHandle texture, int level, int bufSize, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.GetCompressedTextureImage(texture, level, bufSize, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetCompressedTextureImage<T1>(this GL.ARBExtension glInstance, TextureHandle texture, int level, int bufSize, ref T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.GetCompressedTextureImage(texture, level, bufSize, pixels_ptr);
            }
        }

        // GetTextureLevelParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTextureLevelParameterf(this GL.ARBExtension glInstance, TextureHandle texture, int level, GetTextureParameter pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTextureLevelParameterfv(texture, level, pname, parameters_ptr);
            }
        }

        // GetTextureLevelParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTextureLevelParameteri(this GL.ARBExtension glInstance, TextureHandle texture, int level, GetTextureParameter pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTextureLevelParameteriv(texture, level, pname, parameters_ptr);
            }
        }

        // GetTextureParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTextureParameterf(this GL.ARBExtension glInstance, TextureHandle texture, GetTextureParameter pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTextureParameterfv(texture, pname, parameters_ptr);
            }
        }

        // GetTextureParameterIiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTextureParameterIi(this GL.ARBExtension glInstance, TextureHandle texture, GetTextureParameter pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTextureParameterIiv(texture, pname, parameters_ptr);
            }
        }

        // GetTextureParameterIuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTextureParameterIui(this GL.ARBExtension glInstance, TextureHandle texture, GetTextureParameter pname, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTextureParameterIuiv(texture, pname, parameters_ptr);
            }
        }

        // GetTextureParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTextureParameteri(this GL.ARBExtension glInstance, TextureHandle texture, GetTextureParameter pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTextureParameteriv(texture, pname, parameters_ptr);
            }
        }

        // CreateVertexArrays overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe VertexArrayHandle CreateVertexArray(this GL.ARBExtension glInstance)
        {
            VertexArrayHandle arrays;
            int n = 1;
            Unsafe.SkipInit(out arrays);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            VertexArrayHandle* arrays_handle = (VertexArrayHandle*)Unsafe.AsPointer(ref arrays);
            glInstance.CreateVertexArrays(n, arrays_handle);
            return arrays;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void CreateVertexArray(this GL.ARBExtension glInstance, out VertexArrayHandle arrays)
        {
            int n = 1;
            Unsafe.SkipInit(out arrays);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            VertexArrayHandle* arrays_handle = (VertexArrayHandle*)Unsafe.AsPointer(ref arrays);
            glInstance.CreateVertexArrays(n, arrays_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateVertexArrays(this GL.ARBExtension glInstance, Span<VertexArrayHandle> arrays)
        {
            var n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays) // SpanOrArrayLayer
            {
                glInstance.CreateVertexArrays(n, arrays_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateVertexArrays(this GL.ARBExtension glInstance, VertexArrayHandle[] arrays)
        {
            var n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays) // SpanOrArrayLayer
            {
                glInstance.CreateVertexArrays(n, arrays_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CreateVertexArrays(this GL.ARBExtension glInstance, int n, ref VertexArrayHandle arrays)
        {
            fixed (VertexArrayHandle* arrays_ptr = &arrays) // RefInsteadOfPointerLayer
            {
                glInstance.CreateVertexArrays(n, arrays_ptr);
            }
        }

        // VertexArrayVertexBuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexArrayVertexBuffers(this GL.ARBExtension glInstance, VertexArrayHandle vaobj, uint first, int count, in BufferHandle buffers, in IntPtr offsets, in int strides)
        {
            fixed (BufferHandle* buffers_ptr = &buffers) // RefInsteadOfPointerLayer
            fixed (IntPtr* offsets_ptr = &offsets) // RefInsteadOfPointerLayer
            fixed (int* strides_ptr = &strides) // RefInsteadOfPointerLayer
            {
                glInstance.VertexArrayVertexBuffers(vaobj, first, count, buffers_ptr, offsets_ptr, strides_ptr);
            }
        }

        // VertexArrayAttribFormat overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void VertexArrayAttribFormat(this GL.ARBExtension glInstance, VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset)
        {
            var normalized_byte = (byte)(normalized ? 1 : 0);
            glInstance.VertexArrayAttribFormat(vaobj, attribindex, size, type, normalized_byte, relativeoffset);
        }

        // GetVertexArrayiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetVertexArrayi(this GL.ARBExtension glInstance, VertexArrayHandle vaobj, VertexArrayPName pname, ref int param)
        {
            fixed (int* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.GetVertexArrayiv(vaobj, pname, param_ptr);
            }
        }

        // GetVertexArrayIndexediv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetVertexArrayIndexedi(this GL.ARBExtension glInstance, VertexArrayHandle vaobj, uint index, VertexArrayPName pname, ref int param)
        {
            fixed (int* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.GetVertexArrayIndexediv(vaobj, index, pname, param_ptr);
            }
        }

        // GetVertexArrayIndexed64iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetVertexArrayIndexed64iv(this GL.ARBExtension glInstance, VertexArrayHandle vaobj, uint index, VertexArrayPName pname, ref long param)
        {
            fixed (long* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.GetVertexArrayIndexed64iv(vaobj, index, pname, param_ptr);
            }
        }

        // CreateSamplers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe SamplerHandle CreateSampler(this GL.ARBExtension glInstance)
        {
            SamplerHandle samplers;
            int n = 1;
            Unsafe.SkipInit(out samplers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            SamplerHandle* samplers_handle = (SamplerHandle*)Unsafe.AsPointer(ref samplers);
            glInstance.CreateSamplers(n, samplers_handle);
            return samplers;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void CreateSampler(this GL.ARBExtension glInstance, out SamplerHandle samplers)
        {
            int n = 1;
            Unsafe.SkipInit(out samplers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            SamplerHandle* samplers_handle = (SamplerHandle*)Unsafe.AsPointer(ref samplers);
            glInstance.CreateSamplers(n, samplers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateSamplers(this GL.ARBExtension glInstance, Span<SamplerHandle> samplers)
        {
            var n = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers) // SpanOrArrayLayer
            {
                glInstance.CreateSamplers(n, samplers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateSamplers(this GL.ARBExtension glInstance, SamplerHandle[] samplers)
        {
            var n = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers) // SpanOrArrayLayer
            {
                glInstance.CreateSamplers(n, samplers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CreateSamplers(this GL.ARBExtension glInstance, int n, ref SamplerHandle samplers)
        {
            fixed (SamplerHandle* samplers_ptr = &samplers) // RefInsteadOfPointerLayer
            {
                glInstance.CreateSamplers(n, samplers_ptr);
            }
        }

        // CreateProgramPipelines overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe ProgramPipelineHandle CreateProgramPipeline(this GL.ARBExtension glInstance)
        {
            ProgramPipelineHandle pipelines;
            int n = 1;
            Unsafe.SkipInit(out pipelines);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            ProgramPipelineHandle* pipelines_handle = (ProgramPipelineHandle*)Unsafe.AsPointer(ref pipelines);
            glInstance.CreateProgramPipelines(n, pipelines_handle);
            return pipelines;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void CreateProgramPipeline(this GL.ARBExtension glInstance, out ProgramPipelineHandle pipelines)
        {
            int n = 1;
            Unsafe.SkipInit(out pipelines);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            ProgramPipelineHandle* pipelines_handle = (ProgramPipelineHandle*)Unsafe.AsPointer(ref pipelines);
            glInstance.CreateProgramPipelines(n, pipelines_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateProgramPipelines(this GL.ARBExtension glInstance, Span<ProgramPipelineHandle> pipelines)
        {
            var n = (int)(pipelines.Length);
            fixed (ProgramPipelineHandle* pipelines_ptr = pipelines) // SpanOrArrayLayer
            {
                glInstance.CreateProgramPipelines(n, pipelines_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateProgramPipelines(this GL.ARBExtension glInstance, ProgramPipelineHandle[] pipelines)
        {
            var n = (int)(pipelines.Length);
            fixed (ProgramPipelineHandle* pipelines_ptr = pipelines) // SpanOrArrayLayer
            {
                glInstance.CreateProgramPipelines(n, pipelines_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CreateProgramPipelines(this GL.ARBExtension glInstance, int n, ref ProgramPipelineHandle pipelines)
        {
            fixed (ProgramPipelineHandle* pipelines_ptr = &pipelines) // RefInsteadOfPointerLayer
            {
                glInstance.CreateProgramPipelines(n, pipelines_ptr);
            }
        }

        // CreateQueries overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe QueryHandle CreateQuerie(this GL.ARBExtension glInstance, QueryTarget target)
        {
            QueryHandle ids;
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            QueryHandle* ids_handle = (QueryHandle*)Unsafe.AsPointer(ref ids);
            glInstance.CreateQueries(target, n, ids_handle);
            return ids;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void CreateQuerie(this GL.ARBExtension glInstance, QueryTarget target, out QueryHandle ids)
        {
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            QueryHandle* ids_handle = (QueryHandle*)Unsafe.AsPointer(ref ids);
            glInstance.CreateQueries(target, n, ids_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateQueries(this GL.ARBExtension glInstance, QueryTarget target, Span<QueryHandle> ids)
        {
            var n = (int)(ids.Length);
            fixed (QueryHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.CreateQueries(target, n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateQueries(this GL.ARBExtension glInstance, QueryTarget target, QueryHandle[] ids)
        {
            var n = (int)(ids.Length);
            fixed (QueryHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.CreateQueries(target, n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CreateQueries(this GL.ARBExtension glInstance, QueryTarget target, int n, ref QueryHandle ids)
        {
            fixed (QueryHandle* ids_ptr = &ids) // RefInsteadOfPointerLayer
            {
                glInstance.CreateQueries(target, n, ids_ptr);
            }
        }

        // GetQueryBufferObjecti64v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void GetQueryBufferObjecti64(this GL.ARBExtension glInstance, QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset) =>
            glInstance.GetQueryBufferObjecti64v(id, buffer, pname, offset);

        // GetQueryBufferObjectiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void GetQueryBufferObjecti(this GL.ARBExtension glInstance, QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset) =>
            glInstance.GetQueryBufferObjectiv(id, buffer, pname, offset);

        // GetQueryBufferObjectui64v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void GetQueryBufferObjectui64(this GL.ARBExtension glInstance, QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset) =>
            glInstance.GetQueryBufferObjectui64v(id, buffer, pname, offset);

        // GetQueryBufferObjectuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void GetQueryBufferObjectui(this GL.ARBExtension glInstance, QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset) =>
            glInstance.GetQueryBufferObjectuiv(id, buffer, pname, offset);

        // DrawBuffersARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DrawBuffersARB(this GL.ARBExtension glInstance, ReadOnlySpan<DrawBufferMode> bufs)
        {
            var n = (int)(bufs.Length);
            fixed (DrawBufferMode* bufs_ptr = bufs) // SpanOrArrayLayer
            {
                glInstance.DrawBuffersARB(n, bufs_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DrawBuffersARB(this GL.ARBExtension glInstance, DrawBufferMode[] bufs)
        {
            var n = (int)(bufs.Length);
            fixed (DrawBufferMode* bufs_ptr = bufs) // SpanOrArrayLayer
            {
                glInstance.DrawBuffersARB(n, bufs_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DrawBuffersARB(this GL.ARBExtension glInstance, int n, in DrawBufferMode bufs)
        {
            fixed (DrawBufferMode* bufs_ptr = &bufs) // RefInsteadOfPointerLayer
            {
                glInstance.DrawBuffersARB(n, bufs_ptr);
            }
        }

        // DrawElementsBaseVertex overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void DrawElementsBaseVertex(this GL.ARBExtension glInstance, PrimitiveType mode, int count, DrawElementsType type, nint offset, int basevertex)
        {
            void* indices = (void*)offset;
            glInstance.DrawElementsBaseVertex(mode, count, type, indices, basevertex);
        }

        // DrawRangeElementsBaseVertex overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void DrawRangeElementsBaseVertex(this GL.ARBExtension glInstance, PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, nint offset, int basevertex)
        {
            void* indices = (void*)offset;
            glInstance.DrawRangeElementsBaseVertex(mode, start, end, count, type, indices, basevertex);
        }

        // DrawElementsInstancedBaseVertex overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void DrawElementsInstancedBaseVertex(this GL.ARBExtension glInstance, PrimitiveType mode, int count, DrawElementsType type, nint offset, int instancecount, int basevertex)
        {
            void* indices = (void*)offset;
            glInstance.DrawElementsInstancedBaseVertex(mode, count, type, indices, instancecount, basevertex);
        }

        // MultiDrawElementsBaseVertex overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiDrawElementsBaseVertex(this GL.ARBExtension glInstance, PrimitiveType mode, ReadOnlySpan<int> count, DrawElementsType type, void** indices, int drawcount, ReadOnlySpan<int> basevertex)
        {
            fixed (int* count_ptr = count) // SpanOrArrayLayer
            {
                fixed (int* basevertex_ptr = basevertex) // SpanOrArrayLayer
                {
                    glInstance.MultiDrawElementsBaseVertex(mode, count_ptr, type, indices, drawcount, basevertex_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiDrawElementsBaseVertex(this GL.ARBExtension glInstance, PrimitiveType mode, int[] count, DrawElementsType type, void** indices, int drawcount, int[] basevertex)
        {
            fixed (int* count_ptr = count) // SpanOrArrayLayer
            {
                fixed (int* basevertex_ptr = basevertex) // SpanOrArrayLayer
                {
                    glInstance.MultiDrawElementsBaseVertex(mode, count_ptr, type, indices, drawcount, basevertex_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiDrawElementsBaseVertex(this GL.ARBExtension glInstance, PrimitiveType mode, in int count, DrawElementsType type, void** indices, int drawcount, in int basevertex)
        {
            fixed (int* count_ptr = &count) // RefInsteadOfPointerLayer
            fixed (int* basevertex_ptr = &basevertex) // RefInsteadOfPointerLayer
            {
                glInstance.MultiDrawElementsBaseVertex(mode, count_ptr, type, indices, drawcount, basevertex_ptr);
            }
        }

        // DrawArraysIndirect overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void DrawArraysIndirect(this GL.ARBExtension glInstance, PrimitiveType mode, IntPtr indirect)
        {
            var indirect_vptr = (void*)indirect;
            glInstance.DrawArraysIndirect(mode, indirect_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DrawArraysIndirect<T1>(this GL.ARBExtension glInstance, PrimitiveType mode, in T1 indirect)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = &indirect) // RefInsteadOfPointerLayer
            {
                glInstance.DrawArraysIndirect(mode, indirect_ptr);
            }
        }

        // DrawElementsIndirect overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void DrawElementsIndirect(this GL.ARBExtension glInstance, PrimitiveType mode, DrawElementsType type, IntPtr indirect)
        {
            var indirect_vptr = (void*)indirect;
            glInstance.DrawElementsIndirect(mode, type, indirect_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DrawElementsIndirect<T1>(this GL.ARBExtension glInstance, PrimitiveType mode, DrawElementsType type, in T1 indirect)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = &indirect) // RefInsteadOfPointerLayer
            {
                glInstance.DrawElementsIndirect(mode, type, indirect_ptr);
            }
        }

        // DrawElementsInstancedARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void DrawElementsInstancedARB(this GL.ARBExtension glInstance, PrimitiveType mode, int count, DrawElementsType type, nint offset, int primcount)
        {
            void* indices = (void*)offset;
            glInstance.DrawElementsInstancedARB(mode, count, type, indices, primcount);
        }

        // ProgramStringARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ProgramStringARB(this GL.ARBExtension glInstance, ProgramTarget target, ProgramFormat format, int len, IntPtr str)
        {
            var str_vptr = (void*)str;
            glInstance.ProgramStringARB(target, format, len, str_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramStringARB<T1>(this GL.ARBExtension glInstance, ProgramTarget target, ProgramFormat format, ReadOnlySpan<T1> str)
            where T1 : unmanaged
        {
            var len = (int)(str.Length * sizeof(T1));
            fixed (void* str_ptr = str) // SpanOrArrayLayer
            {
                glInstance.ProgramStringARB(target, format, len, str_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramStringARB<T1>(this GL.ARBExtension glInstance, ProgramTarget target, ProgramFormat format, T1[] str)
            where T1 : unmanaged
        {
            var len = (int)(str.Length * sizeof(T1));
            fixed (void* str_ptr = str) // SpanOrArrayLayer
            {
                glInstance.ProgramStringARB(target, format, len, str_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramStringARB<T1>(this GL.ARBExtension glInstance, ProgramTarget target, ProgramFormat format, int len, in T1 str)
            where T1 : unmanaged
        {
            fixed (void* str_ptr = &str) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramStringARB(target, format, len, str_ptr);
            }
        }

        // DeleteProgramsARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteProgramsARB(this GL.ARBExtension glInstance, ReadOnlySpan<ProgramHandle> programs)
        {
            var n = (int)(programs.Length);
            fixed (ProgramHandle* programs_ptr = programs) // SpanOrArrayLayer
            {
                glInstance.DeleteProgramsARB(n, programs_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteProgramsARB(this GL.ARBExtension glInstance, ProgramHandle[] programs)
        {
            var n = (int)(programs.Length);
            fixed (ProgramHandle* programs_ptr = programs) // SpanOrArrayLayer
            {
                glInstance.DeleteProgramsARB(n, programs_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteProgramsARB(this GL.ARBExtension glInstance, int n, in ProgramHandle programs)
        {
            fixed (ProgramHandle* programs_ptr = &programs) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteProgramsARB(n, programs_ptr);
            }
        }

        // GenProgramsARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenProgramsARB(this GL.ARBExtension glInstance, Span<ProgramHandle> programs)
        {
            var n = (int)(programs.Length);
            fixed (ProgramHandle* programs_ptr = programs) // SpanOrArrayLayer
            {
                glInstance.GenProgramsARB(n, programs_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenProgramsARB(this GL.ARBExtension glInstance, ProgramHandle[] programs)
        {
            var n = (int)(programs.Length);
            fixed (ProgramHandle* programs_ptr = programs) // SpanOrArrayLayer
            {
                glInstance.GenProgramsARB(n, programs_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenProgramsARB(this GL.ARBExtension glInstance, int n, ref ProgramHandle programs)
        {
            fixed (ProgramHandle* programs_ptr = &programs) // RefInsteadOfPointerLayer
            {
                glInstance.GenProgramsARB(n, programs_ptr);
            }
        }

        // ProgramEnvParameter4dvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramEnvParameter4dvARB(this GL.ARBExtension glInstance, ProgramTarget target, uint index, ReadOnlySpan<double> parameters)
        {
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.ProgramEnvParameter4dvARB(target, index, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramEnvParameter4dvARB(this GL.ARBExtension glInstance, ProgramTarget target, uint index, double[] parameters)
        {
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.ProgramEnvParameter4dvARB(target, index, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramEnvParameter4dvARB(this GL.ARBExtension glInstance, ProgramTarget target, uint index, in double parameters)
        {
            fixed (double* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramEnvParameter4dvARB(target, index, parameters_ptr);
            }
        }

        // ProgramEnvParameter4fvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramEnvParameter4fvARB(this GL.ARBExtension glInstance, ProgramTarget target, uint index, ReadOnlySpan<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.ProgramEnvParameter4fvARB(target, index, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramEnvParameter4fvARB(this GL.ARBExtension glInstance, ProgramTarget target, uint index, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.ProgramEnvParameter4fvARB(target, index, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramEnvParameter4fvARB(this GL.ARBExtension glInstance, ProgramTarget target, uint index, in float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramEnvParameter4fvARB(target, index, parameters_ptr);
            }
        }

        // ProgramLocalParameter4dvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramLocalParameter4dvARB(this GL.ARBExtension glInstance, ProgramTarget target, uint index, ReadOnlySpan<double> parameters)
        {
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.ProgramLocalParameter4dvARB(target, index, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramLocalParameter4dvARB(this GL.ARBExtension glInstance, ProgramTarget target, uint index, double[] parameters)
        {
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.ProgramLocalParameter4dvARB(target, index, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramLocalParameter4dvARB(this GL.ARBExtension glInstance, ProgramTarget target, uint index, in double parameters)
        {
            fixed (double* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramLocalParameter4dvARB(target, index, parameters_ptr);
            }
        }

        // ProgramLocalParameter4fvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramLocalParameter4fvARB(this GL.ARBExtension glInstance, ProgramTarget target, uint index, ReadOnlySpan<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.ProgramLocalParameter4fvARB(target, index, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramLocalParameter4fvARB(this GL.ARBExtension glInstance, ProgramTarget target, uint index, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.ProgramLocalParameter4fvARB(target, index, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramLocalParameter4fvARB(this GL.ARBExtension glInstance, ProgramTarget target, uint index, in float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramLocalParameter4fvARB(target, index, parameters_ptr);
            }
        }

        // GetProgramEnvParameterdvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramEnvParameterdvARB(this GL.ARBExtension glInstance, ProgramTarget target, uint index, Span<double> parameters)
        {
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramEnvParameterdvARB(target, index, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramEnvParameterdvARB(this GL.ARBExtension glInstance, ProgramTarget target, uint index, double[] parameters)
        {
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramEnvParameterdvARB(target, index, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramEnvParameterdvARB(this GL.ARBExtension glInstance, ProgramTarget target, uint index, ref double parameters)
        {
            fixed (double* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetProgramEnvParameterdvARB(target, index, parameters_ptr);
            }
        }

        // GetProgramEnvParameterfvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramEnvParameterfvARB(this GL.ARBExtension glInstance, ProgramTarget target, uint index, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramEnvParameterfvARB(target, index, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramEnvParameterfvARB(this GL.ARBExtension glInstance, ProgramTarget target, uint index, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramEnvParameterfvARB(target, index, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramEnvParameterfvARB(this GL.ARBExtension glInstance, ProgramTarget target, uint index, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetProgramEnvParameterfvARB(target, index, parameters_ptr);
            }
        }

        // GetProgramLocalParameterdvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramLocalParameterdvARB(this GL.ARBExtension glInstance, ProgramTarget target, uint index, Span<double> parameters)
        {
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramLocalParameterdvARB(target, index, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramLocalParameterdvARB(this GL.ARBExtension glInstance, ProgramTarget target, uint index, double[] parameters)
        {
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramLocalParameterdvARB(target, index, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramLocalParameterdvARB(this GL.ARBExtension glInstance, ProgramTarget target, uint index, ref double parameters)
        {
            fixed (double* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetProgramLocalParameterdvARB(target, index, parameters_ptr);
            }
        }

        // GetProgramLocalParameterfvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramLocalParameterfvARB(this GL.ARBExtension glInstance, ProgramTarget target, uint index, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramLocalParameterfvARB(target, index, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramLocalParameterfvARB(this GL.ARBExtension glInstance, ProgramTarget target, uint index, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramLocalParameterfvARB(target, index, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramLocalParameterfvARB(this GL.ARBExtension glInstance, ProgramTarget target, uint index, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetProgramLocalParameterfvARB(target, index, parameters_ptr);
            }
        }

        // GetProgramivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramivARB(this GL.ARBExtension glInstance, ProgramTarget target, ProgramPropertyARB pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramivARB(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramivARB(this GL.ARBExtension glInstance, ProgramTarget target, ProgramPropertyARB pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramivARB(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramivARB(this GL.ARBExtension glInstance, ProgramTarget target, ProgramPropertyARB pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetProgramivARB(target, pname, parameters_ptr);
            }
        }

        // GetProgramStringARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetProgramStringARB(this GL.ARBExtension glInstance, ProgramTarget target, ProgramStringProperty pname, IntPtr str)
        {
            var str_vptr = (void*)str;
            glInstance.GetProgramStringARB(target, pname, str_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramStringARB<T1>(this GL.ARBExtension glInstance, ProgramTarget target, ProgramStringProperty pname, Span<T1> str)
            where T1 : unmanaged
        {
            fixed (void* str_ptr = str) // SpanOrArrayLayer
            {
                glInstance.GetProgramStringARB(target, pname, str_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramStringARB<T1>(this GL.ARBExtension glInstance, ProgramTarget target, ProgramStringProperty pname, T1[] str)
            where T1 : unmanaged
        {
            fixed (void* str_ptr = str) // SpanOrArrayLayer
            {
                glInstance.GetProgramStringARB(target, pname, str_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramStringARB<T1>(this GL.ARBExtension glInstance, ProgramTarget target, ProgramStringProperty pname, ref T1 str)
            where T1 : unmanaged
        {
            fixed (void* str_ptr = &str) // RefInsteadOfPointerLayer
            {
                glInstance.GetProgramStringARB(target, pname, str_ptr);
            }
        }

        // GetFramebufferParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetFramebufferParameteri(this GL.ARBExtension glInstance, FramebufferTarget target, FramebufferAttachmentParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetFramebufferParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetFramebufferParameteri(this GL.ARBExtension glInstance, FramebufferTarget target, FramebufferAttachmentParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetFramebufferParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetFramebufferParameteri(this GL.ARBExtension glInstance, FramebufferTarget target, FramebufferAttachmentParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetFramebufferParameteriv(target, pname, parameters_ptr);
            }
        }

        // DeleteRenderbuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void DeleteRenderbuffer(this GL.ARBExtension glInstance, in RenderbufferHandle renderbuffers)
        {
            int n = 1;
            fixed(RenderbufferHandle* renderbuffers_handle = &renderbuffers) // DeleteOverloadLayer
                glInstance.DeleteRenderbuffers(n, renderbuffers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteRenderbuffers(this GL.ARBExtension glInstance, ReadOnlySpan<RenderbufferHandle> renderbuffers)
        {
            var n = (int)(renderbuffers.Length);
            fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers) // SpanOrArrayLayer
            {
                glInstance.DeleteRenderbuffers(n, renderbuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteRenderbuffers(this GL.ARBExtension glInstance, RenderbufferHandle[] renderbuffers)
        {
            var n = (int)(renderbuffers.Length);
            fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers) // SpanOrArrayLayer
            {
                glInstance.DeleteRenderbuffers(n, renderbuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteRenderbuffers(this GL.ARBExtension glInstance, int n, in RenderbufferHandle renderbuffers)
        {
            fixed (RenderbufferHandle* renderbuffers_ptr = &renderbuffers) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteRenderbuffers(n, renderbuffers_ptr);
            }
        }

        // GenRenderbuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe RenderbufferHandle GenRenderbuffer(this GL.ARBExtension glInstance)
        {
            RenderbufferHandle renderbuffers;
            int n = 1;
            Unsafe.SkipInit(out renderbuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            RenderbufferHandle* renderbuffers_handle = (RenderbufferHandle*)Unsafe.AsPointer(ref renderbuffers);
            glInstance.GenRenderbuffers(n, renderbuffers_handle);
            return renderbuffers;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void GenRenderbuffer(this GL.ARBExtension glInstance, out RenderbufferHandle renderbuffers)
        {
            int n = 1;
            Unsafe.SkipInit(out renderbuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            RenderbufferHandle* renderbuffers_handle = (RenderbufferHandle*)Unsafe.AsPointer(ref renderbuffers);
            glInstance.GenRenderbuffers(n, renderbuffers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenRenderbuffers(this GL.ARBExtension glInstance, Span<RenderbufferHandle> renderbuffers)
        {
            var n = (int)(renderbuffers.Length);
            fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers) // SpanOrArrayLayer
            {
                glInstance.GenRenderbuffers(n, renderbuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenRenderbuffers(this GL.ARBExtension glInstance, RenderbufferHandle[] renderbuffers)
        {
            var n = (int)(renderbuffers.Length);
            fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers) // SpanOrArrayLayer
            {
                glInstance.GenRenderbuffers(n, renderbuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenRenderbuffers(this GL.ARBExtension glInstance, int n, ref RenderbufferHandle renderbuffers)
        {
            fixed (RenderbufferHandle* renderbuffers_ptr = &renderbuffers) // RefInsteadOfPointerLayer
            {
                glInstance.GenRenderbuffers(n, renderbuffers_ptr);
            }
        }

        // GetRenderbufferParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetRenderbufferParameteri(this GL.ARBExtension glInstance, RenderbufferTarget target, RenderbufferParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetRenderbufferParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetRenderbufferParameteri(this GL.ARBExtension glInstance, RenderbufferTarget target, RenderbufferParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetRenderbufferParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetRenderbufferParameteri(this GL.ARBExtension glInstance, RenderbufferTarget target, RenderbufferParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetRenderbufferParameteriv(target, pname, parameters_ptr);
            }
        }

        // DeleteFramebuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void DeleteFramebuffer(this GL.ARBExtension glInstance, in FramebufferHandle framebuffers)
        {
            int n = 1;
            fixed(FramebufferHandle* framebuffers_handle = &framebuffers) // DeleteOverloadLayer
                glInstance.DeleteFramebuffers(n, framebuffers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteFramebuffers(this GL.ARBExtension glInstance, ReadOnlySpan<FramebufferHandle> framebuffers)
        {
            var n = (int)(framebuffers.Length);
            fixed (FramebufferHandle* framebuffers_ptr = framebuffers) // SpanOrArrayLayer
            {
                glInstance.DeleteFramebuffers(n, framebuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteFramebuffers(this GL.ARBExtension glInstance, FramebufferHandle[] framebuffers)
        {
            var n = (int)(framebuffers.Length);
            fixed (FramebufferHandle* framebuffers_ptr = framebuffers) // SpanOrArrayLayer
            {
                glInstance.DeleteFramebuffers(n, framebuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteFramebuffers(this GL.ARBExtension glInstance, int n, in FramebufferHandle framebuffers)
        {
            fixed (FramebufferHandle* framebuffers_ptr = &framebuffers) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteFramebuffers(n, framebuffers_ptr);
            }
        }

        // GenFramebuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe FramebufferHandle GenFramebuffer(this GL.ARBExtension glInstance)
        {
            FramebufferHandle framebuffers;
            int n = 1;
            Unsafe.SkipInit(out framebuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            FramebufferHandle* framebuffers_handle = (FramebufferHandle*)Unsafe.AsPointer(ref framebuffers);
            glInstance.GenFramebuffers(n, framebuffers_handle);
            return framebuffers;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void GenFramebuffer(this GL.ARBExtension glInstance, out FramebufferHandle framebuffers)
        {
            int n = 1;
            Unsafe.SkipInit(out framebuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            FramebufferHandle* framebuffers_handle = (FramebufferHandle*)Unsafe.AsPointer(ref framebuffers);
            glInstance.GenFramebuffers(n, framebuffers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenFramebuffers(this GL.ARBExtension glInstance, Span<FramebufferHandle> framebuffers)
        {
            var n = (int)(framebuffers.Length);
            fixed (FramebufferHandle* framebuffers_ptr = framebuffers) // SpanOrArrayLayer
            {
                glInstance.GenFramebuffers(n, framebuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenFramebuffers(this GL.ARBExtension glInstance, FramebufferHandle[] framebuffers)
        {
            var n = (int)(framebuffers.Length);
            fixed (FramebufferHandle* framebuffers_ptr = framebuffers) // SpanOrArrayLayer
            {
                glInstance.GenFramebuffers(n, framebuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenFramebuffers(this GL.ARBExtension glInstance, int n, ref FramebufferHandle framebuffers)
        {
            fixed (FramebufferHandle* framebuffers_ptr = &framebuffers) // RefInsteadOfPointerLayer
            {
                glInstance.GenFramebuffers(n, framebuffers_ptr);
            }
        }

        // GetFramebufferAttachmentParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetFramebufferAttachmentParameteri(this GL.ARBExtension glInstance, FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetFramebufferAttachmentParameteriv(target, attachment, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetFramebufferAttachmentParameteri(this GL.ARBExtension glInstance, FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetFramebufferAttachmentParameteriv(target, attachment, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetFramebufferAttachmentParameteri(this GL.ARBExtension glInstance, FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetFramebufferAttachmentParameteriv(target, attachment, pname, parameters_ptr);
            }
        }

        // GetProgramBinary overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramBinary(this GL.ARBExtension glInstance, ProgramHandle program, int bufSize, Span<int> length, Span<GLEnum> binaryFormat, IntPtr binary)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (GLEnum* binaryFormat_ptr = binaryFormat) // SpanOrArrayLayer
                {
                    var binary_vptr = (void*)binary;
                    glInstance.GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_vptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramBinary(this GL.ARBExtension glInstance, ProgramHandle program, int bufSize, int[] length, GLEnum[] binaryFormat, IntPtr binary)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (GLEnum* binaryFormat_ptr = binaryFormat) // SpanOrArrayLayer
                {
                    var binary_vptr = (void*)binary;
                    glInstance.GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_vptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramBinary(this GL.ARBExtension glInstance, ProgramHandle program, int bufSize, ref int length, ref GLEnum binaryFormat, IntPtr binary)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (GLEnum* binaryFormat_ptr = &binaryFormat) // RefInsteadOfPointerLayer
            {
                var binary_vptr = (void*)binary;
                glInstance.GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_vptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramBinary<T1>(this GL.ARBExtension glInstance, ProgramHandle program, Span<int> length, Span<GLEnum> binaryFormat, Span<T1> binary)
            where T1 : unmanaged
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (GLEnum* binaryFormat_ptr = binaryFormat) // SpanOrArrayLayer
                {
                    var bufSize = (int)(binary.Length * sizeof(T1));
                    fixed (void* binary_ptr = binary) // SpanOrArrayLayer
                    {
                        glInstance.GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramBinary<T1>(this GL.ARBExtension glInstance, ProgramHandle program, int[] length, GLEnum[] binaryFormat, T1[] binary)
            where T1 : unmanaged
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (GLEnum* binaryFormat_ptr = binaryFormat) // SpanOrArrayLayer
                {
                    var bufSize = (int)(binary.Length * sizeof(T1));
                    fixed (void* binary_ptr = binary) // SpanOrArrayLayer
                    {
                        glInstance.GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramBinary<T1>(this GL.ARBExtension glInstance, ProgramHandle program, int bufSize, ref int length, ref GLEnum binaryFormat, ref T1 binary)
            where T1 : unmanaged
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (GLEnum* binaryFormat_ptr = &binaryFormat) // RefInsteadOfPointerLayer
            fixed (void* binary_ptr = &binary) // RefInsteadOfPointerLayer
            {
                glInstance.GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_ptr);
            }
        }

        // ProgramBinary overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ProgramBinary(this GL.ARBExtension glInstance, ProgramHandle program, GLEnum binaryFormat, IntPtr binary, int length)
        {
            var binary_vptr = (void*)binary;
            glInstance.ProgramBinary(program, binaryFormat, binary_vptr, length);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramBinary<T1>(this GL.ARBExtension glInstance, ProgramHandle program, GLEnum binaryFormat, ReadOnlySpan<T1> binary)
            where T1 : unmanaged
        {
            var length = (int)(binary.Length * sizeof(T1));
            fixed (void* binary_ptr = binary) // SpanOrArrayLayer
            {
                glInstance.ProgramBinary(program, binaryFormat, binary_ptr, length);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramBinary<T1>(this GL.ARBExtension glInstance, ProgramHandle program, GLEnum binaryFormat, T1[] binary)
            where T1 : unmanaged
        {
            var length = (int)(binary.Length * sizeof(T1));
            fixed (void* binary_ptr = binary) // SpanOrArrayLayer
            {
                glInstance.ProgramBinary(program, binaryFormat, binary_ptr, length);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramBinary<T1>(this GL.ARBExtension glInstance, ProgramHandle program, GLEnum binaryFormat, in T1 binary, int length)
            where T1 : unmanaged
        {
            fixed (void* binary_ptr = &binary) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramBinary(program, binaryFormat, binary_ptr, length);
            }
        }

        // GetTextureSubImage overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetTextureSubImage(this GL.ARBExtension glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, int bufSize, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.GetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTextureSubImage<T1>(this GL.ARBExtension glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, int bufSize, ref T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.GetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels_ptr);
            }
        }

        // GetCompressedTextureSubImage overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetCompressedTextureSubImage(this GL.ARBExtension glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.GetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetCompressedTextureSubImage<T1>(this GL.ARBExtension glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, ref T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.GetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels_ptr);
            }
        }

        // SpecializeShaderARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SpecializeShaderARB(this GL.ARBExtension glInstance, ShaderHandle shader, string pEntryPoint, uint numSpecializationConstants, in uint pConstantIndex, in uint pConstantValue)
        {
            fixed (uint* pConstantIndex_ptr = &pConstantIndex) // RefInsteadOfPointerLayer
            fixed (uint* pConstantValue_ptr = &pConstantValue) // RefInsteadOfPointerLayer
            {
                byte* pEntryPoint_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(pEntryPoint);
                glInstance.SpecializeShaderARB(shader, pEntryPoint_ptr, numSpecializationConstants, pConstantIndex_ptr, pConstantValue_ptr);
                Marshal.FreeCoTaskMem((IntPtr)pEntryPoint_ptr);
            }
        }

        // Uniform1dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1dv(this GL.ARBExtension glInstance, int location, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 1);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1dv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1dv(this GL.ARBExtension glInstance, int location, double[] value)
        {
            var count = (int)(value.Length / 1);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1dv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform1dv(this GL.ARBExtension glInstance, int location, int count, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform1dv(location, count, value_ptr);
            }
        }

        // Uniform2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2dv(this GL.ARBExtension glInstance, int location, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 2);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2dv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2dv(this GL.ARBExtension glInstance, int location, double[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2dv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform2dv(this GL.ARBExtension glInstance, int location, int count, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform2dv(location, count, value_ptr);
            }
        }

        // Uniform3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3dv(this GL.ARBExtension glInstance, int location, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 3);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3dv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3dv(this GL.ARBExtension glInstance, int location, double[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3dv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform3dv(this GL.ARBExtension glInstance, int location, int count, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform3dv(location, count, value_ptr);
            }
        }

        // Uniform4dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4dv(this GL.ARBExtension glInstance, int location, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 4);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4dv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4dv(this GL.ARBExtension glInstance, int location, double[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4dv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform4dv(this GL.ARBExtension glInstance, int location, int count, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform4dv(location, count, value_ptr);
            }
        }

        // UniformMatrix2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2dv(this GL.ARBExtension glInstance, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 4);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2dv(this GL.ARBExtension glInstance, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix2dv(this GL.ARBExtension glInstance, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2dv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3dv(this GL.ARBExtension glInstance, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 9);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3dv(this GL.ARBExtension glInstance, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 9);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix3dv(this GL.ARBExtension glInstance, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3dv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix4dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4dv(this GL.ARBExtension glInstance, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 16);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4dv(this GL.ARBExtension glInstance, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 16);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix4dv(this GL.ARBExtension glInstance, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4dv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix2x3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2x3dv(this GL.ARBExtension glInstance, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 6);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x3dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2x3dv(this GL.ARBExtension glInstance, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 6);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x3dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix2x3dv(this GL.ARBExtension glInstance, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x3dv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix2x4dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2x4dv(this GL.ARBExtension glInstance, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 8);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x4dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2x4dv(this GL.ARBExtension glInstance, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 8);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x4dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix2x4dv(this GL.ARBExtension glInstance, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x4dv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix3x2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3x2dv(this GL.ARBExtension glInstance, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 6);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x2dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3x2dv(this GL.ARBExtension glInstance, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 6);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x2dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix3x2dv(this GL.ARBExtension glInstance, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x2dv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix3x4dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3x4dv(this GL.ARBExtension glInstance, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 12);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x4dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3x4dv(this GL.ARBExtension glInstance, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 12);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x4dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix3x4dv(this GL.ARBExtension glInstance, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x4dv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix4x2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4x2dv(this GL.ARBExtension glInstance, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 8);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x2dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4x2dv(this GL.ARBExtension glInstance, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 8);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x2dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix4x2dv(this GL.ARBExtension glInstance, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x2dv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix4x3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4x3dv(this GL.ARBExtension glInstance, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 12);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x3dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4x3dv(this GL.ARBExtension glInstance, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 12);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x3dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix4x3dv(this GL.ARBExtension glInstance, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x3dv(location, count, transpose_byte, value_ptr);
            }
        }

        // GetUniformdv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformd(this GL.ARBExtension glInstance, ProgramHandle program, int location, Span<double> parameters)
        {
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformdv(program, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformd(this GL.ARBExtension glInstance, ProgramHandle program, int location, double[] parameters)
        {
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformdv(program, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetUniformd(this GL.ARBExtension glInstance, ProgramHandle program, int location, ref double parameters)
        {
            fixed (double* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetUniformdv(program, location, parameters_ptr);
            }
        }

        // Uniform1i64vARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1i64vARB(this GL.ARBExtension glInstance, int location, ReadOnlySpan<long> value)
        {
            var count = (int)(value.Length / 1);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1i64vARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1i64vARB(this GL.ARBExtension glInstance, int location, long[] value)
        {
            var count = (int)(value.Length / 1);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1i64vARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform1i64vARB(this GL.ARBExtension glInstance, int location, int count, in long value)
        {
            fixed (long* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform1i64vARB(location, count, value_ptr);
            }
        }

        // Uniform2i64vARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2i64vARB(this GL.ARBExtension glInstance, int location, ReadOnlySpan<long> value)
        {
            var count = (int)(value.Length / 2);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2i64vARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2i64vARB(this GL.ARBExtension glInstance, int location, long[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2i64vARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform2i64vARB(this GL.ARBExtension glInstance, int location, int count, in long value)
        {
            fixed (long* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform2i64vARB(location, count, value_ptr);
            }
        }

        // Uniform3i64vARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3i64vARB(this GL.ARBExtension glInstance, int location, ReadOnlySpan<long> value)
        {
            var count = (int)(value.Length / 3);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3i64vARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3i64vARB(this GL.ARBExtension glInstance, int location, long[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3i64vARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform3i64vARB(this GL.ARBExtension glInstance, int location, int count, in long value)
        {
            fixed (long* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform3i64vARB(location, count, value_ptr);
            }
        }

        // Uniform4i64vARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4i64vARB(this GL.ARBExtension glInstance, int location, ReadOnlySpan<long> value)
        {
            var count = (int)(value.Length / 4);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4i64vARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4i64vARB(this GL.ARBExtension glInstance, int location, long[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4i64vARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform4i64vARB(this GL.ARBExtension glInstance, int location, int count, in long value)
        {
            fixed (long* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform4i64vARB(location, count, value_ptr);
            }
        }

        // Uniform1ui64vARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1ui64vARB(this GL.ARBExtension glInstance, int location, ReadOnlySpan<ulong> value)
        {
            var count = (int)(value.Length / 1);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1ui64vARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1ui64vARB(this GL.ARBExtension glInstance, int location, ulong[] value)
        {
            var count = (int)(value.Length / 1);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1ui64vARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform1ui64vARB(this GL.ARBExtension glInstance, int location, int count, in ulong value)
        {
            fixed (ulong* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform1ui64vARB(location, count, value_ptr);
            }
        }

        // Uniform2ui64vARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2ui64vARB(this GL.ARBExtension glInstance, int location, ReadOnlySpan<ulong> value)
        {
            var count = (int)(value.Length / 2);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2ui64vARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2ui64vARB(this GL.ARBExtension glInstance, int location, ulong[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2ui64vARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform2ui64vARB(this GL.ARBExtension glInstance, int location, int count, in ulong value)
        {
            fixed (ulong* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform2ui64vARB(location, count, value_ptr);
            }
        }

        // Uniform3ui64vARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3ui64vARB(this GL.ARBExtension glInstance, int location, ReadOnlySpan<ulong> value)
        {
            var count = (int)(value.Length / 3);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3ui64vARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3ui64vARB(this GL.ARBExtension glInstance, int location, ulong[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3ui64vARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform3ui64vARB(this GL.ARBExtension glInstance, int location, int count, in ulong value)
        {
            fixed (ulong* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform3ui64vARB(location, count, value_ptr);
            }
        }

        // Uniform4ui64vARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4ui64vARB(this GL.ARBExtension glInstance, int location, ReadOnlySpan<ulong> value)
        {
            var count = (int)(value.Length / 4);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4ui64vARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4ui64vARB(this GL.ARBExtension glInstance, int location, ulong[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4ui64vARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform4ui64vARB(this GL.ARBExtension glInstance, int location, int count, in ulong value)
        {
            fixed (ulong* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform4ui64vARB(location, count, value_ptr);
            }
        }

        // GetUniformi64vARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformi64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, Span<long> parameters)
        {
            fixed (long* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformi64vARB(program, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformi64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, long[] parameters)
        {
            fixed (long* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformi64vARB(program, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetUniformi64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, ref long parameters)
        {
            fixed (long* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetUniformi64vARB(program, location, parameters_ptr);
            }
        }

        // GetUniformui64vARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformui64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, Span<ulong> parameters)
        {
            fixed (ulong* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformui64vARB(program, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformui64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, ulong[] parameters)
        {
            fixed (ulong* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformui64vARB(program, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetUniformui64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, ref ulong parameters)
        {
            fixed (ulong* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetUniformui64vARB(program, location, parameters_ptr);
            }
        }

        // GetnUniformi64vARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformi64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, Span<long> parameters)
        {
            var bufSize = (int)(parameters.Length * 8);
            fixed (long* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformi64vARB(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformi64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, long[] parameters)
        {
            var bufSize = (int)(parameters.Length * 8);
            fixed (long* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformi64vARB(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnUniformi64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, int bufSize, ref long parameters)
        {
            fixed (long* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetnUniformi64vARB(program, location, bufSize, parameters_ptr);
            }
        }

        // GetnUniformui64vARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformui64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, Span<ulong> parameters)
        {
            var bufSize = (int)(parameters.Length * 8);
            fixed (ulong* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformui64vARB(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformui64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, ulong[] parameters)
        {
            var bufSize = (int)(parameters.Length * 8);
            fixed (ulong* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformui64vARB(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnUniformui64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, int bufSize, ref ulong parameters)
        {
            fixed (ulong* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetnUniformui64vARB(program, location, bufSize, parameters_ptr);
            }
        }

        // ProgramUniform1i64vARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1i64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<long> value)
        {
            var count = (int)(value.Length);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1i64vARB(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1i64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, long[] value)
        {
            var count = (int)(value.Length);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1i64vARB(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform1i64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in long value)
        {
            fixed (long* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform1i64vARB(program, location, count, value_ptr);
            }
        }

        // ProgramUniform2i64vARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2i64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<long> value)
        {
            var count = (int)(value.Length / 2);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2i64vARB(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2i64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, long[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2i64vARB(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform2i64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in long value)
        {
            fixed (long* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform2i64vARB(program, location, count, value_ptr);
            }
        }

        // ProgramUniform3i64vARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3i64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<long> value)
        {
            var count = (int)(value.Length / 3);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3i64vARB(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3i64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, long[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3i64vARB(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform3i64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in long value)
        {
            fixed (long* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform3i64vARB(program, location, count, value_ptr);
            }
        }

        // ProgramUniform4i64vARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4i64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<long> value)
        {
            var count = (int)(value.Length / 4);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4i64vARB(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4i64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, long[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (long* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4i64vARB(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform4i64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in long value)
        {
            fixed (long* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform4i64vARB(program, location, count, value_ptr);
            }
        }

        // ProgramUniform1ui64vARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1ui64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<ulong> value)
        {
            var count = (int)(value.Length);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1ui64vARB(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1ui64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, ulong[] value)
        {
            var count = (int)(value.Length);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1ui64vARB(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform1ui64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in ulong value)
        {
            fixed (ulong* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform1ui64vARB(program, location, count, value_ptr);
            }
        }

        // ProgramUniform2ui64vARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2ui64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<ulong> value)
        {
            var count = (int)(value.Length / 2);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2ui64vARB(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2ui64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, ulong[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2ui64vARB(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform2ui64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in ulong value)
        {
            fixed (ulong* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform2ui64vARB(program, location, count, value_ptr);
            }
        }

        // ProgramUniform3ui64vARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3ui64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<ulong> value)
        {
            var count = (int)(value.Length / 3);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3ui64vARB(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3ui64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, ulong[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3ui64vARB(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform3ui64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in ulong value)
        {
            fixed (ulong* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform3ui64vARB(program, location, count, value_ptr);
            }
        }

        // ProgramUniform4ui64vARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4ui64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<ulong> value)
        {
            var count = (int)(value.Length / 4);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4ui64vARB(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4ui64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, ulong[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (ulong* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4ui64vARB(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform4ui64vARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in ulong value)
        {
            fixed (ulong* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform4ui64vARB(program, location, count, value_ptr);
            }
        }

        // ColorTable overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ColorTable(this GL.ARBExtension glInstance, ColorTableTarget target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, IntPtr table)
        {
            var table_vptr = (void*)table;
            glInstance.ColorTable(target, internalformat, width, format, type, table_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ColorTable<T1>(this GL.ARBExtension glInstance, ColorTableTarget target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, ReadOnlySpan<T1> table)
            where T1 : unmanaged
        {
            fixed (void* table_ptr = table) // SpanOrArrayLayer
            {
                glInstance.ColorTable(target, internalformat, width, format, type, table_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ColorTable<T1>(this GL.ARBExtension glInstance, ColorTableTarget target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, T1[] table)
            where T1 : unmanaged
        {
            fixed (void* table_ptr = table) // SpanOrArrayLayer
            {
                glInstance.ColorTable(target, internalformat, width, format, type, table_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ColorTable<T1>(this GL.ARBExtension glInstance, ColorTableTarget target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, in T1 table)
            where T1 : unmanaged
        {
            fixed (void* table_ptr = &table) // RefInsteadOfPointerLayer
            {
                glInstance.ColorTable(target, internalformat, width, format, type, table_ptr);
            }
        }

        // ColorTableParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ColorTableParameterf(this GL.ARBExtension glInstance, ColorTableTarget target, ColorTableParameterPNameSGI pname, ReadOnlySpan<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.ColorTableParameterfv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ColorTableParameterf(this GL.ARBExtension glInstance, ColorTableTarget target, ColorTableParameterPNameSGI pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.ColorTableParameterfv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ColorTableParameterf(this GL.ARBExtension glInstance, ColorTableTarget target, ColorTableParameterPNameSGI pname, in float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.ColorTableParameterfv(target, pname, parameters_ptr);
            }
        }

        // ColorTableParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ColorTableParameteri(this GL.ARBExtension glInstance, ColorTableTarget target, ColorTableParameterPNameSGI pname, ReadOnlySpan<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.ColorTableParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ColorTableParameteri(this GL.ARBExtension glInstance, ColorTableTarget target, ColorTableParameterPNameSGI pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.ColorTableParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ColorTableParameteri(this GL.ARBExtension glInstance, ColorTableTarget target, ColorTableParameterPNameSGI pname, in int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.ColorTableParameteriv(target, pname, parameters_ptr);
            }
        }

        // GetColorTable overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetColorTable(this GL.ARBExtension glInstance, ColorTableTarget target, PixelFormat format, PixelType type, IntPtr table)
        {
            var table_vptr = (void*)table;
            glInstance.GetColorTable(target, format, type, table_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetColorTable<T1>(this GL.ARBExtension glInstance, ColorTableTarget target, PixelFormat format, PixelType type, Span<T1> table)
            where T1 : unmanaged
        {
            fixed (void* table_ptr = table) // SpanOrArrayLayer
            {
                glInstance.GetColorTable(target, format, type, table_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetColorTable<T1>(this GL.ARBExtension glInstance, ColorTableTarget target, PixelFormat format, PixelType type, T1[] table)
            where T1 : unmanaged
        {
            fixed (void* table_ptr = table) // SpanOrArrayLayer
            {
                glInstance.GetColorTable(target, format, type, table_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetColorTable<T1>(this GL.ARBExtension glInstance, ColorTableTarget target, PixelFormat format, PixelType type, ref T1 table)
            where T1 : unmanaged
        {
            fixed (void* table_ptr = &table) // RefInsteadOfPointerLayer
            {
                glInstance.GetColorTable(target, format, type, table_ptr);
            }
        }

        // GetColorTableParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetColorTableParameterf(this GL.ARBExtension glInstance, ColorTableTarget target, GetColorTableParameterPNameSGI pname, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetColorTableParameterfv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetColorTableParameterf(this GL.ARBExtension glInstance, ColorTableTarget target, GetColorTableParameterPNameSGI pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetColorTableParameterfv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetColorTableParameterf(this GL.ARBExtension glInstance, ColorTableTarget target, GetColorTableParameterPNameSGI pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetColorTableParameterfv(target, pname, parameters_ptr);
            }
        }

        // GetColorTableParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetColorTableParameteri(this GL.ARBExtension glInstance, ColorTableTarget target, GetColorTableParameterPNameSGI pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetColorTableParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetColorTableParameteri(this GL.ARBExtension glInstance, ColorTableTarget target, GetColorTableParameterPNameSGI pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetColorTableParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetColorTableParameteri(this GL.ARBExtension glInstance, ColorTableTarget target, GetColorTableParameterPNameSGI pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetColorTableParameteriv(target, pname, parameters_ptr);
            }
        }

        // ColorSubTable overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ColorSubTable(this GL.ARBExtension glInstance, ColorTableTarget target, int start, int count, PixelFormat format, PixelType type, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.ColorSubTable(target, start, count, format, type, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ColorSubTable<T1>(this GL.ARBExtension glInstance, ColorTableTarget target, int start, int count, PixelFormat format, PixelType type, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.ColorSubTable(target, start, count, format, type, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ColorSubTable<T1>(this GL.ARBExtension glInstance, ColorTableTarget target, int start, int count, PixelFormat format, PixelType type, T1[] data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.ColorSubTable(target, start, count, format, type, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ColorSubTable<T1>(this GL.ARBExtension glInstance, ColorTableTarget target, int start, int count, PixelFormat format, PixelType type, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.ColorSubTable(target, start, count, format, type, data_ptr);
            }
        }

        // ConvolutionFilter1D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ConvolutionFilter1D(this GL.ARBExtension glInstance, ConvolutionTarget target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, IntPtr image)
        {
            var image_vptr = (void*)image;
            glInstance.ConvolutionFilter1D(target, internalformat, width, format, type, image_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ConvolutionFilter1D<T1>(this GL.ARBExtension glInstance, ConvolutionTarget target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, ReadOnlySpan<T1> image)
            where T1 : unmanaged
        {
            fixed (void* image_ptr = image) // SpanOrArrayLayer
            {
                glInstance.ConvolutionFilter1D(target, internalformat, width, format, type, image_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ConvolutionFilter1D<T1>(this GL.ARBExtension glInstance, ConvolutionTarget target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, T1[] image)
            where T1 : unmanaged
        {
            fixed (void* image_ptr = image) // SpanOrArrayLayer
            {
                glInstance.ConvolutionFilter1D(target, internalformat, width, format, type, image_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ConvolutionFilter1D<T1>(this GL.ARBExtension glInstance, ConvolutionTarget target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, in T1 image)
            where T1 : unmanaged
        {
            fixed (void* image_ptr = &image) // RefInsteadOfPointerLayer
            {
                glInstance.ConvolutionFilter1D(target, internalformat, width, format, type, image_ptr);
            }
        }

        // ConvolutionFilter2D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ConvolutionFilter2D(this GL.ARBExtension glInstance, ConvolutionTarget target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, IntPtr image)
        {
            var image_vptr = (void*)image;
            glInstance.ConvolutionFilter2D(target, internalformat, width, height, format, type, image_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ConvolutionFilter2D<T1>(this GL.ARBExtension glInstance, ConvolutionTarget target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, ReadOnlySpan<T1> image)
            where T1 : unmanaged
        {
            fixed (void* image_ptr = image) // SpanOrArrayLayer
            {
                glInstance.ConvolutionFilter2D(target, internalformat, width, height, format, type, image_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ConvolutionFilter2D<T1>(this GL.ARBExtension glInstance, ConvolutionTarget target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, T1[] image)
            where T1 : unmanaged
        {
            fixed (void* image_ptr = image) // SpanOrArrayLayer
            {
                glInstance.ConvolutionFilter2D(target, internalformat, width, height, format, type, image_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ConvolutionFilter2D<T1>(this GL.ARBExtension glInstance, ConvolutionTarget target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, in T1 image)
            where T1 : unmanaged
        {
            fixed (void* image_ptr = &image) // RefInsteadOfPointerLayer
            {
                glInstance.ConvolutionFilter2D(target, internalformat, width, height, format, type, image_ptr);
            }
        }

        // ConvolutionParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ConvolutionParameterf(this GL.ARBExtension glInstance, ConvolutionTarget target, ConvolutionParameterEXT pname, ReadOnlySpan<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.ConvolutionParameterfv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ConvolutionParameterf(this GL.ARBExtension glInstance, ConvolutionTarget target, ConvolutionParameterEXT pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.ConvolutionParameterfv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ConvolutionParameterf(this GL.ARBExtension glInstance, ConvolutionTarget target, ConvolutionParameterEXT pname, in float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.ConvolutionParameterfv(target, pname, parameters_ptr);
            }
        }

        // ConvolutionParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ConvolutionParameteri(this GL.ARBExtension glInstance, ConvolutionTarget target, ConvolutionParameterEXT pname, ReadOnlySpan<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.ConvolutionParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ConvolutionParameteri(this GL.ARBExtension glInstance, ConvolutionTarget target, ConvolutionParameterEXT pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.ConvolutionParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ConvolutionParameteri(this GL.ARBExtension glInstance, ConvolutionTarget target, ConvolutionParameterEXT pname, in int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.ConvolutionParameteriv(target, pname, parameters_ptr);
            }
        }

        // GetConvolutionFilter overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetConvolutionFilter(this GL.ARBExtension glInstance, ConvolutionTarget target, PixelFormat format, PixelType type, IntPtr image)
        {
            var image_vptr = (void*)image;
            glInstance.GetConvolutionFilter(target, format, type, image_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetConvolutionFilter<T1>(this GL.ARBExtension glInstance, ConvolutionTarget target, PixelFormat format, PixelType type, Span<T1> image)
            where T1 : unmanaged
        {
            fixed (void* image_ptr = image) // SpanOrArrayLayer
            {
                glInstance.GetConvolutionFilter(target, format, type, image_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetConvolutionFilter<T1>(this GL.ARBExtension glInstance, ConvolutionTarget target, PixelFormat format, PixelType type, T1[] image)
            where T1 : unmanaged
        {
            fixed (void* image_ptr = image) // SpanOrArrayLayer
            {
                glInstance.GetConvolutionFilter(target, format, type, image_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetConvolutionFilter<T1>(this GL.ARBExtension glInstance, ConvolutionTarget target, PixelFormat format, PixelType type, ref T1 image)
            where T1 : unmanaged
        {
            fixed (void* image_ptr = &image) // RefInsteadOfPointerLayer
            {
                glInstance.GetConvolutionFilter(target, format, type, image_ptr);
            }
        }

        // GetConvolutionParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetConvolutionParameterf(this GL.ARBExtension glInstance, ConvolutionTarget target, ConvolutionParameterEXT pname, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetConvolutionParameterfv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetConvolutionParameterf(this GL.ARBExtension glInstance, ConvolutionTarget target, ConvolutionParameterEXT pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetConvolutionParameterfv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetConvolutionParameterf(this GL.ARBExtension glInstance, ConvolutionTarget target, ConvolutionParameterEXT pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetConvolutionParameterfv(target, pname, parameters_ptr);
            }
        }

        // GetConvolutionParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetConvolutionParameteri(this GL.ARBExtension glInstance, ConvolutionTarget target, ConvolutionParameterEXT pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetConvolutionParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetConvolutionParameteri(this GL.ARBExtension glInstance, ConvolutionTarget target, ConvolutionParameterEXT pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetConvolutionParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetConvolutionParameteri(this GL.ARBExtension glInstance, ConvolutionTarget target, ConvolutionParameterEXT pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetConvolutionParameteriv(target, pname, parameters_ptr);
            }
        }

        // GetSeparableFilter overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetSeparableFilter(this GL.ARBExtension glInstance, SeparableTargetEXT target, PixelFormat format, PixelType type, IntPtr row, IntPtr column, IntPtr span)
        {
            var row_vptr = (void*)row;
            var column_vptr = (void*)column;
            var span_vptr = (void*)span;
            glInstance.GetSeparableFilter(target, format, type, row_vptr, column_vptr, span_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSeparableFilter<T1, T2, T3>(this GL.ARBExtension glInstance, SeparableTargetEXT target, PixelFormat format, PixelType type, Span<T3> row, Span<T2> column, Span<T1> span)
            where T1 : unmanaged
            where T2 : unmanaged
            where T3 : unmanaged
        {
            fixed (void* row_ptr = row) // SpanOrArrayLayer
            {
                fixed (void* column_ptr = column) // SpanOrArrayLayer
                {
                    fixed (void* span_ptr = span) // SpanOrArrayLayer
                    {
                        glInstance.GetSeparableFilter(target, format, type, row_ptr, column_ptr, span_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSeparableFilter<T1, T2, T3>(this GL.ARBExtension glInstance, SeparableTargetEXT target, PixelFormat format, PixelType type, T3[] row, T2[] column, T1[] span)
            where T1 : unmanaged
            where T2 : unmanaged
            where T3 : unmanaged
        {
            fixed (void* row_ptr = row) // SpanOrArrayLayer
            {
                fixed (void* column_ptr = column) // SpanOrArrayLayer
                {
                    fixed (void* span_ptr = span) // SpanOrArrayLayer
                    {
                        glInstance.GetSeparableFilter(target, format, type, row_ptr, column_ptr, span_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetSeparableFilter<T1, T2, T3>(this GL.ARBExtension glInstance, SeparableTargetEXT target, PixelFormat format, PixelType type, ref T1 row, ref T2 column, ref T3 span)
            where T1 : unmanaged
            where T2 : unmanaged
            where T3 : unmanaged
        {
            fixed (void* row_ptr = &row) // RefInsteadOfPointerLayer
            fixed (void* column_ptr = &column) // RefInsteadOfPointerLayer
            fixed (void* span_ptr = &span) // RefInsteadOfPointerLayer
            {
                glInstance.GetSeparableFilter(target, format, type, row_ptr, column_ptr, span_ptr);
            }
        }

        // SeparableFilter2D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void SeparableFilter2D(this GL.ARBExtension glInstance, SeparableTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, IntPtr row, IntPtr column)
        {
            var row_vptr = (void*)row;
            var column_vptr = (void*)column;
            glInstance.SeparableFilter2D(target, internalformat, width, height, format, type, row_vptr, column_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SeparableFilter2D<T1, T2>(this GL.ARBExtension glInstance, SeparableTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, ReadOnlySpan<T2> row, ReadOnlySpan<T1> column)
            where T1 : unmanaged
            where T2 : unmanaged
        {
            fixed (void* row_ptr = row) // SpanOrArrayLayer
            {
                fixed (void* column_ptr = column) // SpanOrArrayLayer
                {
                    glInstance.SeparableFilter2D(target, internalformat, width, height, format, type, row_ptr, column_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SeparableFilter2D<T1, T2>(this GL.ARBExtension glInstance, SeparableTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, T2[] row, T1[] column)
            where T1 : unmanaged
            where T2 : unmanaged
        {
            fixed (void* row_ptr = row) // SpanOrArrayLayer
            {
                fixed (void* column_ptr = column) // SpanOrArrayLayer
                {
                    glInstance.SeparableFilter2D(target, internalformat, width, height, format, type, row_ptr, column_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SeparableFilter2D<T1, T2>(this GL.ARBExtension glInstance, SeparableTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, in T1 row, in T2 column)
            where T1 : unmanaged
            where T2 : unmanaged
        {
            fixed (void* row_ptr = &row) // RefInsteadOfPointerLayer
            fixed (void* column_ptr = &column) // RefInsteadOfPointerLayer
            {
                glInstance.SeparableFilter2D(target, internalformat, width, height, format, type, row_ptr, column_ptr);
            }
        }

        // GetHistogram overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetHistogram(this GL.ARBExtension glInstance, HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, IntPtr values)
        {
            var values_vptr = (void*)values;
            var reset_byte = (byte)(reset ? 1 : 0);
            glInstance.GetHistogram(target, reset_byte, format, type, values_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetHistogram<T1>(this GL.ARBExtension glInstance, HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, Span<T1> values)
            where T1 : unmanaged
        {
            fixed (void* values_ptr = values) // SpanOrArrayLayer
            {
                var reset_byte = (byte)(reset ? 1 : 0);
                glInstance.GetHistogram(target, reset_byte, format, type, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetHistogram<T1>(this GL.ARBExtension glInstance, HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, T1[] values)
            where T1 : unmanaged
        {
            fixed (void* values_ptr = values) // SpanOrArrayLayer
            {
                var reset_byte = (byte)(reset ? 1 : 0);
                glInstance.GetHistogram(target, reset_byte, format, type, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetHistogram<T1>(this GL.ARBExtension glInstance, HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, ref T1 values)
            where T1 : unmanaged
        {
            fixed (void* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                var reset_byte = (byte)(reset ? 1 : 0);
                glInstance.GetHistogram(target, reset_byte, format, type, values_ptr);
            }
        }

        // GetHistogramParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetHistogramParameterf(this GL.ARBExtension glInstance, HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetHistogramParameterfv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetHistogramParameterf(this GL.ARBExtension glInstance, HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetHistogramParameterfv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetHistogramParameterf(this GL.ARBExtension glInstance, HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetHistogramParameterfv(target, pname, parameters_ptr);
            }
        }

        // GetHistogramParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetHistogramParameteri(this GL.ARBExtension glInstance, HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetHistogramParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetHistogramParameteri(this GL.ARBExtension glInstance, HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetHistogramParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetHistogramParameteri(this GL.ARBExtension glInstance, HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetHistogramParameteriv(target, pname, parameters_ptr);
            }
        }

        // GetMinmax overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetMinmax(this GL.ARBExtension glInstance, MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, IntPtr values)
        {
            var values_vptr = (void*)values;
            var reset_byte = (byte)(reset ? 1 : 0);
            glInstance.GetMinmax(target, reset_byte, format, type, values_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetMinmax<T1>(this GL.ARBExtension glInstance, MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, Span<T1> values)
            where T1 : unmanaged
        {
            fixed (void* values_ptr = values) // SpanOrArrayLayer
            {
                var reset_byte = (byte)(reset ? 1 : 0);
                glInstance.GetMinmax(target, reset_byte, format, type, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetMinmax<T1>(this GL.ARBExtension glInstance, MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, T1[] values)
            where T1 : unmanaged
        {
            fixed (void* values_ptr = values) // SpanOrArrayLayer
            {
                var reset_byte = (byte)(reset ? 1 : 0);
                glInstance.GetMinmax(target, reset_byte, format, type, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetMinmax<T1>(this GL.ARBExtension glInstance, MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, ref T1 values)
            where T1 : unmanaged
        {
            fixed (void* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                var reset_byte = (byte)(reset ? 1 : 0);
                glInstance.GetMinmax(target, reset_byte, format, type, values_ptr);
            }
        }

        // GetMinmaxParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetMinmaxParameterf(this GL.ARBExtension glInstance, MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetMinmaxParameterfv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetMinmaxParameterf(this GL.ARBExtension glInstance, MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetMinmaxParameterfv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetMinmaxParameterf(this GL.ARBExtension glInstance, MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetMinmaxParameterfv(target, pname, parameters_ptr);
            }
        }

        // GetMinmaxParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetMinmaxParameteri(this GL.ARBExtension glInstance, MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetMinmaxParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetMinmaxParameteri(this GL.ARBExtension glInstance, MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetMinmaxParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetMinmaxParameteri(this GL.ARBExtension glInstance, MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetMinmaxParameteriv(target, pname, parameters_ptr);
            }
        }

        // Histogram overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void Histogram(this GL.ARBExtension glInstance, HistogramTargetEXT target, int width, InternalFormat internalformat, bool sink)
        {
            var sink_byte = (byte)(sink ? 1 : 0);
            glInstance.Histogram(target, width, internalformat, sink_byte);
        }

        // Minmax overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void Minmax(this GL.ARBExtension glInstance, MinmaxTargetEXT target, InternalFormat internalformat, bool sink)
        {
            var sink_byte = (byte)(sink ? 1 : 0);
            glInstance.Minmax(target, internalformat, sink_byte);
        }

        // MultiDrawArraysIndirectCountARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void MultiDrawArraysIndirectCountARB(this GL.ARBExtension glInstance, PrimitiveType mode, IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride)
        {
            var indirect_vptr = (void*)indirect;
            glInstance.MultiDrawArraysIndirectCountARB(mode, indirect_vptr, drawcount, maxdrawcount, stride);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiDrawArraysIndirectCountARB<T1>(this GL.ARBExtension glInstance, PrimitiveType mode, in T1 indirect, IntPtr drawcount, int maxdrawcount, int stride)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = &indirect) // RefInsteadOfPointerLayer
            {
                glInstance.MultiDrawArraysIndirectCountARB(mode, indirect_ptr, drawcount, maxdrawcount, stride);
            }
        }

        // MultiDrawElementsIndirectCountARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void MultiDrawElementsIndirectCountARB(this GL.ARBExtension glInstance, PrimitiveType mode, DrawElementsType type, IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride)
        {
            var indirect_vptr = (void*)indirect;
            glInstance.MultiDrawElementsIndirectCountARB(mode, type, indirect_vptr, drawcount, maxdrawcount, stride);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiDrawElementsIndirectCountARB<T1>(this GL.ARBExtension glInstance, PrimitiveType mode, DrawElementsType type, in T1 indirect, IntPtr drawcount, int maxdrawcount, int stride)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = &indirect) // RefInsteadOfPointerLayer
            {
                glInstance.MultiDrawElementsIndirectCountARB(mode, type, indirect_ptr, drawcount, maxdrawcount, stride);
            }
        }

        // GetInternalformativ overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInternalformati(this GL.ARBExtension glInstance, TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, Span<int> parameters)
        {
            var count = (int)(parameters.Length);
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetInternalformativ(target, internalformat, pname, count, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInternalformati(this GL.ARBExtension glInstance, TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int[] parameters)
        {
            var count = (int)(parameters.Length);
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetInternalformativ(target, internalformat, pname, count, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetInternalformati(this GL.ARBExtension glInstance, TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetInternalformativ(target, internalformat, pname, count, parameters_ptr);
            }
        }

        // GetInternalformati64v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInternalformati64(this GL.ARBExtension glInstance, TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, Span<long> parameters)
        {
            var count = (int)(parameters.Length);
            fixed (long* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetInternalformati64v(target, internalformat, pname, count, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInternalformati64(this GL.ARBExtension glInstance, TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, long[] parameters)
        {
            var count = (int)(parameters.Length);
            fixed (long* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetInternalformati64v(target, internalformat, pname, count, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetInternalformati64(this GL.ARBExtension glInstance, TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, ref long parameters)
        {
            fixed (long* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetInternalformati64v(target, internalformat, pname, count, parameters_ptr);
            }
        }

        // InvalidateFramebuffer overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void InvalidateFramebuffer(this GL.ARBExtension glInstance, FramebufferTarget target, ReadOnlySpan<InvalidateFramebufferAttachment> attachments)
        {
            var numAttachments = (int)(attachments.Length);
            fixed (InvalidateFramebufferAttachment* attachments_ptr = attachments) // SpanOrArrayLayer
            {
                glInstance.InvalidateFramebuffer(target, numAttachments, attachments_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void InvalidateFramebuffer(this GL.ARBExtension glInstance, FramebufferTarget target, InvalidateFramebufferAttachment[] attachments)
        {
            var numAttachments = (int)(attachments.Length);
            fixed (InvalidateFramebufferAttachment* attachments_ptr = attachments) // SpanOrArrayLayer
            {
                glInstance.InvalidateFramebuffer(target, numAttachments, attachments_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void InvalidateFramebuffer(this GL.ARBExtension glInstance, FramebufferTarget target, int numAttachments, in InvalidateFramebufferAttachment attachments)
        {
            fixed (InvalidateFramebufferAttachment* attachments_ptr = &attachments) // RefInsteadOfPointerLayer
            {
                glInstance.InvalidateFramebuffer(target, numAttachments, attachments_ptr);
            }
        }

        // InvalidateSubFramebuffer overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void InvalidateSubFramebuffer(this GL.ARBExtension glInstance, FramebufferTarget target, ReadOnlySpan<InvalidateFramebufferAttachment> attachments, int x, int y, int width, int height)
        {
            var numAttachments = (int)(attachments.Length);
            fixed (InvalidateFramebufferAttachment* attachments_ptr = attachments) // SpanOrArrayLayer
            {
                glInstance.InvalidateSubFramebuffer(target, numAttachments, attachments_ptr, x, y, width, height);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void InvalidateSubFramebuffer(this GL.ARBExtension glInstance, FramebufferTarget target, InvalidateFramebufferAttachment[] attachments, int x, int y, int width, int height)
        {
            var numAttachments = (int)(attachments.Length);
            fixed (InvalidateFramebufferAttachment* attachments_ptr = attachments) // SpanOrArrayLayer
            {
                glInstance.InvalidateSubFramebuffer(target, numAttachments, attachments_ptr, x, y, width, height);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void InvalidateSubFramebuffer(this GL.ARBExtension glInstance, FramebufferTarget target, int numAttachments, in InvalidateFramebufferAttachment attachments, int x, int y, int width, int height)
        {
            fixed (InvalidateFramebufferAttachment* attachments_ptr = &attachments) // RefInsteadOfPointerLayer
            {
                glInstance.InvalidateSubFramebuffer(target, numAttachments, attachments_ptr, x, y, width, height);
            }
        }

        // MatrixIndexubvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MatrixIndexubvARB(this GL.ARBExtension glInstance, ReadOnlySpan<byte> indices)
        {
            var size = (int)(indices.Length);
            fixed (byte* indices_ptr = indices) // SpanOrArrayLayer
            {
                glInstance.MatrixIndexubvARB(size, indices_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MatrixIndexubvARB(this GL.ARBExtension glInstance, byte[] indices)
        {
            var size = (int)(indices.Length);
            fixed (byte* indices_ptr = indices) // SpanOrArrayLayer
            {
                glInstance.MatrixIndexubvARB(size, indices_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MatrixIndexubvARB(this GL.ARBExtension glInstance, int size, in byte indices)
        {
            fixed (byte* indices_ptr = &indices) // RefInsteadOfPointerLayer
            {
                glInstance.MatrixIndexubvARB(size, indices_ptr);
            }
        }

        // MatrixIndexusvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MatrixIndexusvARB(this GL.ARBExtension glInstance, ReadOnlySpan<ushort> indices)
        {
            var size = (int)(indices.Length);
            fixed (ushort* indices_ptr = indices) // SpanOrArrayLayer
            {
                glInstance.MatrixIndexusvARB(size, indices_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MatrixIndexusvARB(this GL.ARBExtension glInstance, ushort[] indices)
        {
            var size = (int)(indices.Length);
            fixed (ushort* indices_ptr = indices) // SpanOrArrayLayer
            {
                glInstance.MatrixIndexusvARB(size, indices_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MatrixIndexusvARB(this GL.ARBExtension glInstance, int size, in ushort indices)
        {
            fixed (ushort* indices_ptr = &indices) // RefInsteadOfPointerLayer
            {
                glInstance.MatrixIndexusvARB(size, indices_ptr);
            }
        }

        // MatrixIndexuivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MatrixIndexuivARB(this GL.ARBExtension glInstance, ReadOnlySpan<uint> indices)
        {
            var size = (int)(indices.Length);
            fixed (uint* indices_ptr = indices) // SpanOrArrayLayer
            {
                glInstance.MatrixIndexuivARB(size, indices_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MatrixIndexuivARB(this GL.ARBExtension glInstance, uint[] indices)
        {
            var size = (int)(indices.Length);
            fixed (uint* indices_ptr = indices) // SpanOrArrayLayer
            {
                glInstance.MatrixIndexuivARB(size, indices_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MatrixIndexuivARB(this GL.ARBExtension glInstance, int size, in uint indices)
        {
            fixed (uint* indices_ptr = &indices) // RefInsteadOfPointerLayer
            {
                glInstance.MatrixIndexuivARB(size, indices_ptr);
            }
        }

        // MatrixIndexPointerARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void MatrixIndexPointerARB(this GL.ARBExtension glInstance, int size, MatrixIndexPointerTypeARB type, int stride, IntPtr pointer)
        {
            var pointer_vptr = (void*)pointer;
            glInstance.MatrixIndexPointerARB(size, type, stride, pointer_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MatrixIndexPointerARB<T1>(this GL.ARBExtension glInstance, int size, MatrixIndexPointerTypeARB type, int stride, ReadOnlySpan<T1> pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.MatrixIndexPointerARB(size, type, stride, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MatrixIndexPointerARB<T1>(this GL.ARBExtension glInstance, int size, MatrixIndexPointerTypeARB type, int stride, T1[] pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.MatrixIndexPointerARB(size, type, stride, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MatrixIndexPointerARB<T1>(this GL.ARBExtension glInstance, int size, MatrixIndexPointerTypeARB type, int stride, in T1 pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = &pointer) // RefInsteadOfPointerLayer
            {
                glInstance.MatrixIndexPointerARB(size, type, stride, pointer_ptr);
            }
        }

        // BindBuffersBase overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BindBuffersBase(this GL.ARBExtension glInstance, BufferTargetARB target, uint first, ReadOnlySpan<BufferHandle> buffers)
        {
            var count = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                glInstance.BindBuffersBase(target, first, count, buffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BindBuffersBase(this GL.ARBExtension glInstance, BufferTargetARB target, uint first, BufferHandle[] buffers)
        {
            var count = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                glInstance.BindBuffersBase(target, first, count, buffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void BindBuffersBase(this GL.ARBExtension glInstance, BufferTargetARB target, uint first, int count, in BufferHandle buffers)
        {
            fixed (BufferHandle* buffers_ptr = &buffers) // RefInsteadOfPointerLayer
            {
                glInstance.BindBuffersBase(target, first, count, buffers_ptr);
            }
        }

        // BindBuffersRange overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BindBuffersRange(this GL.ARBExtension glInstance, BufferTargetARB target, uint first, int count, ReadOnlySpan<BufferHandle> buffers, ReadOnlySpan<IntPtr> offsets, ReadOnlySpan<nint> sizes)
        {
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                fixed (IntPtr* offsets_ptr = offsets) // SpanOrArrayLayer
                {
                    fixed (nint* sizes_ptr = sizes) // SpanOrArrayLayer
                    {
                        glInstance.BindBuffersRange(target, first, count, buffers_ptr, offsets_ptr, sizes_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BindBuffersRange(this GL.ARBExtension glInstance, BufferTargetARB target, uint first, int count, BufferHandle[] buffers, IntPtr[] offsets, nint[] sizes)
        {
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                fixed (IntPtr* offsets_ptr = offsets) // SpanOrArrayLayer
                {
                    fixed (nint* sizes_ptr = sizes) // SpanOrArrayLayer
                    {
                        glInstance.BindBuffersRange(target, first, count, buffers_ptr, offsets_ptr, sizes_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void BindBuffersRange(this GL.ARBExtension glInstance, BufferTargetARB target, uint first, int count, in BufferHandle buffers, in IntPtr offsets, in nint sizes)
        {
            fixed (BufferHandle* buffers_ptr = &buffers) // RefInsteadOfPointerLayer
            fixed (IntPtr* offsets_ptr = &offsets) // RefInsteadOfPointerLayer
            fixed (nint* sizes_ptr = &sizes) // RefInsteadOfPointerLayer
            {
                glInstance.BindBuffersRange(target, first, count, buffers_ptr, offsets_ptr, sizes_ptr);
            }
        }

        // BindTextures overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BindTextures(this GL.ARBExtension glInstance, uint first, ReadOnlySpan<TextureHandle> textures)
        {
            var count = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures) // SpanOrArrayLayer
            {
                glInstance.BindTextures(first, count, textures_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BindTextures(this GL.ARBExtension glInstance, uint first, TextureHandle[] textures)
        {
            var count = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures) // SpanOrArrayLayer
            {
                glInstance.BindTextures(first, count, textures_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void BindTextures(this GL.ARBExtension glInstance, uint first, int count, in TextureHandle textures)
        {
            fixed (TextureHandle* textures_ptr = &textures) // RefInsteadOfPointerLayer
            {
                glInstance.BindTextures(first, count, textures_ptr);
            }
        }

        // BindSamplers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BindSamplers(this GL.ARBExtension glInstance, uint first, ReadOnlySpan<SamplerHandle> samplers)
        {
            var count = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers) // SpanOrArrayLayer
            {
                glInstance.BindSamplers(first, count, samplers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BindSamplers(this GL.ARBExtension glInstance, uint first, SamplerHandle[] samplers)
        {
            var count = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers) // SpanOrArrayLayer
            {
                glInstance.BindSamplers(first, count, samplers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void BindSamplers(this GL.ARBExtension glInstance, uint first, int count, in SamplerHandle samplers)
        {
            fixed (SamplerHandle* samplers_ptr = &samplers) // RefInsteadOfPointerLayer
            {
                glInstance.BindSamplers(first, count, samplers_ptr);
            }
        }

        // BindImageTextures overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BindImageTextures(this GL.ARBExtension glInstance, uint first, ReadOnlySpan<TextureHandle> textures)
        {
            var count = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures) // SpanOrArrayLayer
            {
                glInstance.BindImageTextures(first, count, textures_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BindImageTextures(this GL.ARBExtension glInstance, uint first, TextureHandle[] textures)
        {
            var count = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures) // SpanOrArrayLayer
            {
                glInstance.BindImageTextures(first, count, textures_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void BindImageTextures(this GL.ARBExtension glInstance, uint first, int count, in TextureHandle textures)
        {
            fixed (TextureHandle* textures_ptr = &textures) // RefInsteadOfPointerLayer
            {
                glInstance.BindImageTextures(first, count, textures_ptr);
            }
        }

        // BindVertexBuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BindVertexBuffers(this GL.ARBExtension glInstance, uint first, int count, ReadOnlySpan<BufferHandle> buffers, ReadOnlySpan<IntPtr> offsets, ReadOnlySpan<int> strides)
        {
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                fixed (IntPtr* offsets_ptr = offsets) // SpanOrArrayLayer
                {
                    fixed (int* strides_ptr = strides) // SpanOrArrayLayer
                    {
                        glInstance.BindVertexBuffers(first, count, buffers_ptr, offsets_ptr, strides_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BindVertexBuffers(this GL.ARBExtension glInstance, uint first, int count, BufferHandle[] buffers, IntPtr[] offsets, int[] strides)
        {
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                fixed (IntPtr* offsets_ptr = offsets) // SpanOrArrayLayer
                {
                    fixed (int* strides_ptr = strides) // SpanOrArrayLayer
                    {
                        glInstance.BindVertexBuffers(first, count, buffers_ptr, offsets_ptr, strides_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void BindVertexBuffers(this GL.ARBExtension glInstance, uint first, int count, in BufferHandle buffers, in IntPtr offsets, in int strides)
        {
            fixed (BufferHandle* buffers_ptr = &buffers) // RefInsteadOfPointerLayer
            fixed (IntPtr* offsets_ptr = &offsets) // RefInsteadOfPointerLayer
            fixed (int* strides_ptr = &strides) // RefInsteadOfPointerLayer
            {
                glInstance.BindVertexBuffers(first, count, buffers_ptr, offsets_ptr, strides_ptr);
            }
        }

        // MultiDrawArraysIndirect overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void MultiDrawArraysIndirect(this GL.ARBExtension glInstance, PrimitiveType mode, IntPtr indirect, int drawcount, int stride)
        {
            var indirect_vptr = (void*)indirect;
            glInstance.MultiDrawArraysIndirect(mode, indirect_vptr, drawcount, stride);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiDrawArraysIndirect<T1>(this GL.ARBExtension glInstance, PrimitiveType mode, ReadOnlySpan<T1> indirect, int drawcount, int stride)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = indirect) // SpanOrArrayLayer
            {
                glInstance.MultiDrawArraysIndirect(mode, indirect_ptr, drawcount, stride);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiDrawArraysIndirect<T1>(this GL.ARBExtension glInstance, PrimitiveType mode, T1[] indirect, int drawcount, int stride)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = indirect) // SpanOrArrayLayer
            {
                glInstance.MultiDrawArraysIndirect(mode, indirect_ptr, drawcount, stride);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiDrawArraysIndirect<T1>(this GL.ARBExtension glInstance, PrimitiveType mode, in T1 indirect, int drawcount, int stride)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = &indirect) // RefInsteadOfPointerLayer
            {
                glInstance.MultiDrawArraysIndirect(mode, indirect_ptr, drawcount, stride);
            }
        }

        // MultiDrawElementsIndirect overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void MultiDrawElementsIndirect(this GL.ARBExtension glInstance, PrimitiveType mode, DrawElementsType type, IntPtr indirect, int drawcount, int stride)
        {
            var indirect_vptr = (void*)indirect;
            glInstance.MultiDrawElementsIndirect(mode, type, indirect_vptr, drawcount, stride);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiDrawElementsIndirect<T1>(this GL.ARBExtension glInstance, PrimitiveType mode, DrawElementsType type, ReadOnlySpan<T1> indirect, int drawcount, int stride)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = indirect) // SpanOrArrayLayer
            {
                glInstance.MultiDrawElementsIndirect(mode, type, indirect_ptr, drawcount, stride);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiDrawElementsIndirect<T1>(this GL.ARBExtension glInstance, PrimitiveType mode, DrawElementsType type, T1[] indirect, int drawcount, int stride)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = indirect) // SpanOrArrayLayer
            {
                glInstance.MultiDrawElementsIndirect(mode, type, indirect_ptr, drawcount, stride);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiDrawElementsIndirect<T1>(this GL.ARBExtension glInstance, PrimitiveType mode, DrawElementsType type, in T1 indirect, int drawcount, int stride)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = &indirect) // RefInsteadOfPointerLayer
            {
                glInstance.MultiDrawElementsIndirect(mode, type, indirect_ptr, drawcount, stride);
            }
        }

        // SampleCoverageARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void SampleCoverageARB(this GL.ARBExtension glInstance, float value, bool invert)
        {
            var invert_byte = (byte)(invert ? 1 : 0);
            glInstance.SampleCoverageARB(value, invert_byte);
        }

        // MultiTexCoord1dvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord1dvARB(this GL.ARBExtension glInstance, TextureUnit target, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord1dvARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord1dvARB(this GL.ARBExtension glInstance, TextureUnit target, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord1dvARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord1dvARB(this GL.ARBExtension glInstance, TextureUnit target, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord1dvARB(target, v_ptr);
            }
        }

        // MultiTexCoord1fvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord1fvARB(this GL.ARBExtension glInstance, TextureUnit target, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord1fvARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord1fvARB(this GL.ARBExtension glInstance, TextureUnit target, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord1fvARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord1fvARB(this GL.ARBExtension glInstance, TextureUnit target, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord1fvARB(target, v_ptr);
            }
        }

        // MultiTexCoord1ivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord1ivARB(this GL.ARBExtension glInstance, TextureUnit target, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord1ivARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord1ivARB(this GL.ARBExtension glInstance, TextureUnit target, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord1ivARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord1ivARB(this GL.ARBExtension glInstance, TextureUnit target, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord1ivARB(target, v_ptr);
            }
        }

        // MultiTexCoord1svARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord1svARB(this GL.ARBExtension glInstance, TextureUnit target, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord1svARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord1svARB(this GL.ARBExtension glInstance, TextureUnit target, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord1svARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord1svARB(this GL.ARBExtension glInstance, TextureUnit target, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord1svARB(target, v_ptr);
            }
        }

        // MultiTexCoord2dvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord2dvARB(this GL.ARBExtension glInstance, TextureUnit target, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord2dvARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord2dvARB(this GL.ARBExtension glInstance, TextureUnit target, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord2dvARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord2dvARB(this GL.ARBExtension glInstance, TextureUnit target, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord2dvARB(target, v_ptr);
            }
        }

        // MultiTexCoord2fvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord2fvARB(this GL.ARBExtension glInstance, TextureUnit target, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord2fvARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord2fvARB(this GL.ARBExtension glInstance, TextureUnit target, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord2fvARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord2fvARB(this GL.ARBExtension glInstance, TextureUnit target, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord2fvARB(target, v_ptr);
            }
        }

        // MultiTexCoord2ivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord2ivARB(this GL.ARBExtension glInstance, TextureUnit target, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord2ivARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord2ivARB(this GL.ARBExtension glInstance, TextureUnit target, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord2ivARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord2ivARB(this GL.ARBExtension glInstance, TextureUnit target, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord2ivARB(target, v_ptr);
            }
        }

        // MultiTexCoord2svARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord2svARB(this GL.ARBExtension glInstance, TextureUnit target, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord2svARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord2svARB(this GL.ARBExtension glInstance, TextureUnit target, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord2svARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord2svARB(this GL.ARBExtension glInstance, TextureUnit target, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord2svARB(target, v_ptr);
            }
        }

        // MultiTexCoord3dvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord3dvARB(this GL.ARBExtension glInstance, TextureUnit target, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord3dvARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord3dvARB(this GL.ARBExtension glInstance, TextureUnit target, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord3dvARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord3dvARB(this GL.ARBExtension glInstance, TextureUnit target, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord3dvARB(target, v_ptr);
            }
        }

        // MultiTexCoord3fvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord3fvARB(this GL.ARBExtension glInstance, TextureUnit target, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord3fvARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord3fvARB(this GL.ARBExtension glInstance, TextureUnit target, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord3fvARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord3fvARB(this GL.ARBExtension glInstance, TextureUnit target, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord3fvARB(target, v_ptr);
            }
        }

        // MultiTexCoord3ivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord3ivARB(this GL.ARBExtension glInstance, TextureUnit target, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord3ivARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord3ivARB(this GL.ARBExtension glInstance, TextureUnit target, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord3ivARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord3ivARB(this GL.ARBExtension glInstance, TextureUnit target, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord3ivARB(target, v_ptr);
            }
        }

        // MultiTexCoord3svARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord3svARB(this GL.ARBExtension glInstance, TextureUnit target, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord3svARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord3svARB(this GL.ARBExtension glInstance, TextureUnit target, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord3svARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord3svARB(this GL.ARBExtension glInstance, TextureUnit target, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord3svARB(target, v_ptr);
            }
        }

        // MultiTexCoord4dvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord4dvARB(this GL.ARBExtension glInstance, TextureUnit target, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord4dvARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord4dvARB(this GL.ARBExtension glInstance, TextureUnit target, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord4dvARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord4dvARB(this GL.ARBExtension glInstance, TextureUnit target, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord4dvARB(target, v_ptr);
            }
        }

        // MultiTexCoord4fvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord4fvARB(this GL.ARBExtension glInstance, TextureUnit target, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord4fvARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord4fvARB(this GL.ARBExtension glInstance, TextureUnit target, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord4fvARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord4fvARB(this GL.ARBExtension glInstance, TextureUnit target, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord4fvARB(target, v_ptr);
            }
        }

        // MultiTexCoord4ivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord4ivARB(this GL.ARBExtension glInstance, TextureUnit target, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord4ivARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord4ivARB(this GL.ARBExtension glInstance, TextureUnit target, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord4ivARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord4ivARB(this GL.ARBExtension glInstance, TextureUnit target, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord4ivARB(target, v_ptr);
            }
        }

        // MultiTexCoord4svARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord4svARB(this GL.ARBExtension glInstance, TextureUnit target, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord4svARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord4svARB(this GL.ARBExtension glInstance, TextureUnit target, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord4svARB(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord4svARB(this GL.ARBExtension glInstance, TextureUnit target, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord4svARB(target, v_ptr);
            }
        }

        // GenQueriesARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenQueriesARB(this GL.ARBExtension glInstance, Span<QueryHandle> ids)
        {
            var n = (int)(ids.Length);
            fixed (QueryHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.GenQueriesARB(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenQueriesARB(this GL.ARBExtension glInstance, QueryHandle[] ids)
        {
            var n = (int)(ids.Length);
            fixed (QueryHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.GenQueriesARB(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenQueriesARB(this GL.ARBExtension glInstance, int n, ref QueryHandle ids)
        {
            fixed (QueryHandle* ids_ptr = &ids) // RefInsteadOfPointerLayer
            {
                glInstance.GenQueriesARB(n, ids_ptr);
            }
        }

        // DeleteQueriesARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteQueriesARB(this GL.ARBExtension glInstance, ReadOnlySpan<QueryHandle> ids)
        {
            var n = (int)(ids.Length);
            fixed (QueryHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.DeleteQueriesARB(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteQueriesARB(this GL.ARBExtension glInstance, QueryHandle[] ids)
        {
            var n = (int)(ids.Length);
            fixed (QueryHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.DeleteQueriesARB(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteQueriesARB(this GL.ARBExtension glInstance, int n, in QueryHandle ids)
        {
            fixed (QueryHandle* ids_ptr = &ids) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteQueriesARB(n, ids_ptr);
            }
        }

        // GetQueryivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryivARB(this GL.ARBExtension glInstance, QueryTarget target, QueryParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryivARB(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryivARB(this GL.ARBExtension glInstance, QueryTarget target, QueryParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryivARB(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetQueryivARB(this GL.ARBExtension glInstance, QueryTarget target, QueryParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetQueryivARB(target, pname, parameters_ptr);
            }
        }

        // GetQueryObjectivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryObjectivARB(this GL.ARBExtension glInstance, QueryHandle id, QueryObjectParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryObjectivARB(id, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryObjectivARB(this GL.ARBExtension glInstance, QueryHandle id, QueryObjectParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryObjectivARB(id, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetQueryObjectivARB(this GL.ARBExtension glInstance, QueryHandle id, QueryObjectParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetQueryObjectivARB(id, pname, parameters_ptr);
            }
        }

        // GetQueryObjectuivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryObjectuivARB(this GL.ARBExtension glInstance, QueryHandle id, QueryObjectParameterName pname, Span<uint> parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryObjectuivARB(id, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryObjectuivARB(this GL.ARBExtension glInstance, QueryHandle id, QueryObjectParameterName pname, uint[] parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryObjectuivARB(id, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetQueryObjectuivARB(this GL.ARBExtension glInstance, QueryHandle id, QueryObjectParameterName pname, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetQueryObjectuivARB(id, pname, parameters_ptr);
            }
        }

        // PointParameterfvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PointParameterfvARB(this GL.ARBExtension glInstance, PointParameterNameARB pname, ReadOnlySpan<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.PointParameterfvARB(pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PointParameterfvARB(this GL.ARBExtension glInstance, PointParameterNameARB pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.PointParameterfvARB(pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void PointParameterfvARB(this GL.ARBExtension glInstance, PointParameterNameARB pname, in float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.PointParameterfvARB(pname, parameters_ptr);
            }
        }

        // GetProgramInterfaceiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramInterfacei(this GL.ARBExtension glInstance, ProgramHandle program, ProgramInterface programInterface, ProgramInterfacePName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramInterfaceiv(program, programInterface, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramInterfacei(this GL.ARBExtension glInstance, ProgramHandle program, ProgramInterface programInterface, ProgramInterfacePName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramInterfaceiv(program, programInterface, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramInterfacei(this GL.ARBExtension glInstance, ProgramHandle program, ProgramInterface programInterface, ProgramInterfacePName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetProgramInterfaceiv(program, programInterface, pname, parameters_ptr);
            }
        }

        // GetProgramResourceIndex overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe uint GetProgramResourceIndex(this GL.ARBExtension glInstance, ProgramHandle program, ProgramInterface programInterface, string name)
        {
            uint returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = glInstance.GetProgramResourceIndex(program, programInterface, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }

        // GetProgramResourceName overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetProgramResourceName(this GL.ARBExtension glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, Span<int> length)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramResourceName(this GL.ARBExtension glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, Span<int> length, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetProgramResourceName(this GL.ARBExtension glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, int[] length)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramResourceName(this GL.ARBExtension glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, int[] length, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetProgramResourceName(this GL.ARBExtension glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, ref int length)
        {
            string name;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramResourceName(this GL.ARBExtension glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, ref int length, out string name)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // GetProgramResourceiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramResourcei(this GL.ARBExtension glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, ReadOnlySpan<ProgramResourceProperty> props, Span<int> length, Span<int> parameters)
        {
            var propCount = (int)(props.Length);
            fixed (ProgramResourceProperty* props_ptr = props) // SpanOrArrayLayer
            {
                fixed (int* length_ptr = length) // SpanOrArrayLayer
                {
                    var count = (int)(parameters.Length);
                    fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
                    {
                        glInstance.GetProgramResourceiv(program, programInterface, index, propCount, props_ptr, count, length_ptr, parameters_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramResourcei(this GL.ARBExtension glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, ProgramResourceProperty[] props, int[] length, int[] parameters)
        {
            var propCount = (int)(props.Length);
            fixed (ProgramResourceProperty* props_ptr = props) // SpanOrArrayLayer
            {
                fixed (int* length_ptr = length) // SpanOrArrayLayer
                {
                    var count = (int)(parameters.Length);
                    fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
                    {
                        glInstance.GetProgramResourceiv(program, programInterface, index, propCount, props_ptr, count, length_ptr, parameters_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramResourcei(this GL.ARBExtension glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, int propCount, in ProgramResourceProperty props, int count, ref int length, ref int parameters)
        {
            fixed (ProgramResourceProperty* props_ptr = &props) // RefInsteadOfPointerLayer
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetProgramResourceiv(program, programInterface, index, propCount, props_ptr, count, length_ptr, parameters_ptr);
            }
        }

        // GetProgramResourceLocation overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe int GetProgramResourceLocation(this GL.ARBExtension glInstance, ProgramHandle program, ProgramInterface programInterface, string name)
        {
            int returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = glInstance.GetProgramResourceLocation(program, programInterface, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }

        // GetProgramResourceLocationIndex overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe int GetProgramResourceLocationIndex(this GL.ARBExtension glInstance, ProgramHandle program, ProgramInterface programInterface, string name)
        {
            int returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = glInstance.GetProgramResourceLocationIndex(program, programInterface, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }

        // GetnTexImageARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetnTexImageARB(this GL.ARBExtension glInstance, TextureTarget target, int level, PixelFormat format, PixelType type, int bufSize, IntPtr img)
        {
            var img_vptr = (void*)img;
            glInstance.GetnTexImageARB(target, level, format, type, bufSize, img_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnTexImageARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int level, PixelFormat format, PixelType type, Span<T1> img)
            where T1 : unmanaged
        {
            var bufSize = (int)(img.Length * sizeof(T1));
            fixed (void* img_ptr = img) // SpanOrArrayLayer
            {
                glInstance.GetnTexImageARB(target, level, format, type, bufSize, img_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnTexImageARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int level, PixelFormat format, PixelType type, T1[] img)
            where T1 : unmanaged
        {
            var bufSize = (int)(img.Length * sizeof(T1));
            fixed (void* img_ptr = img) // SpanOrArrayLayer
            {
                glInstance.GetnTexImageARB(target, level, format, type, bufSize, img_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnTexImageARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int level, PixelFormat format, PixelType type, int bufSize, ref T1 img)
            where T1 : unmanaged
        {
            fixed (void* img_ptr = &img) // RefInsteadOfPointerLayer
            {
                glInstance.GetnTexImageARB(target, level, format, type, bufSize, img_ptr);
            }
        }

        // ReadnPixelsARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ReadnPixelsARB(this GL.ARBExtension glInstance, int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.ReadnPixelsARB(x, y, width, height, format, type, bufSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ReadnPixelsARB<T1>(this GL.ARBExtension glInstance, int x, int y, int width, int height, PixelFormat format, PixelType type, Span<T1> data)
            where T1 : unmanaged
        {
            var bufSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.ReadnPixelsARB(x, y, width, height, format, type, bufSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ReadnPixelsARB<T1>(this GL.ARBExtension glInstance, int x, int y, int width, int height, PixelFormat format, PixelType type, T1[] data)
            where T1 : unmanaged
        {
            var bufSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.ReadnPixelsARB(x, y, width, height, format, type, bufSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ReadnPixelsARB<T1>(this GL.ARBExtension glInstance, int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, ref T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.ReadnPixelsARB(x, y, width, height, format, type, bufSize, data_ptr);
            }
        }

        // GetnCompressedTexImageARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetnCompressedTexImageARB(this GL.ARBExtension glInstance, TextureTarget target, int lod, int bufSize, IntPtr img)
        {
            var img_vptr = (void*)img;
            glInstance.GetnCompressedTexImageARB(target, lod, bufSize, img_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnCompressedTexImageARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int lod, Span<T1> img)
            where T1 : unmanaged
        {
            var bufSize = (int)(img.Length * sizeof(T1));
            fixed (void* img_ptr = img) // SpanOrArrayLayer
            {
                glInstance.GetnCompressedTexImageARB(target, lod, bufSize, img_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnCompressedTexImageARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int lod, T1[] img)
            where T1 : unmanaged
        {
            var bufSize = (int)(img.Length * sizeof(T1));
            fixed (void* img_ptr = img) // SpanOrArrayLayer
            {
                glInstance.GetnCompressedTexImageARB(target, lod, bufSize, img_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnCompressedTexImageARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int lod, int bufSize, ref T1 img)
            where T1 : unmanaged
        {
            fixed (void* img_ptr = &img) // RefInsteadOfPointerLayer
            {
                glInstance.GetnCompressedTexImageARB(target, lod, bufSize, img_ptr);
            }
        }

        // GetnUniformfvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformfvARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, Span<float> parameters)
        {
            var bufSize = (int)(parameters.Length * 4);
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformfvARB(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformfvARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, float[] parameters)
        {
            var bufSize = (int)(parameters.Length * 4);
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformfvARB(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnUniformfvARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, int bufSize, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetnUniformfvARB(program, location, bufSize, parameters_ptr);
            }
        }

        // GetnUniformivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformivARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, Span<int> parameters)
        {
            var bufSize = (int)(parameters.Length * 4);
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformivARB(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformivARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, int[] parameters)
        {
            var bufSize = (int)(parameters.Length * 4);
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformivARB(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnUniformivARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, int bufSize, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetnUniformivARB(program, location, bufSize, parameters_ptr);
            }
        }

        // GetnUniformuivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformuivARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, Span<uint> parameters)
        {
            var bufSize = (int)(parameters.Length * 4);
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformuivARB(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformuivARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, uint[] parameters)
        {
            var bufSize = (int)(parameters.Length * 4);
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformuivARB(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnUniformuivARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, int bufSize, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetnUniformuivARB(program, location, bufSize, parameters_ptr);
            }
        }

        // GetnUniformdvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformdvARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, Span<double> parameters)
        {
            var bufSize = (int)(parameters.Length * 8);
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformdvARB(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformdvARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, double[] parameters)
        {
            var bufSize = (int)(parameters.Length * 8);
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformdvARB(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnUniformdvARB(this GL.ARBExtension glInstance, ProgramHandle program, int location, int bufSize, ref double parameters)
        {
            fixed (double* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetnUniformdvARB(program, location, bufSize, parameters_ptr);
            }
        }

        // GetnMapdvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnMapdvARB(this GL.ARBExtension glInstance, MapTarget target, MapQuery query, Span<double> v)
        {
            var bufSize = (int)(v.Length * 8);
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.GetnMapdvARB(target, query, bufSize, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnMapdvARB(this GL.ARBExtension glInstance, MapTarget target, MapQuery query, double[] v)
        {
            var bufSize = (int)(v.Length * 8);
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.GetnMapdvARB(target, query, bufSize, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnMapdvARB(this GL.ARBExtension glInstance, MapTarget target, MapQuery query, int bufSize, ref double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.GetnMapdvARB(target, query, bufSize, v_ptr);
            }
        }

        // GetnMapfvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnMapfvARB(this GL.ARBExtension glInstance, MapTarget target, MapQuery query, Span<float> v)
        {
            var bufSize = (int)(v.Length);
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.GetnMapfvARB(target, query, bufSize, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnMapfvARB(this GL.ARBExtension glInstance, MapTarget target, MapQuery query, float[] v)
        {
            var bufSize = (int)(v.Length);
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.GetnMapfvARB(target, query, bufSize, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnMapfvARB(this GL.ARBExtension glInstance, MapTarget target, MapQuery query, int bufSize, ref float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.GetnMapfvARB(target, query, bufSize, v_ptr);
            }
        }

        // GetnMapivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnMapivARB(this GL.ARBExtension glInstance, MapTarget target, MapQuery query, Span<int> v)
        {
            var bufSize = (int)(v.Length);
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.GetnMapivARB(target, query, bufSize, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnMapivARB(this GL.ARBExtension glInstance, MapTarget target, MapQuery query, int[] v)
        {
            var bufSize = (int)(v.Length);
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.GetnMapivARB(target, query, bufSize, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnMapivARB(this GL.ARBExtension glInstance, MapTarget target, MapQuery query, int bufSize, ref int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.GetnMapivARB(target, query, bufSize, v_ptr);
            }
        }

        // GetnPixelMapfvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnPixelMapfvARB(this GL.ARBExtension glInstance, PixelMap map, Span<float> values)
        {
            var bufSize = (int)(values.Length * 4);
            fixed (float* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.GetnPixelMapfvARB(map, bufSize, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnPixelMapfvARB(this GL.ARBExtension glInstance, PixelMap map, float[] values)
        {
            var bufSize = (int)(values.Length * 4);
            fixed (float* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.GetnPixelMapfvARB(map, bufSize, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnPixelMapfvARB(this GL.ARBExtension glInstance, PixelMap map, int bufSize, ref float values)
        {
            fixed (float* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                glInstance.GetnPixelMapfvARB(map, bufSize, values_ptr);
            }
        }

        // GetnPixelMapuivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnPixelMapuivARB(this GL.ARBExtension glInstance, PixelMap map, Span<uint> values)
        {
            var bufSize = (int)(values.Length);
            fixed (uint* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.GetnPixelMapuivARB(map, bufSize, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnPixelMapuivARB(this GL.ARBExtension glInstance, PixelMap map, uint[] values)
        {
            var bufSize = (int)(values.Length);
            fixed (uint* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.GetnPixelMapuivARB(map, bufSize, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnPixelMapuivARB(this GL.ARBExtension glInstance, PixelMap map, int bufSize, ref uint values)
        {
            fixed (uint* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                glInstance.GetnPixelMapuivARB(map, bufSize, values_ptr);
            }
        }

        // GetnPixelMapusvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnPixelMapusvARB(this GL.ARBExtension glInstance, PixelMap map, Span<ushort> values)
        {
            var bufSize = (int)(values.Length);
            fixed (ushort* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.GetnPixelMapusvARB(map, bufSize, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnPixelMapusvARB(this GL.ARBExtension glInstance, PixelMap map, ushort[] values)
        {
            var bufSize = (int)(values.Length);
            fixed (ushort* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.GetnPixelMapusvARB(map, bufSize, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnPixelMapusvARB(this GL.ARBExtension glInstance, PixelMap map, int bufSize, ref ushort values)
        {
            fixed (ushort* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                glInstance.GetnPixelMapusvARB(map, bufSize, values_ptr);
            }
        }

        // GetnPolygonStippleARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnPolygonStippleARB(this GL.ARBExtension glInstance, Span<byte> pattern)
        {
            var bufSize = (int)(pattern.Length);
            fixed (byte* pattern_ptr = pattern) // SpanOrArrayLayer
            {
                glInstance.GetnPolygonStippleARB(bufSize, pattern_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnPolygonStippleARB(this GL.ARBExtension glInstance, byte[] pattern)
        {
            var bufSize = (int)(pattern.Length);
            fixed (byte* pattern_ptr = pattern) // SpanOrArrayLayer
            {
                glInstance.GetnPolygonStippleARB(bufSize, pattern_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnPolygonStippleARB(this GL.ARBExtension glInstance, int bufSize, ref byte pattern)
        {
            fixed (byte* pattern_ptr = &pattern) // RefInsteadOfPointerLayer
            {
                glInstance.GetnPolygonStippleARB(bufSize, pattern_ptr);
            }
        }

        // GetnColorTableARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetnColorTableARB(this GL.ARBExtension glInstance, ColorTableTarget target, PixelFormat format, PixelType type, int bufSize, IntPtr table)
        {
            var table_vptr = (void*)table;
            glInstance.GetnColorTableARB(target, format, type, bufSize, table_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnColorTableARB<T1>(this GL.ARBExtension glInstance, ColorTableTarget target, PixelFormat format, PixelType type, Span<T1> table)
            where T1 : unmanaged
        {
            var bufSize = (int)(table.Length * sizeof(T1));
            fixed (void* table_ptr = table) // SpanOrArrayLayer
            {
                glInstance.GetnColorTableARB(target, format, type, bufSize, table_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnColorTableARB<T1>(this GL.ARBExtension glInstance, ColorTableTarget target, PixelFormat format, PixelType type, T1[] table)
            where T1 : unmanaged
        {
            var bufSize = (int)(table.Length * sizeof(T1));
            fixed (void* table_ptr = table) // SpanOrArrayLayer
            {
                glInstance.GetnColorTableARB(target, format, type, bufSize, table_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnColorTableARB<T1>(this GL.ARBExtension glInstance, ColorTableTarget target, PixelFormat format, PixelType type, int bufSize, ref T1 table)
            where T1 : unmanaged
        {
            fixed (void* table_ptr = &table) // RefInsteadOfPointerLayer
            {
                glInstance.GetnColorTableARB(target, format, type, bufSize, table_ptr);
            }
        }

        // GetnConvolutionFilterARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetnConvolutionFilterARB(this GL.ARBExtension glInstance, ConvolutionTarget target, PixelFormat format, PixelType type, int bufSize, IntPtr image)
        {
            var image_vptr = (void*)image;
            glInstance.GetnConvolutionFilterARB(target, format, type, bufSize, image_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnConvolutionFilterARB<T1>(this GL.ARBExtension glInstance, ConvolutionTarget target, PixelFormat format, PixelType type, Span<T1> image)
            where T1 : unmanaged
        {
            var bufSize = (int)(image.Length * sizeof(T1));
            fixed (void* image_ptr = image) // SpanOrArrayLayer
            {
                glInstance.GetnConvolutionFilterARB(target, format, type, bufSize, image_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnConvolutionFilterARB<T1>(this GL.ARBExtension glInstance, ConvolutionTarget target, PixelFormat format, PixelType type, T1[] image)
            where T1 : unmanaged
        {
            var bufSize = (int)(image.Length * sizeof(T1));
            fixed (void* image_ptr = image) // SpanOrArrayLayer
            {
                glInstance.GetnConvolutionFilterARB(target, format, type, bufSize, image_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnConvolutionFilterARB<T1>(this GL.ARBExtension glInstance, ConvolutionTarget target, PixelFormat format, PixelType type, int bufSize, ref T1 image)
            where T1 : unmanaged
        {
            fixed (void* image_ptr = &image) // RefInsteadOfPointerLayer
            {
                glInstance.GetnConvolutionFilterARB(target, format, type, bufSize, image_ptr);
            }
        }

        // GetnSeparableFilterARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetnSeparableFilterARB(this GL.ARBExtension glInstance, SeparableTargetEXT target, PixelFormat format, PixelType type, int rowBufSize, IntPtr row, int columnBufSize, IntPtr column, IntPtr span)
        {
            var row_vptr = (void*)row;
            var column_vptr = (void*)column;
            var span_vptr = (void*)span;
            glInstance.GetnSeparableFilterARB(target, format, type, rowBufSize, row_vptr, columnBufSize, column_vptr, span_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnSeparableFilterARB<T1, T2, T3>(this GL.ARBExtension glInstance, SeparableTargetEXT target, PixelFormat format, PixelType type, Span<T3> row, Span<T2> column, Span<T1> span)
            where T1 : unmanaged
            where T2 : unmanaged
            where T3 : unmanaged
        {
            var rowBufSize = (int)(row.Length * sizeof(T3));
            fixed (void* row_ptr = row) // SpanOrArrayLayer
            {
                var columnBufSize = (int)(column.Length * sizeof(T2));
                fixed (void* column_ptr = column) // SpanOrArrayLayer
                {
                    fixed (void* span_ptr = span) // SpanOrArrayLayer
                    {
                        glInstance.GetnSeparableFilterARB(target, format, type, rowBufSize, row_ptr, columnBufSize, column_ptr, span_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnSeparableFilterARB<T1, T2, T3>(this GL.ARBExtension glInstance, SeparableTargetEXT target, PixelFormat format, PixelType type, T3[] row, T2[] column, T1[] span)
            where T1 : unmanaged
            where T2 : unmanaged
            where T3 : unmanaged
        {
            var rowBufSize = (int)(row.Length * sizeof(T3));
            fixed (void* row_ptr = row) // SpanOrArrayLayer
            {
                var columnBufSize = (int)(column.Length * sizeof(T2));
                fixed (void* column_ptr = column) // SpanOrArrayLayer
                {
                    fixed (void* span_ptr = span) // SpanOrArrayLayer
                    {
                        glInstance.GetnSeparableFilterARB(target, format, type, rowBufSize, row_ptr, columnBufSize, column_ptr, span_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnSeparableFilterARB<T1, T2, T3>(this GL.ARBExtension glInstance, SeparableTargetEXT target, PixelFormat format, PixelType type, int rowBufSize, ref T1 row, int columnBufSize, ref T2 column, ref T3 span)
            where T1 : unmanaged
            where T2 : unmanaged
            where T3 : unmanaged
        {
            fixed (void* row_ptr = &row) // RefInsteadOfPointerLayer
            fixed (void* column_ptr = &column) // RefInsteadOfPointerLayer
            fixed (void* span_ptr = &span) // RefInsteadOfPointerLayer
            {
                glInstance.GetnSeparableFilterARB(target, format, type, rowBufSize, row_ptr, columnBufSize, column_ptr, span_ptr);
            }
        }

        // GetnHistogramARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetnHistogramARB(this GL.ARBExtension glInstance, HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, int bufSize, IntPtr values)
        {
            var values_vptr = (void*)values;
            var reset_byte = (byte)(reset ? 1 : 0);
            glInstance.GetnHistogramARB(target, reset_byte, format, type, bufSize, values_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnHistogramARB<T1>(this GL.ARBExtension glInstance, HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, Span<T1> values)
            where T1 : unmanaged
        {
            var bufSize = (int)(values.Length * sizeof(T1));
            fixed (void* values_ptr = values) // SpanOrArrayLayer
            {
                var reset_byte = (byte)(reset ? 1 : 0);
                glInstance.GetnHistogramARB(target, reset_byte, format, type, bufSize, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnHistogramARB<T1>(this GL.ARBExtension glInstance, HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, T1[] values)
            where T1 : unmanaged
        {
            var bufSize = (int)(values.Length * sizeof(T1));
            fixed (void* values_ptr = values) // SpanOrArrayLayer
            {
                var reset_byte = (byte)(reset ? 1 : 0);
                glInstance.GetnHistogramARB(target, reset_byte, format, type, bufSize, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnHistogramARB<T1>(this GL.ARBExtension glInstance, HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, int bufSize, ref T1 values)
            where T1 : unmanaged
        {
            fixed (void* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                var reset_byte = (byte)(reset ? 1 : 0);
                glInstance.GetnHistogramARB(target, reset_byte, format, type, bufSize, values_ptr);
            }
        }

        // GetnMinmaxARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetnMinmaxARB(this GL.ARBExtension glInstance, MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, int bufSize, IntPtr values)
        {
            var values_vptr = (void*)values;
            var reset_byte = (byte)(reset ? 1 : 0);
            glInstance.GetnMinmaxARB(target, reset_byte, format, type, bufSize, values_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnMinmaxARB<T1>(this GL.ARBExtension glInstance, MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, Span<T1> values)
            where T1 : unmanaged
        {
            var bufSize = (int)(values.Length * sizeof(T1));
            fixed (void* values_ptr = values) // SpanOrArrayLayer
            {
                var reset_byte = (byte)(reset ? 1 : 0);
                glInstance.GetnMinmaxARB(target, reset_byte, format, type, bufSize, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnMinmaxARB<T1>(this GL.ARBExtension glInstance, MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, T1[] values)
            where T1 : unmanaged
        {
            var bufSize = (int)(values.Length * sizeof(T1));
            fixed (void* values_ptr = values) // SpanOrArrayLayer
            {
                var reset_byte = (byte)(reset ? 1 : 0);
                glInstance.GetnMinmaxARB(target, reset_byte, format, type, bufSize, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnMinmaxARB<T1>(this GL.ARBExtension glInstance, MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, int bufSize, ref T1 values)
            where T1 : unmanaged
        {
            fixed (void* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                var reset_byte = (byte)(reset ? 1 : 0);
                glInstance.GetnMinmaxARB(target, reset_byte, format, type, bufSize, values_ptr);
            }
        }

        // FramebufferSampleLocationsfvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void FramebufferSampleLocationsfvARB(this GL.ARBExtension glInstance, FramebufferTarget target, uint start, int count, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.FramebufferSampleLocationsfvARB(target, start, count, v_ptr);
            }
        }

        // NamedFramebufferSampleLocationsfvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void NamedFramebufferSampleLocationsfvARB(this GL.ARBExtension glInstance, FramebufferHandle framebuffer, uint start, int count, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.NamedFramebufferSampleLocationsfvARB(framebuffer, start, count, v_ptr);
            }
        }

        // GenSamplers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe SamplerHandle GenSampler(this GL.ARBExtension glInstance)
        {
            SamplerHandle samplers;
            int count = 1;
            Unsafe.SkipInit(out samplers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            SamplerHandle* samplers_handle = (SamplerHandle*)Unsafe.AsPointer(ref samplers);
            glInstance.GenSamplers(count, samplers_handle);
            return samplers;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void GenSampler(this GL.ARBExtension glInstance, out SamplerHandle samplers)
        {
            int count = 1;
            Unsafe.SkipInit(out samplers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            SamplerHandle* samplers_handle = (SamplerHandle*)Unsafe.AsPointer(ref samplers);
            glInstance.GenSamplers(count, samplers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenSamplers(this GL.ARBExtension glInstance, Span<SamplerHandle> samplers)
        {
            var count = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers) // SpanOrArrayLayer
            {
                glInstance.GenSamplers(count, samplers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenSamplers(this GL.ARBExtension glInstance, SamplerHandle[] samplers)
        {
            var count = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers) // SpanOrArrayLayer
            {
                glInstance.GenSamplers(count, samplers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenSamplers(this GL.ARBExtension glInstance, int count, ref SamplerHandle samplers)
        {
            fixed (SamplerHandle* samplers_ptr = &samplers) // RefInsteadOfPointerLayer
            {
                glInstance.GenSamplers(count, samplers_ptr);
            }
        }

        // DeleteSamplers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void DeleteSampler(this GL.ARBExtension glInstance, in SamplerHandle samplers)
        {
            int count = 1;
            fixed(SamplerHandle* samplers_handle = &samplers) // DeleteOverloadLayer
                glInstance.DeleteSamplers(count, samplers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteSamplers(this GL.ARBExtension glInstance, ReadOnlySpan<SamplerHandle> samplers)
        {
            var count = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers) // SpanOrArrayLayer
            {
                glInstance.DeleteSamplers(count, samplers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteSamplers(this GL.ARBExtension glInstance, SamplerHandle[] samplers)
        {
            var count = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers) // SpanOrArrayLayer
            {
                glInstance.DeleteSamplers(count, samplers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteSamplers(this GL.ARBExtension glInstance, int count, in SamplerHandle samplers)
        {
            fixed (SamplerHandle* samplers_ptr = &samplers) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteSamplers(count, samplers_ptr);
            }
        }

        // SamplerParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SamplerParameteri(this GL.ARBExtension glInstance, SamplerHandle sampler, SamplerParameterI pname, ReadOnlySpan<int> param)
        {
            fixed (int* param_ptr = param) // SpanOrArrayLayer
            {
                glInstance.SamplerParameteriv(sampler, pname, param_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SamplerParameteri(this GL.ARBExtension glInstance, SamplerHandle sampler, SamplerParameterI pname, int[] param)
        {
            fixed (int* param_ptr = param) // SpanOrArrayLayer
            {
                glInstance.SamplerParameteriv(sampler, pname, param_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SamplerParameteri(this GL.ARBExtension glInstance, SamplerHandle sampler, SamplerParameterI pname, in int param)
        {
            fixed (int* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.SamplerParameteriv(sampler, pname, param_ptr);
            }
        }

        // SamplerParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SamplerParameterf(this GL.ARBExtension glInstance, SamplerHandle sampler, SamplerParameterF pname, ReadOnlySpan<float> param)
        {
            fixed (float* param_ptr = param) // SpanOrArrayLayer
            {
                glInstance.SamplerParameterfv(sampler, pname, param_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SamplerParameterf(this GL.ARBExtension glInstance, SamplerHandle sampler, SamplerParameterF pname, float[] param)
        {
            fixed (float* param_ptr = param) // SpanOrArrayLayer
            {
                glInstance.SamplerParameterfv(sampler, pname, param_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SamplerParameterf(this GL.ARBExtension glInstance, SamplerHandle sampler, SamplerParameterF pname, in float param)
        {
            fixed (float* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.SamplerParameterfv(sampler, pname, param_ptr);
            }
        }

        // SamplerParameterIiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SamplerParameterIi(this GL.ARBExtension glInstance, SamplerHandle sampler, SamplerParameterI pname, ReadOnlySpan<int> param)
        {
            fixed (int* param_ptr = param) // SpanOrArrayLayer
            {
                glInstance.SamplerParameterIiv(sampler, pname, param_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SamplerParameterIi(this GL.ARBExtension glInstance, SamplerHandle sampler, SamplerParameterI pname, int[] param)
        {
            fixed (int* param_ptr = param) // SpanOrArrayLayer
            {
                glInstance.SamplerParameterIiv(sampler, pname, param_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SamplerParameterIi(this GL.ARBExtension glInstance, SamplerHandle sampler, SamplerParameterI pname, in int param)
        {
            fixed (int* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.SamplerParameterIiv(sampler, pname, param_ptr);
            }
        }

        // SamplerParameterIuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SamplerParameterIui(this GL.ARBExtension glInstance, SamplerHandle sampler, SamplerParameterI pname, ReadOnlySpan<uint> param)
        {
            fixed (uint* param_ptr = param) // SpanOrArrayLayer
            {
                glInstance.SamplerParameterIuiv(sampler, pname, param_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SamplerParameterIui(this GL.ARBExtension glInstance, SamplerHandle sampler, SamplerParameterI pname, uint[] param)
        {
            fixed (uint* param_ptr = param) // SpanOrArrayLayer
            {
                glInstance.SamplerParameterIuiv(sampler, pname, param_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SamplerParameterIui(this GL.ARBExtension glInstance, SamplerHandle sampler, SamplerParameterI pname, in uint param)
        {
            fixed (uint* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.SamplerParameterIuiv(sampler, pname, param_ptr);
            }
        }

        // GetSamplerParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSamplerParameteri(this GL.ARBExtension glInstance, SamplerHandle sampler, SamplerParameterI pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetSamplerParameteriv(sampler, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSamplerParameteri(this GL.ARBExtension glInstance, SamplerHandle sampler, SamplerParameterI pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetSamplerParameteriv(sampler, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetSamplerParameteri(this GL.ARBExtension glInstance, SamplerHandle sampler, SamplerParameterI pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetSamplerParameteriv(sampler, pname, parameters_ptr);
            }
        }

        // GetSamplerParameterIiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSamplerParameterIi(this GL.ARBExtension glInstance, SamplerHandle sampler, SamplerParameterI pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetSamplerParameterIiv(sampler, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSamplerParameterIi(this GL.ARBExtension glInstance, SamplerHandle sampler, SamplerParameterI pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetSamplerParameterIiv(sampler, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetSamplerParameterIi(this GL.ARBExtension glInstance, SamplerHandle sampler, SamplerParameterI pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetSamplerParameterIiv(sampler, pname, parameters_ptr);
            }
        }

        // GetSamplerParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSamplerParameterf(this GL.ARBExtension glInstance, SamplerHandle sampler, SamplerParameterF pname, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetSamplerParameterfv(sampler, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSamplerParameterf(this GL.ARBExtension glInstance, SamplerHandle sampler, SamplerParameterF pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetSamplerParameterfv(sampler, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetSamplerParameterf(this GL.ARBExtension glInstance, SamplerHandle sampler, SamplerParameterF pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetSamplerParameterfv(sampler, pname, parameters_ptr);
            }
        }

        // GetSamplerParameterIuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSamplerParameterIui(this GL.ARBExtension glInstance, SamplerHandle sampler, SamplerParameterI pname, Span<uint> parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetSamplerParameterIuiv(sampler, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSamplerParameterIui(this GL.ARBExtension glInstance, SamplerHandle sampler, SamplerParameterI pname, uint[] parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetSamplerParameterIuiv(sampler, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetSamplerParameterIui(this GL.ARBExtension glInstance, SamplerHandle sampler, SamplerParameterI pname, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetSamplerParameterIuiv(sampler, pname, parameters_ptr);
            }
        }

        // CreateShaderProgramv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe ProgramHandle CreateShaderProgram(this GL.ARBExtension glInstance, ShaderType type, int count, byte** strings)
        {
            ProgramHandle returnValue;
            returnValue = glInstance.CreateShaderProgramv(type, count, strings);
            return returnValue;
        }

        // DeleteProgramPipelines overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void DeleteProgramPipeline(this GL.ARBExtension glInstance, in ProgramPipelineHandle pipelines)
        {
            int n = 1;
            fixed(ProgramPipelineHandle* pipelines_handle = &pipelines) // DeleteOverloadLayer
                glInstance.DeleteProgramPipelines(n, pipelines_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteProgramPipelines(this GL.ARBExtension glInstance, ReadOnlySpan<ProgramPipelineHandle> pipelines)
        {
            var n = (int)(pipelines.Length);
            fixed (ProgramPipelineHandle* pipelines_ptr = pipelines) // SpanOrArrayLayer
            {
                glInstance.DeleteProgramPipelines(n, pipelines_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteProgramPipelines(this GL.ARBExtension glInstance, ProgramPipelineHandle[] pipelines)
        {
            var n = (int)(pipelines.Length);
            fixed (ProgramPipelineHandle* pipelines_ptr = pipelines) // SpanOrArrayLayer
            {
                glInstance.DeleteProgramPipelines(n, pipelines_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteProgramPipelines(this GL.ARBExtension glInstance, int n, in ProgramPipelineHandle pipelines)
        {
            fixed (ProgramPipelineHandle* pipelines_ptr = &pipelines) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteProgramPipelines(n, pipelines_ptr);
            }
        }

        // GenProgramPipelines overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe ProgramPipelineHandle GenProgramPipeline(this GL.ARBExtension glInstance)
        {
            ProgramPipelineHandle pipelines;
            int n = 1;
            Unsafe.SkipInit(out pipelines);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            ProgramPipelineHandle* pipelines_handle = (ProgramPipelineHandle*)Unsafe.AsPointer(ref pipelines);
            glInstance.GenProgramPipelines(n, pipelines_handle);
            return pipelines;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void GenProgramPipeline(this GL.ARBExtension glInstance, out ProgramPipelineHandle pipelines)
        {
            int n = 1;
            Unsafe.SkipInit(out pipelines);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            ProgramPipelineHandle* pipelines_handle = (ProgramPipelineHandle*)Unsafe.AsPointer(ref pipelines);
            glInstance.GenProgramPipelines(n, pipelines_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenProgramPipelines(this GL.ARBExtension glInstance, Span<ProgramPipelineHandle> pipelines)
        {
            var n = (int)(pipelines.Length);
            fixed (ProgramPipelineHandle* pipelines_ptr = pipelines) // SpanOrArrayLayer
            {
                glInstance.GenProgramPipelines(n, pipelines_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenProgramPipelines(this GL.ARBExtension glInstance, ProgramPipelineHandle[] pipelines)
        {
            var n = (int)(pipelines.Length);
            fixed (ProgramPipelineHandle* pipelines_ptr = pipelines) // SpanOrArrayLayer
            {
                glInstance.GenProgramPipelines(n, pipelines_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenProgramPipelines(this GL.ARBExtension glInstance, int n, ref ProgramPipelineHandle pipelines)
        {
            fixed (ProgramPipelineHandle* pipelines_ptr = &pipelines) // RefInsteadOfPointerLayer
            {
                glInstance.GenProgramPipelines(n, pipelines_ptr);
            }
        }

        // GetProgramPipelineiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramPipelinei(this GL.ARBExtension glInstance, ProgramPipelineHandle pipeline, PipelineParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramPipelineiv(pipeline, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramPipelinei(this GL.ARBExtension glInstance, ProgramPipelineHandle pipeline, PipelineParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramPipelineiv(pipeline, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramPipelinei(this GL.ARBExtension glInstance, ProgramPipelineHandle pipeline, PipelineParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetProgramPipelineiv(pipeline, pname, parameters_ptr);
            }
        }

        // ProgramUniform1iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1iv(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<int> value)
        {
            var count = (int)(value.Length);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1iv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1iv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int[] value)
        {
            var count = (int)(value.Length);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1iv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform1iv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform1iv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform1fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1fv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, float[] value)
        {
            var count = (int)(value.Length);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1fv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform1fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform1fv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform1dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1dv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, double[] value)
        {
            var count = (int)(value.Length);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1dv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform1dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform1dv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform1uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1ui(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<uint> value)
        {
            var count = (int)(value.Length);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1uiv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1ui(this GL.ARBExtension glInstance, ProgramHandle program, int location, uint[] value)
        {
            var count = (int)(value.Length);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1uiv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform1ui(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform1uiv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform2iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2iv(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<int> value)
        {
            var count = (int)(value.Length / 2);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2iv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2iv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2iv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform2iv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform2iv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 2);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2fv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, float[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2fv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform2fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform2fv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 2);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2dv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, double[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2dv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform2dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform2dv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform2uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2ui(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<uint> value)
        {
            var count = (int)(value.Length / 2);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2uiv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2ui(this GL.ARBExtension glInstance, ProgramHandle program, int location, uint[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2uiv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform2ui(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform2uiv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform3iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3iv(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<int> value)
        {
            var count = (int)(value.Length / 3);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3iv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3iv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3iv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform3iv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform3iv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 3);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3fv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, float[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3fv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform3fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform3fv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 3);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3dv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, double[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3dv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform3dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform3dv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform3uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3ui(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<uint> value)
        {
            var count = (int)(value.Length / 3);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3uiv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3ui(this GL.ARBExtension glInstance, ProgramHandle program, int location, uint[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3uiv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform3ui(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform3uiv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform4iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4iv(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<int> value)
        {
            var count = (int)(value.Length / 4);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4iv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4iv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4iv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform4iv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform4iv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 4);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4fv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, float[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4fv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform4fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform4fv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform4dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 4);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4dv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, double[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4dv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform4dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform4dv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform4uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4ui(this GL.ARBExtension glInstance, ProgramHandle program, int location, ReadOnlySpan<uint> value)
        {
            var count = (int)(value.Length / 4);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4uiv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4ui(this GL.ARBExtension glInstance, ProgramHandle program, int location, uint[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4uiv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform4ui(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform4uiv(program, location, count, value_ptr);
            }
        }

        // ProgramUniformMatrix2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 4);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix2fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 9);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 9);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix3fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 16);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 16);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix4fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 4);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix2dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 9);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 9);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix3dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix4dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 16);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 16);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix4dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix2x3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2x3fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 6);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2x3fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 6);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix2x3fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix3x2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3x2fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 6);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3x2fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 6);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix3x2fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix2x4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2x4fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 8);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2x4fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 8);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix2x4fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix4x2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4x2fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 8);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4x2fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 8);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix4x2fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix3x4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3x4fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 12);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3x4fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 12);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix3x4fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix4x3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4x3fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 12);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4x3fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 12);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix4x3fv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix2x3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2x3dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 6);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x3dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2x3dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 6);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x3dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix2x3dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x3dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix3x2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3x2dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 6);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x2dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3x2dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 6);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x2dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix3x2dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x2dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix2x4dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2x4dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 8);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x4dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2x4dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 8);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x4dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix2x4dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x4dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix4x2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4x2dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 8);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x2dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4x2dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 8);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x2dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix4x2dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x2dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix3x4dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3x4dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 12);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x4dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3x4dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 12);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x4dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix3x4dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x4dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix4x3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4x3dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 12);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x3dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4x3dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 12);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x3dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix4x3dv(this GL.ARBExtension glInstance, ProgramHandle program, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x3dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // GetProgramPipelineInfoLog overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetProgramPipelineInfoLog(this GL.ARBExtension glInstance, ProgramPipelineHandle pipeline, int bufSize, Span<int> length)
        {
            string infoLog;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramPipelineInfoLog(this GL.ARBExtension glInstance, ProgramPipelineHandle pipeline, int bufSize, Span<int> length, out string infoLog)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetProgramPipelineInfoLog(this GL.ARBExtension glInstance, ProgramPipelineHandle pipeline, int bufSize, int[] length)
        {
            string infoLog;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramPipelineInfoLog(this GL.ARBExtension glInstance, ProgramPipelineHandle pipeline, int bufSize, int[] length, out string infoLog)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetProgramPipelineInfoLog(this GL.ARBExtension glInstance, ProgramPipelineHandle pipeline, int bufSize, ref int length)
        {
            string infoLog;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramPipelineInfoLog(this GL.ARBExtension glInstance, ProgramPipelineHandle pipeline, int bufSize, ref int length, out string infoLog)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }

        // GetActiveAtomicCounterBufferiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveAtomicCounterBufferi(this GL.ARBExtension glInstance, ProgramHandle program, uint bufferIndex, AtomicCounterBufferPName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetActiveAtomicCounterBufferiv(program, bufferIndex, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveAtomicCounterBufferi(this GL.ARBExtension glInstance, ProgramHandle program, uint bufferIndex, AtomicCounterBufferPName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetActiveAtomicCounterBufferiv(program, bufferIndex, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveAtomicCounterBufferi(this GL.ARBExtension glInstance, ProgramHandle program, uint bufferIndex, AtomicCounterBufferPName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetActiveAtomicCounterBufferiv(program, bufferIndex, pname, parameters_ptr);
            }
        }

        // BindImageTexture overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void BindImageTexture(this GL.ARBExtension glInstance, uint unit, TextureHandle texture, int level, bool layered, int layer, BufferAccessARB access, InternalFormat format)
        {
            var layered_byte = (byte)(layered ? 1 : 0);
            glInstance.BindImageTexture(unit, texture, level, layered_byte, layer, access, format);
        }

        // ShaderSourceARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ShaderSourceARB(this GL.ARBExtension glInstance, GLHandleARB shaderObj, int count, byte** str, ReadOnlySpan<int> length)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                glInstance.ShaderSourceARB(shaderObj, count, str, length_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ShaderSourceARB(this GL.ARBExtension glInstance, GLHandleARB shaderObj, int count, byte** str, int[] length)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                glInstance.ShaderSourceARB(shaderObj, count, str, length_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ShaderSourceARB(this GL.ARBExtension glInstance, GLHandleARB shaderObj, int count, byte** str, in int length)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                glInstance.ShaderSourceARB(shaderObj, count, str, length_ptr);
            }
        }

        // Uniform1fvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1fvARB(this GL.ARBExtension glInstance, int location, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 1);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1fvARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1fvARB(this GL.ARBExtension glInstance, int location, float[] value)
        {
            var count = (int)(value.Length / 1);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1fvARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform1fvARB(this GL.ARBExtension glInstance, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform1fvARB(location, count, value_ptr);
            }
        }

        // Uniform2fvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2fvARB(this GL.ARBExtension glInstance, int location, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 2);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2fvARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2fvARB(this GL.ARBExtension glInstance, int location, float[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2fvARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform2fvARB(this GL.ARBExtension glInstance, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform2fvARB(location, count, value_ptr);
            }
        }

        // Uniform3fvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3fvARB(this GL.ARBExtension glInstance, int location, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 3);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3fvARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3fvARB(this GL.ARBExtension glInstance, int location, float[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3fvARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform3fvARB(this GL.ARBExtension glInstance, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform3fvARB(location, count, value_ptr);
            }
        }

        // Uniform4fvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4fvARB(this GL.ARBExtension glInstance, int location, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 4);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4fvARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4fvARB(this GL.ARBExtension glInstance, int location, float[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4fvARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform4fvARB(this GL.ARBExtension glInstance, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform4fvARB(location, count, value_ptr);
            }
        }

        // Uniform1ivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1ivARB(this GL.ARBExtension glInstance, int location, ReadOnlySpan<int> value)
        {
            var count = (int)(value.Length / 1);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1ivARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1ivARB(this GL.ARBExtension glInstance, int location, int[] value)
        {
            var count = (int)(value.Length / 1);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1ivARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform1ivARB(this GL.ARBExtension glInstance, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform1ivARB(location, count, value_ptr);
            }
        }

        // Uniform2ivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2ivARB(this GL.ARBExtension glInstance, int location, ReadOnlySpan<int> value)
        {
            var count = (int)(value.Length / 2);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2ivARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2ivARB(this GL.ARBExtension glInstance, int location, int[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2ivARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform2ivARB(this GL.ARBExtension glInstance, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform2ivARB(location, count, value_ptr);
            }
        }

        // Uniform3ivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3ivARB(this GL.ARBExtension glInstance, int location, ReadOnlySpan<int> value)
        {
            var count = (int)(value.Length / 3);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3ivARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3ivARB(this GL.ARBExtension glInstance, int location, int[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3ivARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform3ivARB(this GL.ARBExtension glInstance, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform3ivARB(location, count, value_ptr);
            }
        }

        // Uniform4ivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4ivARB(this GL.ARBExtension glInstance, int location, ReadOnlySpan<int> value)
        {
            var count = (int)(value.Length / 4);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4ivARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4ivARB(this GL.ARBExtension glInstance, int location, int[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4ivARB(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform4ivARB(this GL.ARBExtension glInstance, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform4ivARB(location, count, value_ptr);
            }
        }

        // UniformMatrix2fvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2fvARB(this GL.ARBExtension glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 4);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2fvARB(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2fvARB(this GL.ARBExtension glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2fvARB(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix2fvARB(this GL.ARBExtension glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2fvARB(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix3fvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3fvARB(this GL.ARBExtension glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 9);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3fvARB(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3fvARB(this GL.ARBExtension glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 9);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3fvARB(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix3fvARB(this GL.ARBExtension glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3fvARB(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix4fvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4fvARB(this GL.ARBExtension glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 16);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4fvARB(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4fvARB(this GL.ARBExtension glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 16);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4fvARB(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix4fvARB(this GL.ARBExtension glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4fvARB(location, count, transpose_byte, value_ptr);
            }
        }

        // GetObjectParameterfvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetObjectParameterfvARB(this GL.ARBExtension glInstance, GLHandleARB obj, GLEnum pname, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetObjectParameterfvARB(obj, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetObjectParameterfvARB(this GL.ARBExtension glInstance, GLHandleARB obj, GLEnum pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetObjectParameterfvARB(obj, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetObjectParameterfvARB(this GL.ARBExtension glInstance, GLHandleARB obj, GLEnum pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetObjectParameterfvARB(obj, pname, parameters_ptr);
            }
        }

        // GetObjectParameterivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetObjectParameterivARB(this GL.ARBExtension glInstance, GLHandleARB obj, GLEnum pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetObjectParameterivARB(obj, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetObjectParameterivARB(this GL.ARBExtension glInstance, GLHandleARB obj, GLEnum pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetObjectParameterivARB(obj, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetObjectParameterivARB(this GL.ARBExtension glInstance, GLHandleARB obj, GLEnum pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetObjectParameterivARB(obj, pname, parameters_ptr);
            }
        }

        // GetInfoLogARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetInfoLogARB(this GL.ARBExtension glInstance, GLHandleARB obj, int maxLength, Span<int> length)
        {
            string infoLog;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                glInstance.GetInfoLogARB(obj, maxLength, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInfoLogARB(this GL.ARBExtension glInstance, GLHandleARB obj, int maxLength, Span<int> length, out string infoLog)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                glInstance.GetInfoLogARB(obj, maxLength, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetInfoLogARB(this GL.ARBExtension glInstance, GLHandleARB obj, int maxLength, int[] length)
        {
            string infoLog;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                glInstance.GetInfoLogARB(obj, maxLength, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInfoLogARB(this GL.ARBExtension glInstance, GLHandleARB obj, int maxLength, int[] length, out string infoLog)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                glInstance.GetInfoLogARB(obj, maxLength, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetInfoLogARB(this GL.ARBExtension glInstance, GLHandleARB obj, int maxLength, ref int length)
        {
            string infoLog;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                glInstance.GetInfoLogARB(obj, maxLength, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetInfoLogARB(this GL.ARBExtension glInstance, GLHandleARB obj, int maxLength, ref int length, out string infoLog)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                glInstance.GetInfoLogARB(obj, maxLength, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }

        // GetAttachedObjectsARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetAttachedObjectsARB(this GL.ARBExtension glInstance, GLHandleARB containerObj, Span<int> count, Span<GLHandleARB> obj)
        {
            fixed (int* count_ptr = count) // SpanOrArrayLayer
            {
                var maxCount = (int)(obj.Length);
                fixed (GLHandleARB* obj_ptr = obj) // SpanOrArrayLayer
                {
                    glInstance.GetAttachedObjectsARB(containerObj, maxCount, count_ptr, obj_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetAttachedObjectsARB(this GL.ARBExtension glInstance, GLHandleARB containerObj, int[] count, GLHandleARB[] obj)
        {
            fixed (int* count_ptr = count) // SpanOrArrayLayer
            {
                var maxCount = (int)(obj.Length);
                fixed (GLHandleARB* obj_ptr = obj) // SpanOrArrayLayer
                {
                    glInstance.GetAttachedObjectsARB(containerObj, maxCount, count_ptr, obj_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetAttachedObjectsARB(this GL.ARBExtension glInstance, GLHandleARB containerObj, int maxCount, ref int count, ref GLHandleARB obj)
        {
            fixed (int* count_ptr = &count) // RefInsteadOfPointerLayer
            fixed (GLHandleARB* obj_ptr = &obj) // RefInsteadOfPointerLayer
            {
                glInstance.GetAttachedObjectsARB(containerObj, maxCount, count_ptr, obj_ptr);
            }
        }

        // GetUniformLocationARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe int GetUniformLocationARB(this GL.ARBExtension glInstance, GLHandleARB programObj, string name)
        {
            int returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = glInstance.GetUniformLocationARB(programObj, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }

        // GetActiveUniformARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveUniformARB(this GL.ARBExtension glInstance, GLHandleARB programObj, uint index, int maxLength, Span<int> length, Span<int> size, Span<UniformType> type)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (UniformType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                        glInstance.GetActiveUniformARB(programObj, index, maxLength, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniformARB(this GL.ARBExtension glInstance, GLHandleARB programObj, uint index, int maxLength, Span<int> length, Span<int> size, Span<UniformType> type, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (UniformType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                        glInstance.GetActiveUniformARB(programObj, index, maxLength, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveUniformARB(this GL.ARBExtension glInstance, GLHandleARB programObj, uint index, int maxLength, int[] length, int[] size, UniformType[] type)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (UniformType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                        glInstance.GetActiveUniformARB(programObj, index, maxLength, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniformARB(this GL.ARBExtension glInstance, GLHandleARB programObj, uint index, int maxLength, int[] length, int[] size, UniformType[] type, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (UniformType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                        glInstance.GetActiveUniformARB(programObj, index, maxLength, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveUniformARB(this GL.ARBExtension glInstance, GLHandleARB programObj, uint index, int maxLength, ref int length, ref int size, ref UniformType type)
        {
            string name;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (int* size_ptr = &size) // RefInsteadOfPointerLayer
            fixed (UniformType* type_ptr = &type) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                glInstance.GetActiveUniformARB(programObj, index, maxLength, length_ptr, size_ptr, type_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveUniformARB(this GL.ARBExtension glInstance, GLHandleARB programObj, uint index, int maxLength, ref int length, ref int size, ref UniformType type, out string name)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (int* size_ptr = &size) // RefInsteadOfPointerLayer
            fixed (UniformType* type_ptr = &type) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                glInstance.GetActiveUniformARB(programObj, index, maxLength, length_ptr, size_ptr, type_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // GetUniformfvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformfvARB(this GL.ARBExtension glInstance, GLHandleARB programObj, int location, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformfvARB(programObj, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformfvARB(this GL.ARBExtension glInstance, GLHandleARB programObj, int location, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformfvARB(programObj, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetUniformfvARB(this GL.ARBExtension glInstance, GLHandleARB programObj, int location, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetUniformfvARB(programObj, location, parameters_ptr);
            }
        }

        // GetUniformivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformivARB(this GL.ARBExtension glInstance, GLHandleARB programObj, int location, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformivARB(programObj, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformivARB(this GL.ARBExtension glInstance, GLHandleARB programObj, int location, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformivARB(programObj, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetUniformivARB(this GL.ARBExtension glInstance, GLHandleARB programObj, int location, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetUniformivARB(programObj, location, parameters_ptr);
            }
        }

        // GetShaderSourceARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetShaderSourceARB(this GL.ARBExtension glInstance, GLHandleARB obj, int maxLength, Span<int> length)
        {
            string source;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var source_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                glInstance.GetShaderSourceARB(obj, maxLength, length_ptr, source_ptr);
                source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)source_ptr);
            }
            return source;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetShaderSourceARB(this GL.ARBExtension glInstance, GLHandleARB obj, int maxLength, Span<int> length, out string source)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var source_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                glInstance.GetShaderSourceARB(obj, maxLength, length_ptr, source_ptr);
                source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)source_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetShaderSourceARB(this GL.ARBExtension glInstance, GLHandleARB obj, int maxLength, int[] length)
        {
            string source;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var source_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                glInstance.GetShaderSourceARB(obj, maxLength, length_ptr, source_ptr);
                source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)source_ptr);
            }
            return source;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetShaderSourceARB(this GL.ARBExtension glInstance, GLHandleARB obj, int maxLength, int[] length, out string source)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var source_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                glInstance.GetShaderSourceARB(obj, maxLength, length_ptr, source_ptr);
                source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)source_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetShaderSourceARB(this GL.ARBExtension glInstance, GLHandleARB obj, int maxLength, ref int length)
        {
            string source;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var source_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                glInstance.GetShaderSourceARB(obj, maxLength, length_ptr, source_ptr);
                source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)source_ptr);
            }
            return source;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetShaderSourceARB(this GL.ARBExtension glInstance, GLHandleARB obj, int maxLength, ref int length, out string source)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var source_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                glInstance.GetShaderSourceARB(obj, maxLength, length_ptr, source_ptr);
                source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)source_ptr);
            }
        }

        // GetSubroutineUniformLocation overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe int GetSubroutineUniformLocation(this GL.ARBExtension glInstance, ProgramHandle program, ShaderType shadertype, string name)
        {
            int returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = glInstance.GetSubroutineUniformLocation(program, shadertype, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }

        // GetSubroutineIndex overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe uint GetSubroutineIndex(this GL.ARBExtension glInstance, ProgramHandle program, ShaderType shadertype, string name)
        {
            uint returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = glInstance.GetSubroutineIndex(program, shadertype, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }

        // GetActiveSubroutineUniformiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveSubroutineUniformi(this GL.ARBExtension glInstance, ProgramHandle program, ShaderType shadertype, uint index, SubroutineParameterName pname, Span<int> values)
        {
            fixed (int* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.GetActiveSubroutineUniformiv(program, shadertype, index, pname, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveSubroutineUniformi(this GL.ARBExtension glInstance, ProgramHandle program, ShaderType shadertype, uint index, SubroutineParameterName pname, int[] values)
        {
            fixed (int* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.GetActiveSubroutineUniformiv(program, shadertype, index, pname, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveSubroutineUniformi(this GL.ARBExtension glInstance, ProgramHandle program, ShaderType shadertype, uint index, SubroutineParameterName pname, ref int values)
        {
            fixed (int* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                glInstance.GetActiveSubroutineUniformiv(program, shadertype, index, pname, values_ptr);
            }
        }

        // GetActiveSubroutineUniformName overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveSubroutineUniformName(this GL.ARBExtension glInstance, ProgramHandle program, ShaderType shadertype, uint index, int bufSize, Span<int> length)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveSubroutineUniformName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveSubroutineUniformName(this GL.ARBExtension glInstance, ProgramHandle program, ShaderType shadertype, uint index, int bufSize, Span<int> length, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveSubroutineUniformName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveSubroutineUniformName(this GL.ARBExtension glInstance, ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int[] length)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveSubroutineUniformName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveSubroutineUniformName(this GL.ARBExtension glInstance, ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int[] length, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveSubroutineUniformName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveSubroutineUniformName(this GL.ARBExtension glInstance, ProgramHandle program, ShaderType shadertype, uint index, int bufSize, ref int length)
        {
            string name;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveSubroutineUniformName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveSubroutineUniformName(this GL.ARBExtension glInstance, ProgramHandle program, ShaderType shadertype, uint index, int bufSize, ref int length, out string name)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveSubroutineUniformName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // GetActiveSubroutineName overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveSubroutineName(this GL.ARBExtension glInstance, ProgramHandle program, ShaderType shadertype, uint index, int bufSize, Span<int> length)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveSubroutineName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveSubroutineName(this GL.ARBExtension glInstance, ProgramHandle program, ShaderType shadertype, uint index, int bufSize, Span<int> length, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveSubroutineName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveSubroutineName(this GL.ARBExtension glInstance, ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int[] length)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveSubroutineName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveSubroutineName(this GL.ARBExtension glInstance, ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int[] length, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveSubroutineName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveSubroutineName(this GL.ARBExtension glInstance, ProgramHandle program, ShaderType shadertype, uint index, int bufSize, ref int length)
        {
            string name;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveSubroutineName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveSubroutineName(this GL.ARBExtension glInstance, ProgramHandle program, ShaderType shadertype, uint index, int bufSize, ref int length, out string name)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveSubroutineName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // UniformSubroutinesuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformSubroutinesui(this GL.ARBExtension glInstance, ShaderType shadertype, ReadOnlySpan<uint> indices)
        {
            var count = (int)(indices.Length);
            fixed (uint* indices_ptr = indices) // SpanOrArrayLayer
            {
                glInstance.UniformSubroutinesuiv(shadertype, count, indices_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformSubroutinesui(this GL.ARBExtension glInstance, ShaderType shadertype, uint[] indices)
        {
            var count = (int)(indices.Length);
            fixed (uint* indices_ptr = indices) // SpanOrArrayLayer
            {
                glInstance.UniformSubroutinesuiv(shadertype, count, indices_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformSubroutinesui(this GL.ARBExtension glInstance, ShaderType shadertype, int count, in uint indices)
        {
            fixed (uint* indices_ptr = &indices) // RefInsteadOfPointerLayer
            {
                glInstance.UniformSubroutinesuiv(shadertype, count, indices_ptr);
            }
        }

        // GetUniformSubroutineuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformSubroutineui(this GL.ARBExtension glInstance, ShaderType shadertype, int location, Span<uint> parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformSubroutineuiv(shadertype, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformSubroutineui(this GL.ARBExtension glInstance, ShaderType shadertype, int location, uint[] parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformSubroutineuiv(shadertype, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetUniformSubroutineui(this GL.ARBExtension glInstance, ShaderType shadertype, int location, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetUniformSubroutineuiv(shadertype, location, parameters_ptr);
            }
        }

        // GetProgramStageiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramStagei(this GL.ARBExtension glInstance, ProgramHandle program, ShaderType shadertype, ProgramStagePName pname, Span<int> values)
        {
            fixed (int* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.GetProgramStageiv(program, shadertype, pname, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramStagei(this GL.ARBExtension glInstance, ProgramHandle program, ShaderType shadertype, ProgramStagePName pname, int[] values)
        {
            fixed (int* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.GetProgramStageiv(program, shadertype, pname, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramStagei(this GL.ARBExtension glInstance, ProgramHandle program, ShaderType shadertype, ProgramStagePName pname, ref int values)
        {
            fixed (int* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                glInstance.GetProgramStageiv(program, shadertype, pname, values_ptr);
            }
        }

        // NamedStringARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe void NamedStringARB(this GL.ARBExtension glInstance, GLEnum type, int namelen, string name, int stringlen, string str)
        {
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            byte* str_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(str);
            glInstance.NamedStringARB(type, namelen, name_ptr, stringlen, str_ptr);
            Marshal.FreeCoTaskMem((IntPtr)str_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
        }

        // DeleteNamedStringARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe void DeleteNamedStringARB(this GL.ARBExtension glInstance, int namelen, string name)
        {
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            glInstance.DeleteNamedStringARB(namelen, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
        }

        // CompileShaderIncludeARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompileShaderIncludeARB(this GL.ARBExtension glInstance, ShaderHandle shader, int count, byte** path, ReadOnlySpan<int> length)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                glInstance.CompileShaderIncludeARB(shader, count, path, length_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompileShaderIncludeARB(this GL.ARBExtension glInstance, ShaderHandle shader, int count, byte** path, int[] length)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                glInstance.CompileShaderIncludeARB(shader, count, path, length_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CompileShaderIncludeARB(this GL.ARBExtension glInstance, ShaderHandle shader, int count, byte** path, in int length)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                glInstance.CompileShaderIncludeARB(shader, count, path, length_ptr);
            }
        }

        // IsNamedStringARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe byte IsNamedStringARB(this GL.ARBExtension glInstance, int namelen, string name)
        {
            byte returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = glInstance.IsNamedStringARB(namelen, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }

        // GetNamedStringARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetNamedStringARB(this GL.ARBExtension glInstance, int namelen, string name, int bufSize, Span<int> stringlen)
        {
            string str;
            fixed (int* stringlen_ptr = stringlen) // SpanOrArrayLayer
            {
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                var str_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetNamedStringARB(namelen, name_ptr, bufSize, stringlen_ptr, str_ptr);
                str = Marshal.PtrToStringUTF8((IntPtr)str_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)str_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return str;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetNamedStringARB(this GL.ARBExtension glInstance, int namelen, string name, int bufSize, Span<int> stringlen, out string str)
        {
            fixed (int* stringlen_ptr = stringlen) // SpanOrArrayLayer
            {
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                var str_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetNamedStringARB(namelen, name_ptr, bufSize, stringlen_ptr, str_ptr);
                str = Marshal.PtrToStringUTF8((IntPtr)str_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)str_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetNamedStringARB(this GL.ARBExtension glInstance, int namelen, string name, int bufSize, int[] stringlen)
        {
            string str;
            fixed (int* stringlen_ptr = stringlen) // SpanOrArrayLayer
            {
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                var str_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetNamedStringARB(namelen, name_ptr, bufSize, stringlen_ptr, str_ptr);
                str = Marshal.PtrToStringUTF8((IntPtr)str_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)str_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return str;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetNamedStringARB(this GL.ARBExtension glInstance, int namelen, string name, int bufSize, int[] stringlen, out string str)
        {
            fixed (int* stringlen_ptr = stringlen) // SpanOrArrayLayer
            {
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                var str_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetNamedStringARB(namelen, name_ptr, bufSize, stringlen_ptr, str_ptr);
                str = Marshal.PtrToStringUTF8((IntPtr)str_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)str_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetNamedStringARB(this GL.ARBExtension glInstance, int namelen, string name, int bufSize, ref int stringlen)
        {
            string str;
            fixed (int* stringlen_ptr = &stringlen) // RefInsteadOfPointerLayer
            {
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                var str_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetNamedStringARB(namelen, name_ptr, bufSize, stringlen_ptr, str_ptr);
                str = Marshal.PtrToStringUTF8((IntPtr)str_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)str_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return str;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetNamedStringARB(this GL.ARBExtension glInstance, int namelen, string name, int bufSize, ref int stringlen, out string str)
        {
            fixed (int* stringlen_ptr = &stringlen) // RefInsteadOfPointerLayer
            {
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                var str_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetNamedStringARB(namelen, name_ptr, bufSize, stringlen_ptr, str_ptr);
                str = Marshal.PtrToStringUTF8((IntPtr)str_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)str_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // GetNamedStringivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetNamedStringivARB(this GL.ARBExtension glInstance, int namelen, string name, GLEnum pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                glInstance.GetNamedStringivARB(namelen, name_ptr, pname, parameters_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetNamedStringivARB(this GL.ARBExtension glInstance, int namelen, string name, GLEnum pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                glInstance.GetNamedStringivARB(namelen, name_ptr, pname, parameters_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetNamedStringivARB(this GL.ARBExtension glInstance, int namelen, string name, GLEnum pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                glInstance.GetNamedStringivARB(namelen, name_ptr, pname, parameters_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // BufferPageCommitmentARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void BufferPageCommitmentARB(this GL.ARBExtension glInstance, GLEnum target, IntPtr offset, nint size, bool commit)
        {
            var commit_byte = (byte)(commit ? 1 : 0);
            glInstance.BufferPageCommitmentARB(target, offset, size, commit_byte);
        }

        // NamedBufferPageCommitmentEXT overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void NamedBufferPageCommitmentEXT(this GL.ARBExtension glInstance, BufferHandle buffer, IntPtr offset, nint size, bool commit)
        {
            var commit_byte = (byte)(commit ? 1 : 0);
            glInstance.NamedBufferPageCommitmentEXT(buffer, offset, size, commit_byte);
        }

        // NamedBufferPageCommitmentARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void NamedBufferPageCommitmentARB(this GL.ARBExtension glInstance, BufferHandle buffer, IntPtr offset, nint size, bool commit)
        {
            var commit_byte = (byte)(commit ? 1 : 0);
            glInstance.NamedBufferPageCommitmentARB(buffer, offset, size, commit_byte);
        }

        // TexPageCommitmentARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void TexPageCommitmentARB(this GL.ARBExtension glInstance, GLEnum target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, bool commit)
        {
            var commit_byte = (byte)(commit ? 1 : 0);
            glInstance.TexPageCommitmentARB(target, level, xoffset, yoffset, zoffset, width, height, depth, commit_byte);
        }

        // GetInteger64v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInteger64(this GL.ARBExtension glInstance, GetPName pname, Span<long> data)
        {
            fixed (long* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetInteger64v(pname, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInteger64(this GL.ARBExtension glInstance, GetPName pname, long[] data)
        {
            fixed (long* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetInteger64v(pname, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetInteger64(this GL.ARBExtension glInstance, GetPName pname, ref long data)
        {
            fixed (long* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetInteger64v(pname, data_ptr);
            }
        }

        // GetSynciv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSynci(this GL.ARBExtension glInstance, GLSync sync, SyncParameterName pname, Span<int> length, Span<int> values)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var count = (int)(values.Length);
                fixed (int* values_ptr = values) // SpanOrArrayLayer
                {
                    glInstance.GetSynciv(sync, pname, count, length_ptr, values_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSynci(this GL.ARBExtension glInstance, GLSync sync, SyncParameterName pname, int[] length, int[] values)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var count = (int)(values.Length);
                fixed (int* values_ptr = values) // SpanOrArrayLayer
                {
                    glInstance.GetSynciv(sync, pname, count, length_ptr, values_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetSynci(this GL.ARBExtension glInstance, GLSync sync, SyncParameterName pname, int count, ref int length, ref int values)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (int* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                glInstance.GetSynciv(sync, pname, count, length_ptr, values_ptr);
            }
        }

        // PatchParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PatchParameterf(this GL.ARBExtension glInstance, PatchParameterName pname, ReadOnlySpan<float> values)
        {
            fixed (float* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.PatchParameterfv(pname, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PatchParameterf(this GL.ARBExtension glInstance, PatchParameterName pname, float[] values)
        {
            fixed (float* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.PatchParameterfv(pname, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void PatchParameterf(this GL.ARBExtension glInstance, PatchParameterName pname, in float values)
        {
            fixed (float* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                glInstance.PatchParameterfv(pname, values_ptr);
            }
        }

        // CompressedTexImage3DARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void CompressedTexImage3DARB(this GL.ARBExtension glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.CompressedTexImage3DARB(target, level, internalformat, width, height, depth, border, imageSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexImage3DARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexImage3DARB(target, level, internalformat, width, height, depth, border, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexImage3DARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, T1[] data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexImage3DARB(target, level, internalformat, width, height, depth, border, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CompressedTexImage3DARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.CompressedTexImage3DARB(target, level, internalformat, width, height, depth, border, imageSize, data_ptr);
            }
        }

        // CompressedTexImage2DARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void CompressedTexImage2DARB(this GL.ARBExtension glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.CompressedTexImage2DARB(target, level, internalformat, width, height, border, imageSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexImage2DARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexImage2DARB(target, level, internalformat, width, height, border, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexImage2DARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, T1[] data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexImage2DARB(target, level, internalformat, width, height, border, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CompressedTexImage2DARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.CompressedTexImage2DARB(target, level, internalformat, width, height, border, imageSize, data_ptr);
            }
        }

        // CompressedTexImage1DARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void CompressedTexImage1DARB(this GL.ARBExtension glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.CompressedTexImage1DARB(target, level, internalformat, width, border, imageSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexImage1DARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int border, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexImage1DARB(target, level, internalformat, width, border, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexImage1DARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int border, T1[] data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexImage1DARB(target, level, internalformat, width, border, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CompressedTexImage1DARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.CompressedTexImage1DARB(target, level, internalformat, width, border, imageSize, data_ptr);
            }
        }

        // CompressedTexSubImage3DARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void CompressedTexSubImage3DARB(this GL.ARBExtension glInstance, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.CompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexSubImage3DARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexSubImage3DARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, T1[] data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CompressedTexSubImage3DARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.CompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_ptr);
            }
        }

        // CompressedTexSubImage2DARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void CompressedTexSubImage2DARB(this GL.ARBExtension glInstance, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.CompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, format, imageSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexSubImage2DARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, format, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexSubImage2DARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, T1[] data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, format, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CompressedTexSubImage2DARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.CompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, format, imageSize, data_ptr);
            }
        }

        // CompressedTexSubImage1DARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void CompressedTexSubImage1DARB(this GL.ARBExtension glInstance, TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.CompressedTexSubImage1DARB(target, level, xoffset, width, format, imageSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexSubImage1DARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int level, int xoffset, int width, InternalFormat format, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexSubImage1DARB(target, level, xoffset, width, format, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexSubImage1DARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int level, int xoffset, int width, InternalFormat format, T1[] data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexSubImage1DARB(target, level, xoffset, width, format, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CompressedTexSubImage1DARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.CompressedTexSubImage1DARB(target, level, xoffset, width, format, imageSize, data_ptr);
            }
        }

        // GetCompressedTexImageARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetCompressedTexImageARB(this GL.ARBExtension glInstance, TextureTarget target, int level, IntPtr img)
        {
            var img_vptr = (void*)img;
            glInstance.GetCompressedTexImageARB(target, level, img_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetCompressedTexImageARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int level, Span<T1> img)
            where T1 : unmanaged
        {
            fixed (void* img_ptr = img) // SpanOrArrayLayer
            {
                glInstance.GetCompressedTexImageARB(target, level, img_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetCompressedTexImageARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int level, T1[] img)
            where T1 : unmanaged
        {
            fixed (void* img_ptr = img) // SpanOrArrayLayer
            {
                glInstance.GetCompressedTexImageARB(target, level, img_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetCompressedTexImageARB<T1>(this GL.ARBExtension glInstance, TextureTarget target, int level, ref T1 img)
            where T1 : unmanaged
        {
            fixed (void* img_ptr = &img) // RefInsteadOfPointerLayer
            {
                glInstance.GetCompressedTexImageARB(target, level, img_ptr);
            }
        }

        // TexImage2DMultisample overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void TexImage2DMultisample(this GL.ARBExtension glInstance, TextureTarget target, int samples, InternalFormat internalformat, int width, int height, bool fixedsamplelocations)
        {
            var fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
            glInstance.TexImage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations_byte);
        }

        // TexImage3DMultisample overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void TexImage3DMultisample(this GL.ARBExtension glInstance, TextureTarget target, int samples, InternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
        {
            var fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
            glInstance.TexImage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations_byte);
        }

        // GetMultisamplefv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetMultisamplef(this GL.ARBExtension glInstance, GetMultisamplePNameNV pname, uint index, Span<float> val)
        {
            fixed (float* val_ptr = val) // SpanOrArrayLayer
            {
                glInstance.GetMultisamplefv(pname, index, val_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetMultisamplef(this GL.ARBExtension glInstance, GetMultisamplePNameNV pname, uint index, float[] val)
        {
            fixed (float* val_ptr = val) // SpanOrArrayLayer
            {
                glInstance.GetMultisamplefv(pname, index, val_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetMultisamplef(this GL.ARBExtension glInstance, GetMultisamplePNameNV pname, uint index, ref float val)
        {
            fixed (float* val_ptr = &val) // RefInsteadOfPointerLayer
            {
                glInstance.GetMultisamplefv(pname, index, val_ptr);
            }
        }

        // TexStorage2DMultisample overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void TexStorage2DMultisample(this GL.ARBExtension glInstance, TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations)
        {
            var fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
            glInstance.TexStorage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations_byte);
        }

        // TexStorage3DMultisample overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void TexStorage3DMultisample(this GL.ARBExtension glInstance, TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
        {
            var fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
            glInstance.TexStorage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations_byte);
        }

        // GetQueryObjecti64v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryObjecti64(this GL.ARBExtension glInstance, QueryHandle id, QueryObjectParameterName pname, Span<long> parameters)
        {
            fixed (long* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryObjecti64v(id, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryObjecti64(this GL.ARBExtension glInstance, QueryHandle id, QueryObjectParameterName pname, long[] parameters)
        {
            fixed (long* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryObjecti64v(id, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetQueryObjecti64(this GL.ARBExtension glInstance, QueryHandle id, QueryObjectParameterName pname, ref long parameters)
        {
            fixed (long* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetQueryObjecti64v(id, pname, parameters_ptr);
            }
        }

        // GetQueryObjectui64v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryObjectui64(this GL.ARBExtension glInstance, QueryHandle id, QueryObjectParameterName pname, Span<ulong> parameters)
        {
            fixed (ulong* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryObjectui64v(id, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryObjectui64(this GL.ARBExtension glInstance, QueryHandle id, QueryObjectParameterName pname, ulong[] parameters)
        {
            fixed (ulong* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryObjectui64v(id, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetQueryObjectui64(this GL.ARBExtension glInstance, QueryHandle id, QueryObjectParameterName pname, ref ulong parameters)
        {
            fixed (ulong* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetQueryObjectui64v(id, pname, parameters_ptr);
            }
        }

        // DeleteTransformFeedbacks overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void DeleteTransformFeedback(this GL.ARBExtension glInstance, in TransformFeedbackHandle ids)
        {
            int n = 1;
            fixed(TransformFeedbackHandle* ids_handle = &ids) // DeleteOverloadLayer
                glInstance.DeleteTransformFeedbacks(n, ids_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteTransformFeedbacks(this GL.ARBExtension glInstance, ReadOnlySpan<TransformFeedbackHandle> ids)
        {
            var n = (int)(ids.Length);
            fixed (TransformFeedbackHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.DeleteTransformFeedbacks(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteTransformFeedbacks(this GL.ARBExtension glInstance, TransformFeedbackHandle[] ids)
        {
            var n = (int)(ids.Length);
            fixed (TransformFeedbackHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.DeleteTransformFeedbacks(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteTransformFeedbacks(this GL.ARBExtension glInstance, int n, in TransformFeedbackHandle ids)
        {
            fixed (TransformFeedbackHandle* ids_ptr = &ids) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteTransformFeedbacks(n, ids_ptr);
            }
        }

        // GenTransformFeedbacks overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe TransformFeedbackHandle GenTransformFeedback(this GL.ARBExtension glInstance)
        {
            TransformFeedbackHandle ids;
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TransformFeedbackHandle* ids_handle = (TransformFeedbackHandle*)Unsafe.AsPointer(ref ids);
            glInstance.GenTransformFeedbacks(n, ids_handle);
            return ids;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void GenTransformFeedback(this GL.ARBExtension glInstance, out TransformFeedbackHandle ids)
        {
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TransformFeedbackHandle* ids_handle = (TransformFeedbackHandle*)Unsafe.AsPointer(ref ids);
            glInstance.GenTransformFeedbacks(n, ids_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenTransformFeedbacks(this GL.ARBExtension glInstance, Span<TransformFeedbackHandle> ids)
        {
            var n = (int)(ids.Length);
            fixed (TransformFeedbackHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.GenTransformFeedbacks(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenTransformFeedbacks(this GL.ARBExtension glInstance, TransformFeedbackHandle[] ids)
        {
            var n = (int)(ids.Length);
            fixed (TransformFeedbackHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.GenTransformFeedbacks(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenTransformFeedbacks(this GL.ARBExtension glInstance, int n, ref TransformFeedbackHandle ids)
        {
            fixed (TransformFeedbackHandle* ids_ptr = &ids) // RefInsteadOfPointerLayer
            {
                glInstance.GenTransformFeedbacks(n, ids_ptr);
            }
        }

        // GetQueryIndexediv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryIndexedi(this GL.ARBExtension glInstance, QueryTarget target, uint index, QueryParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryIndexediv(target, index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryIndexedi(this GL.ARBExtension glInstance, QueryTarget target, uint index, QueryParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryIndexediv(target, index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetQueryIndexedi(this GL.ARBExtension glInstance, QueryTarget target, uint index, QueryParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetQueryIndexediv(target, index, pname, parameters_ptr);
            }
        }

        // LoadTransposeMatrixfARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void LoadTransposeMatrixfARB(this GL.ARBExtension glInstance, ReadOnlySpan<float> m)
        {
            fixed (float* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.LoadTransposeMatrixfARB(m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void LoadTransposeMatrixfARB(this GL.ARBExtension glInstance, float[] m)
        {
            fixed (float* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.LoadTransposeMatrixfARB(m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void LoadTransposeMatrixfARB(this GL.ARBExtension glInstance, in float m)
        {
            fixed (float* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.LoadTransposeMatrixfARB(m_ptr);
            }
        }

        // LoadTransposeMatrixdARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void LoadTransposeMatrixdARB(this GL.ARBExtension glInstance, ReadOnlySpan<double> m)
        {
            fixed (double* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.LoadTransposeMatrixdARB(m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void LoadTransposeMatrixdARB(this GL.ARBExtension glInstance, double[] m)
        {
            fixed (double* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.LoadTransposeMatrixdARB(m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void LoadTransposeMatrixdARB(this GL.ARBExtension glInstance, in double m)
        {
            fixed (double* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.LoadTransposeMatrixdARB(m_ptr);
            }
        }

        // MultTransposeMatrixfARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultTransposeMatrixfARB(this GL.ARBExtension glInstance, ReadOnlySpan<float> m)
        {
            fixed (float* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MultTransposeMatrixfARB(m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultTransposeMatrixfARB(this GL.ARBExtension glInstance, float[] m)
        {
            fixed (float* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MultTransposeMatrixfARB(m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultTransposeMatrixfARB(this GL.ARBExtension glInstance, in float m)
        {
            fixed (float* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.MultTransposeMatrixfARB(m_ptr);
            }
        }

        // MultTransposeMatrixdARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultTransposeMatrixdARB(this GL.ARBExtension glInstance, ReadOnlySpan<double> m)
        {
            fixed (double* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MultTransposeMatrixdARB(m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultTransposeMatrixdARB(this GL.ARBExtension glInstance, double[] m)
        {
            fixed (double* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MultTransposeMatrixdARB(m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultTransposeMatrixdARB(this GL.ARBExtension glInstance, in double m)
        {
            fixed (double* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.MultTransposeMatrixdARB(m_ptr);
            }
        }

        // GetUniformIndices overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformIndices(this GL.ARBExtension glInstance, ProgramHandle program, int uniformCount, byte** uniformNames, Span<uint> uniformIndices)
        {
            fixed (uint* uniformIndices_ptr = uniformIndices) // SpanOrArrayLayer
            {
                glInstance.GetUniformIndices(program, uniformCount, uniformNames, uniformIndices_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformIndices(this GL.ARBExtension glInstance, ProgramHandle program, int uniformCount, byte** uniformNames, uint[] uniformIndices)
        {
            fixed (uint* uniformIndices_ptr = uniformIndices) // SpanOrArrayLayer
            {
                glInstance.GetUniformIndices(program, uniformCount, uniformNames, uniformIndices_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetUniformIndices(this GL.ARBExtension glInstance, ProgramHandle program, int uniformCount, byte** uniformNames, ref uint uniformIndices)
        {
            fixed (uint* uniformIndices_ptr = &uniformIndices) // RefInsteadOfPointerLayer
            {
                glInstance.GetUniformIndices(program, uniformCount, uniformNames, uniformIndices_ptr);
            }
        }

        // GetActiveUniformsiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniformsi(this GL.ARBExtension glInstance, ProgramHandle program, ReadOnlySpan<uint> uniformIndices, UniformPName pname, Span<int> parameters)
        {
            var uniformCount = (int)(uniformIndices.Length);
            fixed (uint* uniformIndices_ptr = uniformIndices) // SpanOrArrayLayer
            {
                fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
                {
                    glInstance.GetActiveUniformsiv(program, uniformCount, uniformIndices_ptr, pname, parameters_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniformsi(this GL.ARBExtension glInstance, ProgramHandle program, uint[] uniformIndices, UniformPName pname, int[] parameters)
        {
            var uniformCount = (int)(uniformIndices.Length);
            fixed (uint* uniformIndices_ptr = uniformIndices) // SpanOrArrayLayer
            {
                fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
                {
                    glInstance.GetActiveUniformsiv(program, uniformCount, uniformIndices_ptr, pname, parameters_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveUniformsi(this GL.ARBExtension glInstance, ProgramHandle program, int uniformCount, in uint uniformIndices, UniformPName pname, ref int parameters)
        {
            fixed (uint* uniformIndices_ptr = &uniformIndices) // RefInsteadOfPointerLayer
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetActiveUniformsiv(program, uniformCount, uniformIndices_ptr, pname, parameters_ptr);
            }
        }

        // GetActiveUniformName overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveUniformName(this GL.ARBExtension glInstance, ProgramHandle program, uint uniformIndex, int bufSize, Span<int> length)
        {
            string uniformName;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var uniformName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformName(program, uniformIndex, bufSize, length_ptr, uniformName_ptr);
                uniformName = Marshal.PtrToStringUTF8((IntPtr)uniformName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformName_ptr);
            }
            return uniformName;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniformName(this GL.ARBExtension glInstance, ProgramHandle program, uint uniformIndex, int bufSize, Span<int> length, out string uniformName)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var uniformName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformName(program, uniformIndex, bufSize, length_ptr, uniformName_ptr);
                uniformName = Marshal.PtrToStringUTF8((IntPtr)uniformName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformName_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveUniformName(this GL.ARBExtension glInstance, ProgramHandle program, uint uniformIndex, int bufSize, int[] length)
        {
            string uniformName;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var uniformName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformName(program, uniformIndex, bufSize, length_ptr, uniformName_ptr);
                uniformName = Marshal.PtrToStringUTF8((IntPtr)uniformName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformName_ptr);
            }
            return uniformName;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniformName(this GL.ARBExtension glInstance, ProgramHandle program, uint uniformIndex, int bufSize, int[] length, out string uniformName)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var uniformName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformName(program, uniformIndex, bufSize, length_ptr, uniformName_ptr);
                uniformName = Marshal.PtrToStringUTF8((IntPtr)uniformName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformName_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveUniformName(this GL.ARBExtension glInstance, ProgramHandle program, uint uniformIndex, int bufSize, ref int length)
        {
            string uniformName;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var uniformName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformName(program, uniformIndex, bufSize, length_ptr, uniformName_ptr);
                uniformName = Marshal.PtrToStringUTF8((IntPtr)uniformName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformName_ptr);
            }
            return uniformName;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveUniformName(this GL.ARBExtension glInstance, ProgramHandle program, uint uniformIndex, int bufSize, ref int length, out string uniformName)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var uniformName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformName(program, uniformIndex, bufSize, length_ptr, uniformName_ptr);
                uniformName = Marshal.PtrToStringUTF8((IntPtr)uniformName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformName_ptr);
            }
        }

        // GetUniformBlockIndex overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe uint GetUniformBlockIndex(this GL.ARBExtension glInstance, ProgramHandle program, string uniformBlockName)
        {
            uint returnValue;
            byte* uniformBlockName_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(uniformBlockName);
            returnValue = glInstance.GetUniformBlockIndex(program, uniformBlockName_ptr);
            Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            return returnValue;
        }

        // GetActiveUniformBlockiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniformBlocki(this GL.ARBExtension glInstance, ProgramHandle program, uint uniformBlockIndex, UniformBlockPName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetActiveUniformBlockiv(program, uniformBlockIndex, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniformBlocki(this GL.ARBExtension glInstance, ProgramHandle program, uint uniformBlockIndex, UniformBlockPName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetActiveUniformBlockiv(program, uniformBlockIndex, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveUniformBlocki(this GL.ARBExtension glInstance, ProgramHandle program, uint uniformBlockIndex, UniformBlockPName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetActiveUniformBlockiv(program, uniformBlockIndex, pname, parameters_ptr);
            }
        }

        // GetActiveUniformBlockName overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveUniformBlockName(this GL.ARBExtension glInstance, ProgramHandle program, uint uniformBlockIndex, int bufSize, Span<int> length)
        {
            string uniformBlockName;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            }
            return uniformBlockName;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniformBlockName(this GL.ARBExtension glInstance, ProgramHandle program, uint uniformBlockIndex, int bufSize, Span<int> length, out string uniformBlockName)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveUniformBlockName(this GL.ARBExtension glInstance, ProgramHandle program, uint uniformBlockIndex, int bufSize, int[] length)
        {
            string uniformBlockName;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            }
            return uniformBlockName;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniformBlockName(this GL.ARBExtension glInstance, ProgramHandle program, uint uniformBlockIndex, int bufSize, int[] length, out string uniformBlockName)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveUniformBlockName(this GL.ARBExtension glInstance, ProgramHandle program, uint uniformBlockIndex, int bufSize, ref int length)
        {
            string uniformBlockName;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            }
            return uniformBlockName;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveUniformBlockName(this GL.ARBExtension glInstance, ProgramHandle program, uint uniformBlockIndex, int bufSize, ref int length, out string uniformBlockName)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            }
        }

        // GetIntegeri_v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInteger(this GL.ARBExtension glInstance, GetPName target, uint index, Span<int> data)
        {
            fixed (int* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetIntegeri_v(target, index, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInteger(this GL.ARBExtension glInstance, GetPName target, uint index, int[] data)
        {
            fixed (int* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetIntegeri_v(target, index, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetInteger(this GL.ARBExtension glInstance, GetPName target, uint index, ref int data)
        {
            fixed (int* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetIntegeri_v(target, index, data_ptr);
            }
        }

        // DeleteVertexArrays overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void DeleteVertexArray(this GL.ARBExtension glInstance, in VertexArrayHandle arrays)
        {
            int n = 1;
            fixed(VertexArrayHandle* arrays_handle = &arrays) // DeleteOverloadLayer
                glInstance.DeleteVertexArrays(n, arrays_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteVertexArrays(this GL.ARBExtension glInstance, ReadOnlySpan<VertexArrayHandle> arrays)
        {
            var n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays) // SpanOrArrayLayer
            {
                glInstance.DeleteVertexArrays(n, arrays_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteVertexArrays(this GL.ARBExtension glInstance, VertexArrayHandle[] arrays)
        {
            var n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays) // SpanOrArrayLayer
            {
                glInstance.DeleteVertexArrays(n, arrays_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteVertexArrays(this GL.ARBExtension glInstance, int n, in VertexArrayHandle arrays)
        {
            fixed (VertexArrayHandle* arrays_ptr = &arrays) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteVertexArrays(n, arrays_ptr);
            }
        }

        // GenVertexArrays overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe VertexArrayHandle GenVertexArray(this GL.ARBExtension glInstance)
        {
            VertexArrayHandle arrays;
            int n = 1;
            Unsafe.SkipInit(out arrays);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            VertexArrayHandle* arrays_handle = (VertexArrayHandle*)Unsafe.AsPointer(ref arrays);
            glInstance.GenVertexArrays(n, arrays_handle);
            return arrays;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void GenVertexArray(this GL.ARBExtension glInstance, out VertexArrayHandle arrays)
        {
            int n = 1;
            Unsafe.SkipInit(out arrays);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            VertexArrayHandle* arrays_handle = (VertexArrayHandle*)Unsafe.AsPointer(ref arrays);
            glInstance.GenVertexArrays(n, arrays_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenVertexArrays(this GL.ARBExtension glInstance, Span<VertexArrayHandle> arrays)
        {
            var n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays) // SpanOrArrayLayer
            {
                glInstance.GenVertexArrays(n, arrays_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenVertexArrays(this GL.ARBExtension glInstance, VertexArrayHandle[] arrays)
        {
            var n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays) // SpanOrArrayLayer
            {
                glInstance.GenVertexArrays(n, arrays_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenVertexArrays(this GL.ARBExtension glInstance, int n, ref VertexArrayHandle arrays)
        {
            fixed (VertexArrayHandle* arrays_ptr = &arrays) // RefInsteadOfPointerLayer
            {
                glInstance.GenVertexArrays(n, arrays_ptr);
            }
        }

        // VertexAttribL1dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribL1dv(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribL1dv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribL1dv(this GL.ARBExtension glInstance, uint index, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribL1dv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribL1dv(this GL.ARBExtension glInstance, uint index, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttribL1dv(index, v_ptr);
            }
        }

        // VertexAttribL2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribL2dv(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribL2dv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribL2dv(this GL.ARBExtension glInstance, uint index, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribL2dv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribL2dv(this GL.ARBExtension glInstance, uint index, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttribL2dv(index, v_ptr);
            }
        }

        // VertexAttribL3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribL3dv(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribL3dv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribL3dv(this GL.ARBExtension glInstance, uint index, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribL3dv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribL3dv(this GL.ARBExtension glInstance, uint index, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttribL3dv(index, v_ptr);
            }
        }

        // VertexAttribL4dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribL4dv(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribL4dv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribL4dv(this GL.ARBExtension glInstance, uint index, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribL4dv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribL4dv(this GL.ARBExtension glInstance, uint index, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttribL4dv(index, v_ptr);
            }
        }

        // VertexAttribLPointer overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void VertexAttribLPointer(this GL.ARBExtension glInstance, uint index, int size, VertexAttribLType type, int stride, nint offset)
        {
            void* pointer = (void*)offset;
            glInstance.VertexAttribLPointer(index, size, type, stride, pointer);
        }

        // GetVertexAttribLdv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribLd(this GL.ARBExtension glInstance, uint index, VertexAttribEnum pname, Span<double> parameters)
        {
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribLdv(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribLd(this GL.ARBExtension glInstance, uint index, VertexAttribEnum pname, double[] parameters)
        {
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribLdv(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetVertexAttribLd(this GL.ARBExtension glInstance, uint index, VertexAttribEnum pname, ref double parameters)
        {
            fixed (double* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetVertexAttribLdv(index, pname, parameters_ptr);
            }
        }

        // VertexAttribFormat overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void VertexAttribFormat(this GL.ARBExtension glInstance, uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset)
        {
            var normalized_byte = (byte)(normalized ? 1 : 0);
            glInstance.VertexAttribFormat(attribindex, size, type, normalized_byte, relativeoffset);
        }

        // WeightbvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WeightbvARB(this GL.ARBExtension glInstance, ReadOnlySpan<sbyte> weights)
        {
            var size = (int)(weights.Length);
            fixed (sbyte* weights_ptr = weights) // SpanOrArrayLayer
            {
                glInstance.WeightbvARB(size, weights_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WeightbvARB(this GL.ARBExtension glInstance, sbyte[] weights)
        {
            var size = (int)(weights.Length);
            fixed (sbyte* weights_ptr = weights) // SpanOrArrayLayer
            {
                glInstance.WeightbvARB(size, weights_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WeightbvARB(this GL.ARBExtension glInstance, int size, in sbyte weights)
        {
            fixed (sbyte* weights_ptr = &weights) // RefInsteadOfPointerLayer
            {
                glInstance.WeightbvARB(size, weights_ptr);
            }
        }

        // WeightsvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WeightsvARB(this GL.ARBExtension glInstance, ReadOnlySpan<short> weights)
        {
            var size = (int)(weights.Length);
            fixed (short* weights_ptr = weights) // SpanOrArrayLayer
            {
                glInstance.WeightsvARB(size, weights_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WeightsvARB(this GL.ARBExtension glInstance, short[] weights)
        {
            var size = (int)(weights.Length);
            fixed (short* weights_ptr = weights) // SpanOrArrayLayer
            {
                glInstance.WeightsvARB(size, weights_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WeightsvARB(this GL.ARBExtension glInstance, int size, in short weights)
        {
            fixed (short* weights_ptr = &weights) // RefInsteadOfPointerLayer
            {
                glInstance.WeightsvARB(size, weights_ptr);
            }
        }

        // WeightivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WeightivARB(this GL.ARBExtension glInstance, ReadOnlySpan<int> weights)
        {
            var size = (int)(weights.Length);
            fixed (int* weights_ptr = weights) // SpanOrArrayLayer
            {
                glInstance.WeightivARB(size, weights_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WeightivARB(this GL.ARBExtension glInstance, int[] weights)
        {
            var size = (int)(weights.Length);
            fixed (int* weights_ptr = weights) // SpanOrArrayLayer
            {
                glInstance.WeightivARB(size, weights_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WeightivARB(this GL.ARBExtension glInstance, int size, in int weights)
        {
            fixed (int* weights_ptr = &weights) // RefInsteadOfPointerLayer
            {
                glInstance.WeightivARB(size, weights_ptr);
            }
        }

        // WeightfvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WeightfvARB(this GL.ARBExtension glInstance, ReadOnlySpan<float> weights)
        {
            var size = (int)(weights.Length);
            fixed (float* weights_ptr = weights) // SpanOrArrayLayer
            {
                glInstance.WeightfvARB(size, weights_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WeightfvARB(this GL.ARBExtension glInstance, float[] weights)
        {
            var size = (int)(weights.Length);
            fixed (float* weights_ptr = weights) // SpanOrArrayLayer
            {
                glInstance.WeightfvARB(size, weights_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WeightfvARB(this GL.ARBExtension glInstance, int size, in float weights)
        {
            fixed (float* weights_ptr = &weights) // RefInsteadOfPointerLayer
            {
                glInstance.WeightfvARB(size, weights_ptr);
            }
        }

        // WeightdvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WeightdvARB(this GL.ARBExtension glInstance, ReadOnlySpan<double> weights)
        {
            var size = (int)(weights.Length);
            fixed (double* weights_ptr = weights) // SpanOrArrayLayer
            {
                glInstance.WeightdvARB(size, weights_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WeightdvARB(this GL.ARBExtension glInstance, double[] weights)
        {
            var size = (int)(weights.Length);
            fixed (double* weights_ptr = weights) // SpanOrArrayLayer
            {
                glInstance.WeightdvARB(size, weights_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WeightdvARB(this GL.ARBExtension glInstance, int size, in double weights)
        {
            fixed (double* weights_ptr = &weights) // RefInsteadOfPointerLayer
            {
                glInstance.WeightdvARB(size, weights_ptr);
            }
        }

        // WeightubvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WeightubvARB(this GL.ARBExtension glInstance, ReadOnlySpan<byte> weights)
        {
            var size = (int)(weights.Length);
            fixed (byte* weights_ptr = weights) // SpanOrArrayLayer
            {
                glInstance.WeightubvARB(size, weights_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WeightubvARB(this GL.ARBExtension glInstance, byte[] weights)
        {
            var size = (int)(weights.Length);
            fixed (byte* weights_ptr = weights) // SpanOrArrayLayer
            {
                glInstance.WeightubvARB(size, weights_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WeightubvARB(this GL.ARBExtension glInstance, int size, in byte weights)
        {
            fixed (byte* weights_ptr = &weights) // RefInsteadOfPointerLayer
            {
                glInstance.WeightubvARB(size, weights_ptr);
            }
        }

        // WeightusvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WeightusvARB(this GL.ARBExtension glInstance, ReadOnlySpan<ushort> weights)
        {
            var size = (int)(weights.Length);
            fixed (ushort* weights_ptr = weights) // SpanOrArrayLayer
            {
                glInstance.WeightusvARB(size, weights_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WeightusvARB(this GL.ARBExtension glInstance, ushort[] weights)
        {
            var size = (int)(weights.Length);
            fixed (ushort* weights_ptr = weights) // SpanOrArrayLayer
            {
                glInstance.WeightusvARB(size, weights_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WeightusvARB(this GL.ARBExtension glInstance, int size, in ushort weights)
        {
            fixed (ushort* weights_ptr = &weights) // RefInsteadOfPointerLayer
            {
                glInstance.WeightusvARB(size, weights_ptr);
            }
        }

        // WeightuivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WeightuivARB(this GL.ARBExtension glInstance, ReadOnlySpan<uint> weights)
        {
            var size = (int)(weights.Length);
            fixed (uint* weights_ptr = weights) // SpanOrArrayLayer
            {
                glInstance.WeightuivARB(size, weights_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WeightuivARB(this GL.ARBExtension glInstance, uint[] weights)
        {
            var size = (int)(weights.Length);
            fixed (uint* weights_ptr = weights) // SpanOrArrayLayer
            {
                glInstance.WeightuivARB(size, weights_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WeightuivARB(this GL.ARBExtension glInstance, int size, in uint weights)
        {
            fixed (uint* weights_ptr = &weights) // RefInsteadOfPointerLayer
            {
                glInstance.WeightuivARB(size, weights_ptr);
            }
        }

        // WeightPointerARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void WeightPointerARB(this GL.ARBExtension glInstance, int size, WeightPointerTypeARB type, int stride, IntPtr pointer)
        {
            var pointer_vptr = (void*)pointer;
            glInstance.WeightPointerARB(size, type, stride, pointer_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WeightPointerARB<T1>(this GL.ARBExtension glInstance, int size, WeightPointerTypeARB type, int stride, ReadOnlySpan<T1> pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.WeightPointerARB(size, type, stride, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WeightPointerARB<T1>(this GL.ARBExtension glInstance, int size, WeightPointerTypeARB type, int stride, T1[] pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.WeightPointerARB(size, type, stride, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WeightPointerARB<T1>(this GL.ARBExtension glInstance, int size, WeightPointerTypeARB type, int stride, in T1 pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = &pointer) // RefInsteadOfPointerLayer
            {
                glInstance.WeightPointerARB(size, type, stride, pointer_ptr);
            }
        }

        // DeleteBuffersARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteBuffersARB(this GL.ARBExtension glInstance, ReadOnlySpan<BufferHandle> buffers)
        {
            var n = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                glInstance.DeleteBuffersARB(n, buffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteBuffersARB(this GL.ARBExtension glInstance, BufferHandle[] buffers)
        {
            var n = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                glInstance.DeleteBuffersARB(n, buffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteBuffersARB(this GL.ARBExtension glInstance, int n, in BufferHandle buffers)
        {
            fixed (BufferHandle* buffers_ptr = &buffers) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteBuffersARB(n, buffers_ptr);
            }
        }

        // GenBuffersARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenBuffersARB(this GL.ARBExtension glInstance, Span<BufferHandle> buffers)
        {
            var n = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                glInstance.GenBuffersARB(n, buffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenBuffersARB(this GL.ARBExtension glInstance, BufferHandle[] buffers)
        {
            var n = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                glInstance.GenBuffersARB(n, buffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenBuffersARB(this GL.ARBExtension glInstance, int n, ref BufferHandle buffers)
        {
            fixed (BufferHandle* buffers_ptr = &buffers) // RefInsteadOfPointerLayer
            {
                glInstance.GenBuffersARB(n, buffers_ptr);
            }
        }

        // BufferDataARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void BufferDataARB(this GL.ARBExtension glInstance, BufferTargetARB target, nint size, IntPtr data, BufferUsageARB usage)
        {
            var data_vptr = (void*)data;
            glInstance.BufferDataARB(target, size, data_vptr, usage);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BufferDataARB<T1>(this GL.ARBExtension glInstance, BufferTargetARB target, ReadOnlySpan<T1> data, BufferUsageARB usage)
            where T1 : unmanaged
        {
            var size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.BufferDataARB(target, size, data_ptr, usage);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BufferDataARB<T1>(this GL.ARBExtension glInstance, BufferTargetARB target, T1[] data, BufferUsageARB usage)
            where T1 : unmanaged
        {
            var size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.BufferDataARB(target, size, data_ptr, usage);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void BufferDataARB<T1>(this GL.ARBExtension glInstance, BufferTargetARB target, nint size, in T1 data, BufferUsageARB usage)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.BufferDataARB(target, size, data_ptr, usage);
            }
        }

        // BufferSubDataARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void BufferSubDataARB(this GL.ARBExtension glInstance, BufferTargetARB target, IntPtr offset, nint size, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.BufferSubDataARB(target, offset, size, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BufferSubDataARB<T1>(this GL.ARBExtension glInstance, BufferTargetARB target, IntPtr offset, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            var size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.BufferSubDataARB(target, offset, size, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BufferSubDataARB<T1>(this GL.ARBExtension glInstance, BufferTargetARB target, IntPtr offset, T1[] data)
            where T1 : unmanaged
        {
            var size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.BufferSubDataARB(target, offset, size, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void BufferSubDataARB<T1>(this GL.ARBExtension glInstance, BufferTargetARB target, IntPtr offset, nint size, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.BufferSubDataARB(target, offset, size, data_ptr);
            }
        }

        // GetBufferSubDataARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetBufferSubDataARB(this GL.ARBExtension glInstance, BufferTargetARB target, IntPtr offset, nint size, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.GetBufferSubDataARB(target, offset, size, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetBufferSubDataARB<T1>(this GL.ARBExtension glInstance, BufferTargetARB target, IntPtr offset, Span<T1> data)
            where T1 : unmanaged
        {
            var size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetBufferSubDataARB(target, offset, size, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetBufferSubDataARB<T1>(this GL.ARBExtension glInstance, BufferTargetARB target, IntPtr offset, T1[] data)
            where T1 : unmanaged
        {
            var size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetBufferSubDataARB(target, offset, size, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetBufferSubDataARB<T1>(this GL.ARBExtension glInstance, BufferTargetARB target, IntPtr offset, nint size, ref T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetBufferSubDataARB(target, offset, size, data_ptr);
            }
        }

        // GetBufferParameterivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetBufferParameterivARB(this GL.ARBExtension glInstance, BufferTargetARB target, BufferPNameARB pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetBufferParameterivARB(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetBufferParameterivARB(this GL.ARBExtension glInstance, BufferTargetARB target, BufferPNameARB pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetBufferParameterivARB(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetBufferParameterivARB(this GL.ARBExtension glInstance, BufferTargetARB target, BufferPNameARB pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetBufferParameterivARB(target, pname, parameters_ptr);
            }
        }

        // VertexAttrib1dvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib1dvARB(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib1dvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib1dvARB(this GL.ARBExtension glInstance, uint index, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib1dvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib1dvARB(this GL.ARBExtension glInstance, uint index, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib1dvARB(index, v_ptr);
            }
        }

        // VertexAttrib1fvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib1fvARB(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib1fvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib1fvARB(this GL.ARBExtension glInstance, uint index, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib1fvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib1fvARB(this GL.ARBExtension glInstance, uint index, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib1fvARB(index, v_ptr);
            }
        }

        // VertexAttrib1svARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib1svARB(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib1svARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib1svARB(this GL.ARBExtension glInstance, uint index, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib1svARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib1svARB(this GL.ARBExtension glInstance, uint index, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib1svARB(index, v_ptr);
            }
        }

        // VertexAttrib2dvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib2dvARB(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib2dvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib2dvARB(this GL.ARBExtension glInstance, uint index, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib2dvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib2dvARB(this GL.ARBExtension glInstance, uint index, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib2dvARB(index, v_ptr);
            }
        }

        // VertexAttrib2fvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib2fvARB(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib2fvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib2fvARB(this GL.ARBExtension glInstance, uint index, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib2fvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib2fvARB(this GL.ARBExtension glInstance, uint index, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib2fvARB(index, v_ptr);
            }
        }

        // VertexAttrib2svARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib2svARB(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib2svARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib2svARB(this GL.ARBExtension glInstance, uint index, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib2svARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib2svARB(this GL.ARBExtension glInstance, uint index, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib2svARB(index, v_ptr);
            }
        }

        // VertexAttrib3dvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib3dvARB(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib3dvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib3dvARB(this GL.ARBExtension glInstance, uint index, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib3dvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib3dvARB(this GL.ARBExtension glInstance, uint index, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib3dvARB(index, v_ptr);
            }
        }

        // VertexAttrib3fvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib3fvARB(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib3fvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib3fvARB(this GL.ARBExtension glInstance, uint index, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib3fvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib3fvARB(this GL.ARBExtension glInstance, uint index, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib3fvARB(index, v_ptr);
            }
        }

        // VertexAttrib3svARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib3svARB(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib3svARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib3svARB(this GL.ARBExtension glInstance, uint index, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib3svARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib3svARB(this GL.ARBExtension glInstance, uint index, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib3svARB(index, v_ptr);
            }
        }

        // VertexAttrib4NbvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4NbvARB(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<sbyte> v)
        {
            fixed (sbyte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4NbvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4NbvARB(this GL.ARBExtension glInstance, uint index, sbyte[] v)
        {
            fixed (sbyte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4NbvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4NbvARB(this GL.ARBExtension glInstance, uint index, in sbyte v)
        {
            fixed (sbyte* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4NbvARB(index, v_ptr);
            }
        }

        // VertexAttrib4NivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4NivARB(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4NivARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4NivARB(this GL.ARBExtension glInstance, uint index, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4NivARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4NivARB(this GL.ARBExtension glInstance, uint index, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4NivARB(index, v_ptr);
            }
        }

        // VertexAttrib4NsvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4NsvARB(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4NsvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4NsvARB(this GL.ARBExtension glInstance, uint index, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4NsvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4NsvARB(this GL.ARBExtension glInstance, uint index, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4NsvARB(index, v_ptr);
            }
        }

        // VertexAttrib4NubvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4NubvARB(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<byte> v)
        {
            fixed (byte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4NubvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4NubvARB(this GL.ARBExtension glInstance, uint index, byte[] v)
        {
            fixed (byte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4NubvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4NubvARB(this GL.ARBExtension glInstance, uint index, in byte v)
        {
            fixed (byte* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4NubvARB(index, v_ptr);
            }
        }

        // VertexAttrib4NuivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4NuivARB(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<uint> v)
        {
            fixed (uint* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4NuivARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4NuivARB(this GL.ARBExtension glInstance, uint index, uint[] v)
        {
            fixed (uint* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4NuivARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4NuivARB(this GL.ARBExtension glInstance, uint index, in uint v)
        {
            fixed (uint* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4NuivARB(index, v_ptr);
            }
        }

        // VertexAttrib4NusvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4NusvARB(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<ushort> v)
        {
            fixed (ushort* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4NusvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4NusvARB(this GL.ARBExtension glInstance, uint index, ushort[] v)
        {
            fixed (ushort* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4NusvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4NusvARB(this GL.ARBExtension glInstance, uint index, in ushort v)
        {
            fixed (ushort* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4NusvARB(index, v_ptr);
            }
        }

        // VertexAttrib4bvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4bvARB(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<sbyte> v)
        {
            fixed (sbyte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4bvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4bvARB(this GL.ARBExtension glInstance, uint index, sbyte[] v)
        {
            fixed (sbyte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4bvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4bvARB(this GL.ARBExtension glInstance, uint index, in sbyte v)
        {
            fixed (sbyte* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4bvARB(index, v_ptr);
            }
        }

        // VertexAttrib4dvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4dvARB(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4dvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4dvARB(this GL.ARBExtension glInstance, uint index, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4dvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4dvARB(this GL.ARBExtension glInstance, uint index, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4dvARB(index, v_ptr);
            }
        }

        // VertexAttrib4fvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4fvARB(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4fvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4fvARB(this GL.ARBExtension glInstance, uint index, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4fvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4fvARB(this GL.ARBExtension glInstance, uint index, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4fvARB(index, v_ptr);
            }
        }

        // VertexAttrib4ivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4ivARB(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4ivARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4ivARB(this GL.ARBExtension glInstance, uint index, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4ivARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4ivARB(this GL.ARBExtension glInstance, uint index, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4ivARB(index, v_ptr);
            }
        }

        // VertexAttrib4svARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4svARB(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4svARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4svARB(this GL.ARBExtension glInstance, uint index, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4svARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4svARB(this GL.ARBExtension glInstance, uint index, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4svARB(index, v_ptr);
            }
        }

        // VertexAttrib4ubvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4ubvARB(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<byte> v)
        {
            fixed (byte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4ubvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4ubvARB(this GL.ARBExtension glInstance, uint index, byte[] v)
        {
            fixed (byte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4ubvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4ubvARB(this GL.ARBExtension glInstance, uint index, in byte v)
        {
            fixed (byte* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4ubvARB(index, v_ptr);
            }
        }

        // VertexAttrib4uivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4uivARB(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<uint> v)
        {
            fixed (uint* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4uivARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4uivARB(this GL.ARBExtension glInstance, uint index, uint[] v)
        {
            fixed (uint* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4uivARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4uivARB(this GL.ARBExtension glInstance, uint index, in uint v)
        {
            fixed (uint* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4uivARB(index, v_ptr);
            }
        }

        // VertexAttrib4usvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4usvARB(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<ushort> v)
        {
            fixed (ushort* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4usvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4usvARB(this GL.ARBExtension glInstance, uint index, ushort[] v)
        {
            fixed (ushort* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4usvARB(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4usvARB(this GL.ARBExtension glInstance, uint index, in ushort v)
        {
            fixed (ushort* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4usvARB(index, v_ptr);
            }
        }

        // VertexAttribPointerARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void VertexAttribPointerARB(this GL.ARBExtension glInstance, uint index, int size, VertexAttribPointerType type, bool normalized, int stride, IntPtr pointer)
        {
            var pointer_vptr = (void*)pointer;
            var normalized_byte = (byte)(normalized ? 1 : 0);
            glInstance.VertexAttribPointerARB(index, size, type, normalized_byte, stride, pointer_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribPointerARB<T1>(this GL.ARBExtension glInstance, uint index, int size, VertexAttribPointerType type, bool normalized, int stride, ReadOnlySpan<T1> pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribPointerARB(index, size, type, normalized_byte, stride, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribPointerARB<T1>(this GL.ARBExtension glInstance, uint index, int size, VertexAttribPointerType type, bool normalized, int stride, T1[] pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribPointerARB(index, size, type, normalized_byte, stride, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribPointerARB<T1>(this GL.ARBExtension glInstance, uint index, int size, VertexAttribPointerType type, bool normalized, int stride, in T1 pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = &pointer) // RefInsteadOfPointerLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribPointerARB(index, size, type, normalized_byte, stride, pointer_ptr);
            }
        }

        // GetVertexAttribdvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribdvARB(this GL.ARBExtension glInstance, uint index, VertexAttribPropertyARB pname, Span<double> parameters)
        {
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribdvARB(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribdvARB(this GL.ARBExtension glInstance, uint index, VertexAttribPropertyARB pname, double[] parameters)
        {
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribdvARB(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetVertexAttribdvARB(this GL.ARBExtension glInstance, uint index, VertexAttribPropertyARB pname, ref double parameters)
        {
            fixed (double* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetVertexAttribdvARB(index, pname, parameters_ptr);
            }
        }

        // GetVertexAttribfvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribfvARB(this GL.ARBExtension glInstance, uint index, VertexAttribPropertyARB pname, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribfvARB(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribfvARB(this GL.ARBExtension glInstance, uint index, VertexAttribPropertyARB pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribfvARB(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetVertexAttribfvARB(this GL.ARBExtension glInstance, uint index, VertexAttribPropertyARB pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetVertexAttribfvARB(index, pname, parameters_ptr);
            }
        }

        // GetVertexAttribivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribivARB(this GL.ARBExtension glInstance, uint index, VertexAttribPropertyARB pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribivARB(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribivARB(this GL.ARBExtension glInstance, uint index, VertexAttribPropertyARB pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribivARB(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetVertexAttribivARB(this GL.ARBExtension glInstance, uint index, VertexAttribPropertyARB pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetVertexAttribivARB(index, pname, parameters_ptr);
            }
        }

        // BindAttribLocationARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe void BindAttribLocationARB(this GL.ARBExtension glInstance, GLHandleARB programObj, uint index, string name)
        {
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            glInstance.BindAttribLocationARB(programObj, index, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
        }

        // GetActiveAttribARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveAttribARB(this GL.ARBExtension glInstance, GLHandleARB programObj, uint index, int maxLength, Span<int> length, Span<int> size, Span<AttributeType> type)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (AttributeType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                        glInstance.GetActiveAttribARB(programObj, index, maxLength, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveAttribARB(this GL.ARBExtension glInstance, GLHandleARB programObj, uint index, int maxLength, Span<int> length, Span<int> size, Span<AttributeType> type, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (AttributeType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                        glInstance.GetActiveAttribARB(programObj, index, maxLength, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveAttribARB(this GL.ARBExtension glInstance, GLHandleARB programObj, uint index, int maxLength, int[] length, int[] size, AttributeType[] type)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (AttributeType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                        glInstance.GetActiveAttribARB(programObj, index, maxLength, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveAttribARB(this GL.ARBExtension glInstance, GLHandleARB programObj, uint index, int maxLength, int[] length, int[] size, AttributeType[] type, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (AttributeType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                        glInstance.GetActiveAttribARB(programObj, index, maxLength, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveAttribARB(this GL.ARBExtension glInstance, GLHandleARB programObj, uint index, int maxLength, ref int length, ref int size, ref AttributeType type)
        {
            string name;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (int* size_ptr = &size) // RefInsteadOfPointerLayer
            fixed (AttributeType* type_ptr = &type) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                glInstance.GetActiveAttribARB(programObj, index, maxLength, length_ptr, size_ptr, type_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveAttribARB(this GL.ARBExtension glInstance, GLHandleARB programObj, uint index, int maxLength, ref int length, ref int size, ref AttributeType type, out string name)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (int* size_ptr = &size) // RefInsteadOfPointerLayer
            fixed (AttributeType* type_ptr = &type) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                glInstance.GetActiveAttribARB(programObj, index, maxLength, length_ptr, size_ptr, type_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // GetAttribLocationARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe int GetAttribLocationARB(this GL.ARBExtension glInstance, GLHandleARB programObj, string name)
        {
            int returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = glInstance.GetAttribLocationARB(programObj, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }

        // VertexAttribP1ui overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void VertexAttribP1ui(this GL.ARBExtension glInstance, uint index, VertexAttribPointerType type, bool normalized, uint value)
        {
            var normalized_byte = (byte)(normalized ? 1 : 0);
            glInstance.VertexAttribP1ui(index, type, normalized_byte, value);
        }

        // VertexAttribP1uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribP1ui(this GL.ARBExtension glInstance, uint index, VertexAttribPointerType type, bool normalized, ReadOnlySpan<uint> value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribP1uiv(index, type, normalized_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribP1ui(this GL.ARBExtension glInstance, uint index, VertexAttribPointerType type, bool normalized, uint[] value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribP1uiv(index, type, normalized_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribP1ui(this GL.ARBExtension glInstance, uint index, VertexAttribPointerType type, bool normalized, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribP1uiv(index, type, normalized_byte, value_ptr);
            }
        }

        // VertexAttribP2ui overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void VertexAttribP2ui(this GL.ARBExtension glInstance, uint index, VertexAttribPointerType type, bool normalized, uint value)
        {
            var normalized_byte = (byte)(normalized ? 1 : 0);
            glInstance.VertexAttribP2ui(index, type, normalized_byte, value);
        }

        // VertexAttribP2uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribP2ui(this GL.ARBExtension glInstance, uint index, VertexAttribPointerType type, bool normalized, ReadOnlySpan<uint> value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribP2uiv(index, type, normalized_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribP2ui(this GL.ARBExtension glInstance, uint index, VertexAttribPointerType type, bool normalized, uint[] value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribP2uiv(index, type, normalized_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribP2ui(this GL.ARBExtension glInstance, uint index, VertexAttribPointerType type, bool normalized, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribP2uiv(index, type, normalized_byte, value_ptr);
            }
        }

        // VertexAttribP3ui overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void VertexAttribP3ui(this GL.ARBExtension glInstance, uint index, VertexAttribPointerType type, bool normalized, uint value)
        {
            var normalized_byte = (byte)(normalized ? 1 : 0);
            glInstance.VertexAttribP3ui(index, type, normalized_byte, value);
        }

        // VertexAttribP3uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribP3ui(this GL.ARBExtension glInstance, uint index, VertexAttribPointerType type, bool normalized, ReadOnlySpan<uint> value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribP3uiv(index, type, normalized_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribP3ui(this GL.ARBExtension glInstance, uint index, VertexAttribPointerType type, bool normalized, uint[] value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribP3uiv(index, type, normalized_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribP3ui(this GL.ARBExtension glInstance, uint index, VertexAttribPointerType type, bool normalized, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribP3uiv(index, type, normalized_byte, value_ptr);
            }
        }

        // VertexAttribP4ui overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void VertexAttribP4ui(this GL.ARBExtension glInstance, uint index, VertexAttribPointerType type, bool normalized, uint value)
        {
            var normalized_byte = (byte)(normalized ? 1 : 0);
            glInstance.VertexAttribP4ui(index, type, normalized_byte, value);
        }

        // VertexAttribP4uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribP4ui(this GL.ARBExtension glInstance, uint index, VertexAttribPointerType type, bool normalized, ReadOnlySpan<uint> value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribP4uiv(index, type, normalized_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribP4ui(this GL.ARBExtension glInstance, uint index, VertexAttribPointerType type, bool normalized, uint[] value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribP4uiv(index, type, normalized_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribP4ui(this GL.ARBExtension glInstance, uint index, VertexAttribPointerType type, bool normalized, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribP4uiv(index, type, normalized_byte, value_ptr);
            }
        }

        // VertexP2uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexP2ui(this GL.ARBExtension glInstance, VertexPointerType type, ReadOnlySpan<uint> value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.VertexP2uiv(type, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexP2ui(this GL.ARBExtension glInstance, VertexPointerType type, uint[] value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.VertexP2uiv(type, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexP2ui(this GL.ARBExtension glInstance, VertexPointerType type, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.VertexP2uiv(type, value_ptr);
            }
        }

        // VertexP3uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexP3ui(this GL.ARBExtension glInstance, VertexPointerType type, ReadOnlySpan<uint> value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.VertexP3uiv(type, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexP3ui(this GL.ARBExtension glInstance, VertexPointerType type, uint[] value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.VertexP3uiv(type, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexP3ui(this GL.ARBExtension glInstance, VertexPointerType type, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.VertexP3uiv(type, value_ptr);
            }
        }

        // VertexP4uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexP4ui(this GL.ARBExtension glInstance, VertexPointerType type, ReadOnlySpan<uint> value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.VertexP4uiv(type, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexP4ui(this GL.ARBExtension glInstance, VertexPointerType type, uint[] value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.VertexP4uiv(type, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexP4ui(this GL.ARBExtension glInstance, VertexPointerType type, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.VertexP4uiv(type, value_ptr);
            }
        }

        // TexCoordP1uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoordP1ui(this GL.ARBExtension glInstance, TexCoordPointerType type, ReadOnlySpan<uint> coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.TexCoordP1uiv(type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoordP1ui(this GL.ARBExtension glInstance, TexCoordPointerType type, uint[] coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.TexCoordP1uiv(type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoordP1ui(this GL.ARBExtension glInstance, TexCoordPointerType type, in uint coords)
        {
            fixed (uint* coords_ptr = &coords) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoordP1uiv(type, coords_ptr);
            }
        }

        // TexCoordP2uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoordP2ui(this GL.ARBExtension glInstance, TexCoordPointerType type, ReadOnlySpan<uint> coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.TexCoordP2uiv(type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoordP2ui(this GL.ARBExtension glInstance, TexCoordPointerType type, uint[] coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.TexCoordP2uiv(type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoordP2ui(this GL.ARBExtension glInstance, TexCoordPointerType type, in uint coords)
        {
            fixed (uint* coords_ptr = &coords) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoordP2uiv(type, coords_ptr);
            }
        }

        // TexCoordP3uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoordP3ui(this GL.ARBExtension glInstance, TexCoordPointerType type, ReadOnlySpan<uint> coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.TexCoordP3uiv(type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoordP3ui(this GL.ARBExtension glInstance, TexCoordPointerType type, uint[] coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.TexCoordP3uiv(type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoordP3ui(this GL.ARBExtension glInstance, TexCoordPointerType type, in uint coords)
        {
            fixed (uint* coords_ptr = &coords) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoordP3uiv(type, coords_ptr);
            }
        }

        // TexCoordP4uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoordP4ui(this GL.ARBExtension glInstance, TexCoordPointerType type, ReadOnlySpan<uint> coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.TexCoordP4uiv(type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoordP4ui(this GL.ARBExtension glInstance, TexCoordPointerType type, uint[] coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.TexCoordP4uiv(type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoordP4ui(this GL.ARBExtension glInstance, TexCoordPointerType type, in uint coords)
        {
            fixed (uint* coords_ptr = &coords) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoordP4uiv(type, coords_ptr);
            }
        }

        // MultiTexCoordP1uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoordP1ui(this GL.ARBExtension glInstance, TextureUnit texture, TexCoordPointerType type, ReadOnlySpan<uint> coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoordP1uiv(texture, type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoordP1ui(this GL.ARBExtension glInstance, TextureUnit texture, TexCoordPointerType type, uint[] coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoordP1uiv(texture, type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoordP1ui(this GL.ARBExtension glInstance, TextureUnit texture, TexCoordPointerType type, in uint coords)
        {
            fixed (uint* coords_ptr = &coords) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoordP1uiv(texture, type, coords_ptr);
            }
        }

        // MultiTexCoordP2uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoordP2ui(this GL.ARBExtension glInstance, TextureUnit texture, TexCoordPointerType type, ReadOnlySpan<uint> coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoordP2uiv(texture, type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoordP2ui(this GL.ARBExtension glInstance, TextureUnit texture, TexCoordPointerType type, uint[] coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoordP2uiv(texture, type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoordP2ui(this GL.ARBExtension glInstance, TextureUnit texture, TexCoordPointerType type, in uint coords)
        {
            fixed (uint* coords_ptr = &coords) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoordP2uiv(texture, type, coords_ptr);
            }
        }

        // MultiTexCoordP3uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoordP3ui(this GL.ARBExtension glInstance, TextureUnit texture, TexCoordPointerType type, ReadOnlySpan<uint> coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoordP3uiv(texture, type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoordP3ui(this GL.ARBExtension glInstance, TextureUnit texture, TexCoordPointerType type, uint[] coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoordP3uiv(texture, type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoordP3ui(this GL.ARBExtension glInstance, TextureUnit texture, TexCoordPointerType type, in uint coords)
        {
            fixed (uint* coords_ptr = &coords) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoordP3uiv(texture, type, coords_ptr);
            }
        }

        // MultiTexCoordP4uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoordP4ui(this GL.ARBExtension glInstance, TextureUnit texture, TexCoordPointerType type, ReadOnlySpan<uint> coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoordP4uiv(texture, type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoordP4ui(this GL.ARBExtension glInstance, TextureUnit texture, TexCoordPointerType type, uint[] coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoordP4uiv(texture, type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoordP4ui(this GL.ARBExtension glInstance, TextureUnit texture, TexCoordPointerType type, in uint coords)
        {
            fixed (uint* coords_ptr = &coords) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoordP4uiv(texture, type, coords_ptr);
            }
        }

        // NormalP3uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void NormalP3ui(this GL.ARBExtension glInstance, NormalPointerType type, ReadOnlySpan<uint> coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.NormalP3uiv(type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void NormalP3ui(this GL.ARBExtension glInstance, NormalPointerType type, uint[] coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.NormalP3uiv(type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void NormalP3ui(this GL.ARBExtension glInstance, NormalPointerType type, in uint coords)
        {
            fixed (uint* coords_ptr = &coords) // RefInsteadOfPointerLayer
            {
                glInstance.NormalP3uiv(type, coords_ptr);
            }
        }

        // ColorP3uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ColorP3ui(this GL.ARBExtension glInstance, ColorPointerType type, ReadOnlySpan<uint> color)
        {
            fixed (uint* color_ptr = color) // SpanOrArrayLayer
            {
                glInstance.ColorP3uiv(type, color_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ColorP3ui(this GL.ARBExtension glInstance, ColorPointerType type, uint[] color)
        {
            fixed (uint* color_ptr = color) // SpanOrArrayLayer
            {
                glInstance.ColorP3uiv(type, color_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ColorP3ui(this GL.ARBExtension glInstance, ColorPointerType type, in uint color)
        {
            fixed (uint* color_ptr = &color) // RefInsteadOfPointerLayer
            {
                glInstance.ColorP3uiv(type, color_ptr);
            }
        }

        // ColorP4uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ColorP4ui(this GL.ARBExtension glInstance, ColorPointerType type, ReadOnlySpan<uint> color)
        {
            fixed (uint* color_ptr = color) // SpanOrArrayLayer
            {
                glInstance.ColorP4uiv(type, color_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ColorP4ui(this GL.ARBExtension glInstance, ColorPointerType type, uint[] color)
        {
            fixed (uint* color_ptr = color) // SpanOrArrayLayer
            {
                glInstance.ColorP4uiv(type, color_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ColorP4ui(this GL.ARBExtension glInstance, ColorPointerType type, in uint color)
        {
            fixed (uint* color_ptr = &color) // RefInsteadOfPointerLayer
            {
                glInstance.ColorP4uiv(type, color_ptr);
            }
        }

        // SecondaryColorP3uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SecondaryColorP3ui(this GL.ARBExtension glInstance, ColorPointerType type, ReadOnlySpan<uint> color)
        {
            fixed (uint* color_ptr = color) // SpanOrArrayLayer
            {
                glInstance.SecondaryColorP3uiv(type, color_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SecondaryColorP3ui(this GL.ARBExtension glInstance, ColorPointerType type, uint[] color)
        {
            fixed (uint* color_ptr = color) // SpanOrArrayLayer
            {
                glInstance.SecondaryColorP3uiv(type, color_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SecondaryColorP3ui(this GL.ARBExtension glInstance, ColorPointerType type, in uint color)
        {
            fixed (uint* color_ptr = &color) // RefInsteadOfPointerLayer
            {
                glInstance.SecondaryColorP3uiv(type, color_ptr);
            }
        }

        // ViewportArrayv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ViewportArray(this GL.ARBExtension glInstance, uint first, int count, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ViewportArrayv(first, count, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ViewportArray(this GL.ARBExtension glInstance, uint first, int count, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ViewportArrayv(first, count, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ViewportArray(this GL.ARBExtension glInstance, uint first, int count, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.ViewportArrayv(first, count, v_ptr);
            }
        }

        // ViewportIndexedfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ViewportIndexedf(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ViewportIndexedfv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ViewportIndexedf(this GL.ARBExtension glInstance, uint index, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ViewportIndexedfv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ViewportIndexedf(this GL.ARBExtension glInstance, uint index, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.ViewportIndexedfv(index, v_ptr);
            }
        }

        // ScissorArrayv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ScissorArray(this GL.ARBExtension glInstance, uint first, int count, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ScissorArrayv(first, count, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ScissorArray(this GL.ARBExtension glInstance, uint first, int count, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ScissorArrayv(first, count, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ScissorArray(this GL.ARBExtension glInstance, uint first, int count, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.ScissorArrayv(first, count, v_ptr);
            }
        }

        // ScissorIndexedv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ScissorIndexedv(this GL.ARBExtension glInstance, uint index, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ScissorIndexedv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ScissorIndexedv(this GL.ARBExtension glInstance, uint index, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ScissorIndexedv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ScissorIndexedv(this GL.ARBExtension glInstance, uint index, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.ScissorIndexedv(index, v_ptr);
            }
        }

        // DepthRangeArrayv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DepthRangeArray(this GL.ARBExtension glInstance, uint first, int count, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.DepthRangeArrayv(first, count, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DepthRangeArray(this GL.ARBExtension glInstance, uint first, int count, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.DepthRangeArrayv(first, count, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DepthRangeArray(this GL.ARBExtension glInstance, uint first, int count, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.DepthRangeArrayv(first, count, v_ptr);
            }
        }

        // GetFloati_v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetFloat(this GL.ARBExtension glInstance, GetPName target, uint index, Span<float> data)
        {
            fixed (float* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetFloati_v(target, index, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetFloat(this GL.ARBExtension glInstance, GetPName target, uint index, float[] data)
        {
            fixed (float* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetFloati_v(target, index, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetFloat(this GL.ARBExtension glInstance, GetPName target, uint index, ref float data)
        {
            fixed (float* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetFloati_v(target, index, data_ptr);
            }
        }

        // GetDoublei_v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetDouble(this GL.ARBExtension glInstance, GetPName target, uint index, Span<double> data)
        {
            fixed (double* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetDoublei_v(target, index, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetDouble(this GL.ARBExtension glInstance, GetPName target, uint index, double[] data)
        {
            fixed (double* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetDoublei_v(target, index, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetDouble(this GL.ARBExtension glInstance, GetPName target, uint index, ref double data)
        {
            fixed (double* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetDoublei_v(target, index, data_ptr);
            }
        }

        // DepthRangeArraydvNV overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DepthRangeArraydvNV(this GL.ARBExtension glInstance, uint first, int count, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.DepthRangeArraydvNV(first, count, v_ptr);
            }
        }

        // WindowPos2dvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos2dvARB(this GL.ARBExtension glInstance, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos2dvARB(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos2dvARB(this GL.ARBExtension glInstance, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos2dvARB(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WindowPos2dvARB(this GL.ARBExtension glInstance, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.WindowPos2dvARB(v_ptr);
            }
        }

        // WindowPos2fvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos2fvARB(this GL.ARBExtension glInstance, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos2fvARB(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos2fvARB(this GL.ARBExtension glInstance, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos2fvARB(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WindowPos2fvARB(this GL.ARBExtension glInstance, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.WindowPos2fvARB(v_ptr);
            }
        }

        // WindowPos2ivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos2ivARB(this GL.ARBExtension glInstance, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos2ivARB(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos2ivARB(this GL.ARBExtension glInstance, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos2ivARB(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WindowPos2ivARB(this GL.ARBExtension glInstance, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.WindowPos2ivARB(v_ptr);
            }
        }

        // WindowPos2svARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos2svARB(this GL.ARBExtension glInstance, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos2svARB(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos2svARB(this GL.ARBExtension glInstance, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos2svARB(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WindowPos2svARB(this GL.ARBExtension glInstance, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.WindowPos2svARB(v_ptr);
            }
        }

        // WindowPos3dvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos3dvARB(this GL.ARBExtension glInstance, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos3dvARB(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos3dvARB(this GL.ARBExtension glInstance, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos3dvARB(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WindowPos3dvARB(this GL.ARBExtension glInstance, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.WindowPos3dvARB(v_ptr);
            }
        }

        // WindowPos3fvARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos3fvARB(this GL.ARBExtension glInstance, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos3fvARB(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos3fvARB(this GL.ARBExtension glInstance, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos3fvARB(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WindowPos3fvARB(this GL.ARBExtension glInstance, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.WindowPos3fvARB(v_ptr);
            }
        }

        // WindowPos3ivARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos3ivARB(this GL.ARBExtension glInstance, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos3ivARB(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos3ivARB(this GL.ARBExtension glInstance, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos3ivARB(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WindowPos3ivARB(this GL.ARBExtension glInstance, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.WindowPos3ivARB(v_ptr);
            }
        }

        // WindowPos3svARB overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos3svARB(this GL.ARBExtension glInstance, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos3svARB(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos3svARB(this GL.ARBExtension glInstance, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos3svARB(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WindowPos3svARB(this GL.ARBExtension glInstance, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.WindowPos3svARB(v_ptr);
            }
        }
    }

#pragma warning restore IDE1006 // Naming Styles
}
