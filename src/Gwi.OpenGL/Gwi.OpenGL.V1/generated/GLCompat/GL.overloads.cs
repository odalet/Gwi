// This file is auto generated, do not edit.
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Gwi.OpenGL.GLCompat
{
#pragma warning disable IDE1006 // Naming Styles

    public static class GLOverloads
    {
        // TexParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexParameterf(this GL glInstance, TextureTarget target, TextureParameterName pname, ReadOnlySpan<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexParameterfv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexParameterf(this GL glInstance, TextureTarget target, TextureParameterName pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexParameterfv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexParameterf(this GL glInstance, TextureTarget target, TextureParameterName pname, in float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.TexParameterfv(target, pname, parameters_ptr);
            }
        }

        // TexParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexParameteri(this GL glInstance, TextureTarget target, TextureParameterName pname, ReadOnlySpan<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexParameteri(this GL glInstance, TextureTarget target, TextureParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexParameteri(this GL glInstance, TextureTarget target, TextureParameterName pname, in int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.TexParameteriv(target, pname, parameters_ptr);
            }
        }

        // TexImage1D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void TexImage1D(this GL glInstance, TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.TexImage1D(target, level, internalformat, width, border, format, type, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexImage1D<T1>(this GL glInstance, TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.TexImage1D(target, level, internalformat, width, border, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexImage1D<T1>(this GL glInstance, TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, T1[] pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.TexImage1D(target, level, internalformat, width, border, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexImage1D<T1>(this GL glInstance, TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.TexImage1D(target, level, internalformat, width, border, format, type, pixels_ptr);
            }
        }

        // TexImage2D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void TexImage2D(this GL glInstance, TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.TexImage2D(target, level, internalformat, width, height, border, format, type, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexImage2D<T1>(this GL glInstance, TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.TexImage2D(target, level, internalformat, width, height, border, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexImage2D<T1>(this GL glInstance, TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, T1[] pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.TexImage2D(target, level, internalformat, width, height, border, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexImage2D<T1>(this GL glInstance, TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.TexImage2D(target, level, internalformat, width, height, border, format, type, pixels_ptr);
            }
        }

        // ColorMask overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void ColorMask(this GL glInstance, bool red, bool green, bool blue, bool alpha)
        {
            var red_byte = (byte)(red ? 1 : 0);
            var green_byte = (byte)(green ? 1 : 0);
            var blue_byte = (byte)(blue ? 1 : 0);
            var alpha_byte = (byte)(alpha ? 1 : 0);
            glInstance.ColorMask(red_byte, green_byte, blue_byte, alpha_byte);
        }

        // DepthMask overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void DepthMask(this GL glInstance, bool flag)
        {
            var flag_byte = (byte)(flag ? 1 : 0);
            glInstance.DepthMask(flag_byte);
        }

        // ReadPixels overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ReadPixels(this GL glInstance, int x, int y, int width, int height, PixelFormat format, PixelType type, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.ReadPixels(x, y, width, height, format, type, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ReadPixels<T1>(this GL glInstance, int x, int y, int width, int height, PixelFormat format, PixelType type, Span<T1> pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.ReadPixels(x, y, width, height, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ReadPixels<T1>(this GL glInstance, int x, int y, int width, int height, PixelFormat format, PixelType type, T1[] pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.ReadPixels(x, y, width, height, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ReadPixels<T1>(this GL glInstance, int x, int y, int width, int height, PixelFormat format, PixelType type, ref T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.ReadPixels(x, y, width, height, format, type, pixels_ptr);
            }
        }

        // GetBooleanv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetBoolean(this GL glInstance, GetPName pname, Span<byte> data)
        {
            fixed (byte* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetBooleanv(pname, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetBoolean(this GL glInstance, GetPName pname, byte[] data)
        {
            fixed (byte* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetBooleanv(pname, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetBoolean(this GL glInstance, GetPName pname, ref byte data)
        {
            fixed (byte* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetBooleanv(pname, data_ptr);
            }
        }

        // GetDoublev overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetDouble(this GL glInstance, GetPName pname, Span<double> data)
        {
            fixed (double* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetDoublev(pname, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetDouble(this GL glInstance, GetPName pname, double[] data)
        {
            fixed (double* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetDoublev(pname, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetDouble(this GL glInstance, GetPName pname, ref double data)
        {
            fixed (double* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetDoublev(pname, data_ptr);
            }
        }

        // GetFloatv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetFloat(this GL glInstance, GetPName pname, Span<float> data)
        {
            fixed (float* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetFloatv(pname, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetFloat(this GL glInstance, GetPName pname, float[] data)
        {
            fixed (float* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetFloatv(pname, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetFloat(this GL glInstance, GetPName pname, ref float data)
        {
            fixed (float* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetFloatv(pname, data_ptr);
            }
        }

        // GetIntegerv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInteger(this GL glInstance, GetPName pname, Span<int> data)
        {
            fixed (int* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetIntegerv(pname, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInteger(this GL glInstance, GetPName pname, int[] data)
        {
            fixed (int* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetIntegerv(pname, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetInteger(this GL glInstance, GetPName pname, ref int data)
        {
            fixed (int* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetIntegerv(pname, data_ptr);
            }
        }

        // GetString_ overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.StringReturnOverloader
        public static unsafe string? GetString(this GL glInstance, StringName name)
        {
            byte* returnValue;
            string? returnValue_str;
            returnValue = glInstance.GetString_(name);
            returnValue_str = Marshaller.PtrToString((nint)returnValue);
            return returnValue_str;
        }

        // GetTexImage overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetTexImage(this GL glInstance, TextureTarget target, int level, PixelFormat format, PixelType type, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.GetTexImage(target, level, format, type, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexImage<T1>(this GL glInstance, TextureTarget target, int level, PixelFormat format, PixelType type, Span<T1> pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.GetTexImage(target, level, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexImage<T1>(this GL glInstance, TextureTarget target, int level, PixelFormat format, PixelType type, T1[] pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.GetTexImage(target, level, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTexImage<T1>(this GL glInstance, TextureTarget target, int level, PixelFormat format, PixelType type, ref T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.GetTexImage(target, level, format, type, pixels_ptr);
            }
        }

        // GetTexParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexParameterf(this GL glInstance, TextureTarget target, GetTextureParameter pname, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexParameterfv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexParameterf(this GL glInstance, TextureTarget target, GetTextureParameter pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexParameterfv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTexParameterf(this GL glInstance, TextureTarget target, GetTextureParameter pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTexParameterfv(target, pname, parameters_ptr);
            }
        }

        // GetTexParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexParameteri(this GL glInstance, TextureTarget target, GetTextureParameter pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexParameteri(this GL glInstance, TextureTarget target, GetTextureParameter pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTexParameteri(this GL glInstance, TextureTarget target, GetTextureParameter pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTexParameteriv(target, pname, parameters_ptr);
            }
        }

        // GetTexLevelParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexLevelParameterf(this GL glInstance, TextureTarget target, int level, GetTextureParameter pname, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexLevelParameterfv(target, level, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexLevelParameterf(this GL glInstance, TextureTarget target, int level, GetTextureParameter pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexLevelParameterfv(target, level, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTexLevelParameterf(this GL glInstance, TextureTarget target, int level, GetTextureParameter pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTexLevelParameterfv(target, level, pname, parameters_ptr);
            }
        }

        // GetTexLevelParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexLevelParameteri(this GL glInstance, TextureTarget target, int level, GetTextureParameter pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexLevelParameteriv(target, level, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexLevelParameteri(this GL glInstance, TextureTarget target, int level, GetTextureParameter pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexLevelParameteriv(target, level, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTexLevelParameteri(this GL glInstance, TextureTarget target, int level, GetTextureParameter pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTexLevelParameteriv(target, level, pname, parameters_ptr);
            }
        }

        // CallLists overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void CallLists(this GL glInstance, int n, ListNameType type, IntPtr lists)
        {
            var lists_vptr = (void*)lists;
            glInstance.CallLists(n, type, lists_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CallLists<T1>(this GL glInstance, int n, ListNameType type, ReadOnlySpan<T1> lists)
            where T1 : unmanaged
        {
            fixed (void* lists_ptr = lists) // SpanOrArrayLayer
            {
                glInstance.CallLists(n, type, lists_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CallLists<T1>(this GL glInstance, int n, ListNameType type, T1[] lists)
            where T1 : unmanaged
        {
            fixed (void* lists_ptr = lists) // SpanOrArrayLayer
            {
                glInstance.CallLists(n, type, lists_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CallLists<T1>(this GL glInstance, int n, ListNameType type, in T1 lists)
            where T1 : unmanaged
        {
            fixed (void* lists_ptr = &lists) // RefInsteadOfPointerLayer
            {
                glInstance.CallLists(n, type, lists_ptr);
            }
        }

        // Bitmap overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Bitmap(this GL glInstance, int width, int height, float xorig, float yorig, float xmove, float ymove, ReadOnlySpan<byte> bitmap)
        {
            fixed (byte* bitmap_ptr = bitmap) // SpanOrArrayLayer
            {
                glInstance.Bitmap(width, height, xorig, yorig, xmove, ymove, bitmap_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Bitmap(this GL glInstance, int width, int height, float xorig, float yorig, float xmove, float ymove, byte[] bitmap)
        {
            fixed (byte* bitmap_ptr = bitmap) // SpanOrArrayLayer
            {
                glInstance.Bitmap(width, height, xorig, yorig, xmove, ymove, bitmap_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Bitmap(this GL glInstance, int width, int height, float xorig, float yorig, float xmove, float ymove, in byte bitmap)
        {
            fixed (byte* bitmap_ptr = &bitmap) // RefInsteadOfPointerLayer
            {
                glInstance.Bitmap(width, height, xorig, yorig, xmove, ymove, bitmap_ptr);
            }
        }

        // Color3b overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void Color3(this GL glInstance, sbyte red, sbyte green, sbyte blue) =>
            glInstance.Color3b(red, green, blue);

        // Color3bv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color3(this GL glInstance, ReadOnlySpan<sbyte> v)
        {
            fixed (sbyte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color3bv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color3(this GL glInstance, sbyte[] v)
        {
            fixed (sbyte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color3bv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Color3(this GL glInstance, in sbyte v)
        {
            fixed (sbyte* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Color3bv(v_ptr);
            }
        }

        // Color3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color3dv(this GL glInstance, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color3dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color3dv(this GL glInstance, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color3dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Color3dv(this GL glInstance, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Color3dv(v_ptr);
            }
        }

        // Color3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color3fv(this GL glInstance, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color3fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color3fv(this GL glInstance, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color3fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Color3fv(this GL glInstance, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Color3fv(v_ptr);
            }
        }

        // Color3iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color3iv(this GL glInstance, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color3iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color3iv(this GL glInstance, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color3iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Color3iv(this GL glInstance, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Color3iv(v_ptr);
            }
        }

        // Color3s overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void Color3(this GL glInstance, short red, short green, short blue) =>
            glInstance.Color3s(red, green, blue);

        // Color3sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color3(this GL glInstance, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color3sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color3(this GL glInstance, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color3sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Color3(this GL glInstance, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Color3sv(v_ptr);
            }
        }

        // Color3ub overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void Color3(this GL glInstance, byte red, byte green, byte blue) =>
            glInstance.Color3ub(red, green, blue);

        // Color3ubv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color3(this GL glInstance, ReadOnlySpan<byte> v)
        {
            fixed (byte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color3ubv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color3(this GL glInstance, byte[] v)
        {
            fixed (byte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color3ubv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Color3(this GL glInstance, in byte v)
        {
            fixed (byte* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Color3ubv(v_ptr);
            }
        }

        // Color3uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color3ui(this GL glInstance, ReadOnlySpan<uint> v)
        {
            fixed (uint* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color3uiv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color3ui(this GL glInstance, uint[] v)
        {
            fixed (uint* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color3uiv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Color3ui(this GL glInstance, in uint v)
        {
            fixed (uint* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Color3uiv(v_ptr);
            }
        }

        // Color3us overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void Color3(this GL glInstance, ushort red, ushort green, ushort blue) =>
            glInstance.Color3us(red, green, blue);

        // Color3usv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color3(this GL glInstance, ReadOnlySpan<ushort> v)
        {
            fixed (ushort* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color3usv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color3(this GL glInstance, ushort[] v)
        {
            fixed (ushort* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color3usv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Color3(this GL glInstance, in ushort v)
        {
            fixed (ushort* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Color3usv(v_ptr);
            }
        }

        // Color4b overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void Color4(this GL glInstance, sbyte red, sbyte green, sbyte blue, sbyte alpha) =>
            glInstance.Color4b(red, green, blue, alpha);

        // Color4bv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color4(this GL glInstance, ReadOnlySpan<sbyte> v)
        {
            fixed (sbyte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color4bv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color4(this GL glInstance, sbyte[] v)
        {
            fixed (sbyte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color4bv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Color4(this GL glInstance, in sbyte v)
        {
            fixed (sbyte* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Color4bv(v_ptr);
            }
        }

        // Color4dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color4dv(this GL glInstance, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color4dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color4dv(this GL glInstance, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color4dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Color4dv(this GL glInstance, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Color4dv(v_ptr);
            }
        }

        // Color4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color4fv(this GL glInstance, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color4fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color4fv(this GL glInstance, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color4fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Color4fv(this GL glInstance, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Color4fv(v_ptr);
            }
        }

        // Color4iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color4iv(this GL glInstance, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color4iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color4iv(this GL glInstance, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color4iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Color4iv(this GL glInstance, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Color4iv(v_ptr);
            }
        }

        // Color4s overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void Color4(this GL glInstance, short red, short green, short blue, short alpha) =>
            glInstance.Color4s(red, green, blue, alpha);

        // Color4sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color4(this GL glInstance, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color4sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color4(this GL glInstance, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color4sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Color4(this GL glInstance, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Color4sv(v_ptr);
            }
        }

        // Color4ub overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void Color4(this GL glInstance, byte red, byte green, byte blue, byte alpha) =>
            glInstance.Color4ub(red, green, blue, alpha);

        // Color4ubv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color4(this GL glInstance, ReadOnlySpan<byte> v)
        {
            fixed (byte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color4ubv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color4(this GL glInstance, byte[] v)
        {
            fixed (byte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color4ubv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Color4(this GL glInstance, in byte v)
        {
            fixed (byte* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Color4ubv(v_ptr);
            }
        }

        // Color4uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color4ui(this GL glInstance, ReadOnlySpan<uint> v)
        {
            fixed (uint* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color4uiv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color4ui(this GL glInstance, uint[] v)
        {
            fixed (uint* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color4uiv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Color4ui(this GL glInstance, in uint v)
        {
            fixed (uint* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Color4uiv(v_ptr);
            }
        }

        // Color4us overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void Color4(this GL glInstance, ushort red, ushort green, ushort blue, ushort alpha) =>
            glInstance.Color4us(red, green, blue, alpha);

        // Color4usv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color4(this GL glInstance, ReadOnlySpan<ushort> v)
        {
            fixed (ushort* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color4usv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Color4(this GL glInstance, ushort[] v)
        {
            fixed (ushort* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Color4usv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Color4(this GL glInstance, in ushort v)
        {
            fixed (ushort* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Color4usv(v_ptr);
            }
        }

        // EdgeFlag overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void EdgeFlag(this GL glInstance, bool flag)
        {
            var flag_byte = (byte)(flag ? 1 : 0);
            glInstance.EdgeFlag(flag_byte);
        }

        // EdgeFlagv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void EdgeFlag(this GL glInstance, ReadOnlySpan<byte> flag)
        {
            fixed (byte* flag_ptr = flag) // SpanOrArrayLayer
            {
                glInstance.EdgeFlagv(flag_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void EdgeFlag(this GL glInstance, byte[] flag)
        {
            fixed (byte* flag_ptr = flag) // SpanOrArrayLayer
            {
                glInstance.EdgeFlagv(flag_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void EdgeFlag(this GL glInstance, in byte flag)
        {
            fixed (byte* flag_ptr = &flag) // RefInsteadOfPointerLayer
            {
                glInstance.EdgeFlagv(flag_ptr);
            }
        }

        // Indexdv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Indexd(this GL glInstance, ReadOnlySpan<double> c)
        {
            fixed (double* c_ptr = c) // SpanOrArrayLayer
            {
                glInstance.Indexdv(c_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Indexd(this GL glInstance, double[] c)
        {
            fixed (double* c_ptr = c) // SpanOrArrayLayer
            {
                glInstance.Indexdv(c_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Indexd(this GL glInstance, in double c)
        {
            fixed (double* c_ptr = &c) // RefInsteadOfPointerLayer
            {
                glInstance.Indexdv(c_ptr);
            }
        }

        // Indexfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Indexf(this GL glInstance, ReadOnlySpan<float> c)
        {
            fixed (float* c_ptr = c) // SpanOrArrayLayer
            {
                glInstance.Indexfv(c_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Indexf(this GL glInstance, float[] c)
        {
            fixed (float* c_ptr = c) // SpanOrArrayLayer
            {
                glInstance.Indexfv(c_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Indexf(this GL glInstance, in float c)
        {
            fixed (float* c_ptr = &c) // RefInsteadOfPointerLayer
            {
                glInstance.Indexfv(c_ptr);
            }
        }

        // Indexiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Indexi(this GL glInstance, ReadOnlySpan<int> c)
        {
            fixed (int* c_ptr = c) // SpanOrArrayLayer
            {
                glInstance.Indexiv(c_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Indexi(this GL glInstance, int[] c)
        {
            fixed (int* c_ptr = c) // SpanOrArrayLayer
            {
                glInstance.Indexiv(c_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Indexi(this GL glInstance, in int c)
        {
            fixed (int* c_ptr = &c) // RefInsteadOfPointerLayer
            {
                glInstance.Indexiv(c_ptr);
            }
        }

        // Indexs overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void Index(this GL glInstance, short c) =>
            glInstance.Indexs(c);

        // Indexsv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Index(this GL glInstance, ReadOnlySpan<short> c)
        {
            fixed (short* c_ptr = c) // SpanOrArrayLayer
            {
                glInstance.Indexsv(c_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Index(this GL glInstance, short[] c)
        {
            fixed (short* c_ptr = c) // SpanOrArrayLayer
            {
                glInstance.Indexsv(c_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Index(this GL glInstance, in short c)
        {
            fixed (short* c_ptr = &c) // RefInsteadOfPointerLayer
            {
                glInstance.Indexsv(c_ptr);
            }
        }

        // Normal3b overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void Normal3(this GL glInstance, sbyte nx, sbyte ny, sbyte nz) =>
            glInstance.Normal3b(nx, ny, nz);

        // Normal3bv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Normal3(this GL glInstance, ReadOnlySpan<sbyte> v)
        {
            fixed (sbyte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Normal3bv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Normal3(this GL glInstance, sbyte[] v)
        {
            fixed (sbyte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Normal3bv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Normal3(this GL glInstance, in sbyte v)
        {
            fixed (sbyte* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Normal3bv(v_ptr);
            }
        }

        // Normal3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Normal3dv(this GL glInstance, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Normal3dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Normal3dv(this GL glInstance, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Normal3dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Normal3dv(this GL glInstance, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Normal3dv(v_ptr);
            }
        }

        // Normal3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Normal3fv(this GL glInstance, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Normal3fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Normal3fv(this GL glInstance, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Normal3fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Normal3fv(this GL glInstance, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Normal3fv(v_ptr);
            }
        }

        // Normal3iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Normal3iv(this GL glInstance, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Normal3iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Normal3iv(this GL glInstance, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Normal3iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Normal3iv(this GL glInstance, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Normal3iv(v_ptr);
            }
        }

        // Normal3s overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void Normal3(this GL glInstance, short nx, short ny, short nz) =>
            glInstance.Normal3s(nx, ny, nz);

        // Normal3sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Normal3(this GL glInstance, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Normal3sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Normal3(this GL glInstance, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Normal3sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Normal3(this GL glInstance, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Normal3sv(v_ptr);
            }
        }

        // RasterPos2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void RasterPos2dv(this GL glInstance, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.RasterPos2dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void RasterPos2dv(this GL glInstance, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.RasterPos2dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void RasterPos2dv(this GL glInstance, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.RasterPos2dv(v_ptr);
            }
        }

        // RasterPos2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void RasterPos2fv(this GL glInstance, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.RasterPos2fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void RasterPos2fv(this GL glInstance, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.RasterPos2fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void RasterPos2fv(this GL glInstance, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.RasterPos2fv(v_ptr);
            }
        }

        // RasterPos2iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void RasterPos2iv(this GL glInstance, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.RasterPos2iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void RasterPos2iv(this GL glInstance, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.RasterPos2iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void RasterPos2iv(this GL glInstance, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.RasterPos2iv(v_ptr);
            }
        }

        // RasterPos2s overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void RasterPos2(this GL glInstance, short x, short y) =>
            glInstance.RasterPos2s(x, y);

        // RasterPos2sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void RasterPos2(this GL glInstance, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.RasterPos2sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void RasterPos2(this GL glInstance, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.RasterPos2sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void RasterPos2(this GL glInstance, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.RasterPos2sv(v_ptr);
            }
        }

        // RasterPos3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void RasterPos3dv(this GL glInstance, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.RasterPos3dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void RasterPos3dv(this GL glInstance, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.RasterPos3dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void RasterPos3dv(this GL glInstance, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.RasterPos3dv(v_ptr);
            }
        }

        // RasterPos3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void RasterPos3fv(this GL glInstance, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.RasterPos3fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void RasterPos3fv(this GL glInstance, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.RasterPos3fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void RasterPos3fv(this GL glInstance, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.RasterPos3fv(v_ptr);
            }
        }

        // RasterPos3iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void RasterPos3iv(this GL glInstance, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.RasterPos3iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void RasterPos3iv(this GL glInstance, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.RasterPos3iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void RasterPos3iv(this GL glInstance, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.RasterPos3iv(v_ptr);
            }
        }

        // RasterPos3s overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void RasterPos3(this GL glInstance, short x, short y, short z) =>
            glInstance.RasterPos3s(x, y, z);

        // RasterPos3sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void RasterPos3(this GL glInstance, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.RasterPos3sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void RasterPos3(this GL glInstance, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.RasterPos3sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void RasterPos3(this GL glInstance, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.RasterPos3sv(v_ptr);
            }
        }

        // RasterPos4dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void RasterPos4dv(this GL glInstance, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.RasterPos4dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void RasterPos4dv(this GL glInstance, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.RasterPos4dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void RasterPos4dv(this GL glInstance, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.RasterPos4dv(v_ptr);
            }
        }

        // RasterPos4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void RasterPos4fv(this GL glInstance, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.RasterPos4fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void RasterPos4fv(this GL glInstance, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.RasterPos4fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void RasterPos4fv(this GL glInstance, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.RasterPos4fv(v_ptr);
            }
        }

        // RasterPos4iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void RasterPos4iv(this GL glInstance, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.RasterPos4iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void RasterPos4iv(this GL glInstance, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.RasterPos4iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void RasterPos4iv(this GL glInstance, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.RasterPos4iv(v_ptr);
            }
        }

        // RasterPos4s overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void RasterPos4(this GL glInstance, short x, short y, short z, short w) =>
            glInstance.RasterPos4s(x, y, z, w);

        // RasterPos4sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void RasterPos4(this GL glInstance, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.RasterPos4sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void RasterPos4(this GL glInstance, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.RasterPos4sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void RasterPos4(this GL glInstance, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.RasterPos4sv(v_ptr);
            }
        }

        // Rectdv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Rectd(this GL glInstance, ReadOnlySpan<double> v1, ReadOnlySpan<double> v2)
        {
            fixed (double* v1_ptr = v1) // SpanOrArrayLayer
            {
                fixed (double* v2_ptr = v2) // SpanOrArrayLayer
                {
                    glInstance.Rectdv(v1_ptr, v2_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Rectd(this GL glInstance, double[] v1, double[] v2)
        {
            fixed (double* v1_ptr = v1) // SpanOrArrayLayer
            {
                fixed (double* v2_ptr = v2) // SpanOrArrayLayer
                {
                    glInstance.Rectdv(v1_ptr, v2_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Rectd(this GL glInstance, in double v1, in double v2)
        {
            fixed (double* v1_ptr = &v1) // RefInsteadOfPointerLayer
            fixed (double* v2_ptr = &v2) // RefInsteadOfPointerLayer
            {
                glInstance.Rectdv(v1_ptr, v2_ptr);
            }
        }

        // Rectfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Rectf(this GL glInstance, ReadOnlySpan<float> v1, ReadOnlySpan<float> v2)
        {
            fixed (float* v1_ptr = v1) // SpanOrArrayLayer
            {
                fixed (float* v2_ptr = v2) // SpanOrArrayLayer
                {
                    glInstance.Rectfv(v1_ptr, v2_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Rectf(this GL glInstance, float[] v1, float[] v2)
        {
            fixed (float* v1_ptr = v1) // SpanOrArrayLayer
            {
                fixed (float* v2_ptr = v2) // SpanOrArrayLayer
                {
                    glInstance.Rectfv(v1_ptr, v2_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Rectf(this GL glInstance, in float v1, in float v2)
        {
            fixed (float* v1_ptr = &v1) // RefInsteadOfPointerLayer
            fixed (float* v2_ptr = &v2) // RefInsteadOfPointerLayer
            {
                glInstance.Rectfv(v1_ptr, v2_ptr);
            }
        }

        // Rectiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Recti(this GL glInstance, ReadOnlySpan<int> v1, ReadOnlySpan<int> v2)
        {
            fixed (int* v1_ptr = v1) // SpanOrArrayLayer
            {
                fixed (int* v2_ptr = v2) // SpanOrArrayLayer
                {
                    glInstance.Rectiv(v1_ptr, v2_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Recti(this GL glInstance, int[] v1, int[] v2)
        {
            fixed (int* v1_ptr = v1) // SpanOrArrayLayer
            {
                fixed (int* v2_ptr = v2) // SpanOrArrayLayer
                {
                    glInstance.Rectiv(v1_ptr, v2_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Recti(this GL glInstance, in int v1, in int v2)
        {
            fixed (int* v1_ptr = &v1) // RefInsteadOfPointerLayer
            fixed (int* v2_ptr = &v2) // RefInsteadOfPointerLayer
            {
                glInstance.Rectiv(v1_ptr, v2_ptr);
            }
        }

        // Rectsv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Rect(this GL glInstance, ReadOnlySpan<short> v1, ReadOnlySpan<short> v2)
        {
            fixed (short* v1_ptr = v1) // SpanOrArrayLayer
            {
                fixed (short* v2_ptr = v2) // SpanOrArrayLayer
                {
                    glInstance.Rectsv(v1_ptr, v2_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Rect(this GL glInstance, short[] v1, short[] v2)
        {
            fixed (short* v1_ptr = v1) // SpanOrArrayLayer
            {
                fixed (short* v2_ptr = v2) // SpanOrArrayLayer
                {
                    glInstance.Rectsv(v1_ptr, v2_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Rect(this GL glInstance, in short v1, in short v2)
        {
            fixed (short* v1_ptr = &v1) // RefInsteadOfPointerLayer
            fixed (short* v2_ptr = &v2) // RefInsteadOfPointerLayer
            {
                glInstance.Rectsv(v1_ptr, v2_ptr);
            }
        }

        // TexCoord1dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord1dv(this GL glInstance, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord1dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord1dv(this GL glInstance, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord1dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoord1dv(this GL glInstance, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoord1dv(v_ptr);
            }
        }

        // TexCoord1fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord1fv(this GL glInstance, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord1fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord1fv(this GL glInstance, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord1fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoord1fv(this GL glInstance, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoord1fv(v_ptr);
            }
        }

        // TexCoord1iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord1iv(this GL glInstance, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord1iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord1iv(this GL glInstance, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord1iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoord1iv(this GL glInstance, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoord1iv(v_ptr);
            }
        }

        // TexCoord1s overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void TexCoord1(this GL glInstance, short s) =>
            glInstance.TexCoord1s(s);

        // TexCoord1sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord1(this GL glInstance, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord1sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord1(this GL glInstance, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord1sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoord1(this GL glInstance, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoord1sv(v_ptr);
            }
        }

        // TexCoord2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord2dv(this GL glInstance, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord2dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord2dv(this GL glInstance, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord2dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoord2dv(this GL glInstance, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoord2dv(v_ptr);
            }
        }

        // TexCoord2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord2fv(this GL glInstance, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord2fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord2fv(this GL glInstance, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord2fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoord2fv(this GL glInstance, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoord2fv(v_ptr);
            }
        }

        // TexCoord2iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord2iv(this GL glInstance, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord2iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord2iv(this GL glInstance, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord2iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoord2iv(this GL glInstance, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoord2iv(v_ptr);
            }
        }

        // TexCoord2s overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void TexCoord2(this GL glInstance, short s, short t) =>
            glInstance.TexCoord2s(s, t);

        // TexCoord2sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord2(this GL glInstance, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord2sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord2(this GL glInstance, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord2sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoord2(this GL glInstance, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoord2sv(v_ptr);
            }
        }

        // TexCoord3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord3dv(this GL glInstance, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord3dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord3dv(this GL glInstance, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord3dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoord3dv(this GL glInstance, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoord3dv(v_ptr);
            }
        }

        // TexCoord3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord3fv(this GL glInstance, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord3fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord3fv(this GL glInstance, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord3fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoord3fv(this GL glInstance, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoord3fv(v_ptr);
            }
        }

        // TexCoord3iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord3iv(this GL glInstance, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord3iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord3iv(this GL glInstance, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord3iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoord3iv(this GL glInstance, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoord3iv(v_ptr);
            }
        }

        // TexCoord3s overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void TexCoord3(this GL glInstance, short s, short t, short r) =>
            glInstance.TexCoord3s(s, t, r);

        // TexCoord3sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord3(this GL glInstance, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord3sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord3(this GL glInstance, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord3sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoord3(this GL glInstance, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoord3sv(v_ptr);
            }
        }

        // TexCoord4dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord4dv(this GL glInstance, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord4dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord4dv(this GL glInstance, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord4dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoord4dv(this GL glInstance, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoord4dv(v_ptr);
            }
        }

        // TexCoord4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord4fv(this GL glInstance, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord4fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord4fv(this GL glInstance, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord4fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoord4fv(this GL glInstance, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoord4fv(v_ptr);
            }
        }

        // TexCoord4iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord4iv(this GL glInstance, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord4iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord4iv(this GL glInstance, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord4iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoord4iv(this GL glInstance, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoord4iv(v_ptr);
            }
        }

        // TexCoord4s overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void TexCoord4(this GL glInstance, short s, short t, short r, short q) =>
            glInstance.TexCoord4s(s, t, r, q);

        // TexCoord4sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord4(this GL glInstance, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord4sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoord4(this GL glInstance, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.TexCoord4sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoord4(this GL glInstance, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoord4sv(v_ptr);
            }
        }

        // Vertex2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Vertex2dv(this GL glInstance, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Vertex2dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Vertex2dv(this GL glInstance, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Vertex2dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Vertex2dv(this GL glInstance, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Vertex2dv(v_ptr);
            }
        }

        // Vertex2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Vertex2fv(this GL glInstance, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Vertex2fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Vertex2fv(this GL glInstance, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Vertex2fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Vertex2fv(this GL glInstance, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Vertex2fv(v_ptr);
            }
        }

        // Vertex2iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Vertex2iv(this GL glInstance, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Vertex2iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Vertex2iv(this GL glInstance, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Vertex2iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Vertex2iv(this GL glInstance, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Vertex2iv(v_ptr);
            }
        }

        // Vertex2s overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void Vertex2(this GL glInstance, short x, short y) =>
            glInstance.Vertex2s(x, y);

        // Vertex2sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Vertex2(this GL glInstance, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Vertex2sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Vertex2(this GL glInstance, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Vertex2sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Vertex2(this GL glInstance, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Vertex2sv(v_ptr);
            }
        }

        // Vertex3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Vertex3dv(this GL glInstance, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Vertex3dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Vertex3dv(this GL glInstance, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Vertex3dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Vertex3dv(this GL glInstance, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Vertex3dv(v_ptr);
            }
        }

        // Vertex3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Vertex3fv(this GL glInstance, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Vertex3fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Vertex3fv(this GL glInstance, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Vertex3fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Vertex3fv(this GL glInstance, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Vertex3fv(v_ptr);
            }
        }

        // Vertex3iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Vertex3iv(this GL glInstance, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Vertex3iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Vertex3iv(this GL glInstance, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Vertex3iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Vertex3iv(this GL glInstance, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Vertex3iv(v_ptr);
            }
        }

        // Vertex3s overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void Vertex3(this GL glInstance, short x, short y, short z) =>
            glInstance.Vertex3s(x, y, z);

        // Vertex3sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Vertex3(this GL glInstance, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Vertex3sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Vertex3(this GL glInstance, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Vertex3sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Vertex3(this GL glInstance, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Vertex3sv(v_ptr);
            }
        }

        // Vertex4dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Vertex4dv(this GL glInstance, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Vertex4dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Vertex4dv(this GL glInstance, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Vertex4dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Vertex4dv(this GL glInstance, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Vertex4dv(v_ptr);
            }
        }

        // Vertex4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Vertex4fv(this GL glInstance, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Vertex4fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Vertex4fv(this GL glInstance, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Vertex4fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Vertex4fv(this GL glInstance, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Vertex4fv(v_ptr);
            }
        }

        // Vertex4iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Vertex4iv(this GL glInstance, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Vertex4iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Vertex4iv(this GL glInstance, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Vertex4iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Vertex4iv(this GL glInstance, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Vertex4iv(v_ptr);
            }
        }

        // Vertex4s overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void Vertex4(this GL glInstance, short x, short y, short z, short w) =>
            glInstance.Vertex4s(x, y, z, w);

        // Vertex4sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Vertex4(this GL glInstance, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Vertex4sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Vertex4(this GL glInstance, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.Vertex4sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Vertex4(this GL glInstance, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.Vertex4sv(v_ptr);
            }
        }

        // ClipPlane overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClipPlane(this GL glInstance, ClipPlaneName plane, ReadOnlySpan<double> equation)
        {
            fixed (double* equation_ptr = equation) // SpanOrArrayLayer
            {
                glInstance.ClipPlane(plane, equation_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClipPlane(this GL glInstance, ClipPlaneName plane, double[] equation)
        {
            fixed (double* equation_ptr = equation) // SpanOrArrayLayer
            {
                glInstance.ClipPlane(plane, equation_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClipPlane(this GL glInstance, ClipPlaneName plane, in double equation)
        {
            fixed (double* equation_ptr = &equation) // RefInsteadOfPointerLayer
            {
                glInstance.ClipPlane(plane, equation_ptr);
            }
        }

        // Fogfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Fogf(this GL glInstance, FogParameter pname, ReadOnlySpan<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.Fogfv(pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Fogf(this GL glInstance, FogParameter pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.Fogfv(pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Fogf(this GL glInstance, FogParameter pname, in float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.Fogfv(pname, parameters_ptr);
            }
        }

        // Fogiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Fogi(this GL glInstance, FogParameter pname, ReadOnlySpan<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.Fogiv(pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Fogi(this GL glInstance, FogParameter pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.Fogiv(pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Fogi(this GL glInstance, FogParameter pname, in int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.Fogiv(pname, parameters_ptr);
            }
        }

        // Lightfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Lightf(this GL glInstance, LightName light, LightParameter pname, ReadOnlySpan<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.Lightfv(light, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Lightf(this GL glInstance, LightName light, LightParameter pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.Lightfv(light, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Lightf(this GL glInstance, LightName light, LightParameter pname, in float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.Lightfv(light, pname, parameters_ptr);
            }
        }

        // Lightiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Lighti(this GL glInstance, LightName light, LightParameter pname, ReadOnlySpan<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.Lightiv(light, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Lighti(this GL glInstance, LightName light, LightParameter pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.Lightiv(light, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Lighti(this GL glInstance, LightName light, LightParameter pname, in int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.Lightiv(light, pname, parameters_ptr);
            }
        }

        // LightModelfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void LightModelf(this GL glInstance, LightModelParameter pname, ReadOnlySpan<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.LightModelfv(pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void LightModelf(this GL glInstance, LightModelParameter pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.LightModelfv(pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void LightModelf(this GL glInstance, LightModelParameter pname, in float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.LightModelfv(pname, parameters_ptr);
            }
        }

        // LightModeliv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void LightModeli(this GL glInstance, LightModelParameter pname, ReadOnlySpan<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.LightModeliv(pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void LightModeli(this GL glInstance, LightModelParameter pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.LightModeliv(pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void LightModeli(this GL glInstance, LightModelParameter pname, in int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.LightModeliv(pname, parameters_ptr);
            }
        }

        // Materialfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Materialf(this GL glInstance, MaterialFace face, MaterialParameter pname, ReadOnlySpan<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.Materialfv(face, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Materialf(this GL glInstance, MaterialFace face, MaterialParameter pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.Materialfv(face, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Materialf(this GL glInstance, MaterialFace face, MaterialParameter pname, in float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.Materialfv(face, pname, parameters_ptr);
            }
        }

        // Materialiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Materiali(this GL glInstance, MaterialFace face, MaterialParameter pname, ReadOnlySpan<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.Materialiv(face, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Materiali(this GL glInstance, MaterialFace face, MaterialParameter pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.Materialiv(face, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Materiali(this GL glInstance, MaterialFace face, MaterialParameter pname, in int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.Materialiv(face, pname, parameters_ptr);
            }
        }

        // PolygonStipple overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PolygonStipple(this GL glInstance, ReadOnlySpan<byte> mask)
        {
            fixed (byte* mask_ptr = mask) // SpanOrArrayLayer
            {
                glInstance.PolygonStipple(mask_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PolygonStipple(this GL glInstance, byte[] mask)
        {
            fixed (byte* mask_ptr = mask) // SpanOrArrayLayer
            {
                glInstance.PolygonStipple(mask_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void PolygonStipple(this GL glInstance, in byte mask)
        {
            fixed (byte* mask_ptr = &mask) // RefInsteadOfPointerLayer
            {
                glInstance.PolygonStipple(mask_ptr);
            }
        }

        // TexEnvfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexEnvf(this GL glInstance, TextureEnvTarget target, TextureEnvParameter pname, ReadOnlySpan<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexEnvfv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexEnvf(this GL glInstance, TextureEnvTarget target, TextureEnvParameter pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexEnvfv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexEnvf(this GL glInstance, TextureEnvTarget target, TextureEnvParameter pname, in float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.TexEnvfv(target, pname, parameters_ptr);
            }
        }

        // TexEnviv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexEnvi(this GL glInstance, TextureEnvTarget target, TextureEnvParameter pname, ReadOnlySpan<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexEnviv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexEnvi(this GL glInstance, TextureEnvTarget target, TextureEnvParameter pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexEnviv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexEnvi(this GL glInstance, TextureEnvTarget target, TextureEnvParameter pname, in int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.TexEnviv(target, pname, parameters_ptr);
            }
        }

        // TexGendv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexGend(this GL glInstance, TextureCoordName coord, TextureGenParameter pname, ReadOnlySpan<double> parameters)
        {
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexGendv(coord, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexGend(this GL glInstance, TextureCoordName coord, TextureGenParameter pname, double[] parameters)
        {
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexGendv(coord, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexGend(this GL glInstance, TextureCoordName coord, TextureGenParameter pname, in double parameters)
        {
            fixed (double* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.TexGendv(coord, pname, parameters_ptr);
            }
        }

        // TexGenfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexGenf(this GL glInstance, TextureCoordName coord, TextureGenParameter pname, ReadOnlySpan<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexGenfv(coord, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexGenf(this GL glInstance, TextureCoordName coord, TextureGenParameter pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexGenfv(coord, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexGenf(this GL glInstance, TextureCoordName coord, TextureGenParameter pname, in float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.TexGenfv(coord, pname, parameters_ptr);
            }
        }

        // TexGeniv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexGeni(this GL glInstance, TextureCoordName coord, TextureGenParameter pname, ReadOnlySpan<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexGeniv(coord, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexGeni(this GL glInstance, TextureCoordName coord, TextureGenParameter pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexGeniv(coord, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexGeni(this GL glInstance, TextureCoordName coord, TextureGenParameter pname, in int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.TexGeniv(coord, pname, parameters_ptr);
            }
        }

        // FeedbackBuffer overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void FeedbackBuffer(this GL glInstance, FeedbackType type, Span<float> buffer)
        {
            var size = (int)(buffer.Length);
            fixed (float* buffer_ptr = buffer) // SpanOrArrayLayer
            {
                glInstance.FeedbackBuffer(size, type, buffer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void FeedbackBuffer(this GL glInstance, FeedbackType type, float[] buffer)
        {
            var size = (int)(buffer.Length);
            fixed (float* buffer_ptr = buffer) // SpanOrArrayLayer
            {
                glInstance.FeedbackBuffer(size, type, buffer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void FeedbackBuffer(this GL glInstance, int size, FeedbackType type, ref float buffer)
        {
            fixed (float* buffer_ptr = &buffer) // RefInsteadOfPointerLayer
            {
                glInstance.FeedbackBuffer(size, type, buffer_ptr);
            }
        }

        // SelectBuffer overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SelectBuffer(this GL glInstance, Span<uint> buffer)
        {
            var size = (int)(buffer.Length);
            fixed (uint* buffer_ptr = buffer) // SpanOrArrayLayer
            {
                glInstance.SelectBuffer(size, buffer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SelectBuffer(this GL glInstance, uint[] buffer)
        {
            var size = (int)(buffer.Length);
            fixed (uint* buffer_ptr = buffer) // SpanOrArrayLayer
            {
                glInstance.SelectBuffer(size, buffer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SelectBuffer(this GL glInstance, int size, ref uint buffer)
        {
            fixed (uint* buffer_ptr = &buffer) // RefInsteadOfPointerLayer
            {
                glInstance.SelectBuffer(size, buffer_ptr);
            }
        }

        // Map1d overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Map1d(this GL glInstance, MapTarget target, double u1, double u2, int stride, int order, ReadOnlySpan<double> points)
        {
            fixed (double* points_ptr = points) // SpanOrArrayLayer
            {
                glInstance.Map1d(target, u1, u2, stride, order, points_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Map1d(this GL glInstance, MapTarget target, double u1, double u2, int stride, int order, double[] points)
        {
            fixed (double* points_ptr = points) // SpanOrArrayLayer
            {
                glInstance.Map1d(target, u1, u2, stride, order, points_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Map1d(this GL glInstance, MapTarget target, double u1, double u2, int stride, int order, in double points)
        {
            fixed (double* points_ptr = &points) // RefInsteadOfPointerLayer
            {
                glInstance.Map1d(target, u1, u2, stride, order, points_ptr);
            }
        }

        // Map1f overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Map1f(this GL glInstance, MapTarget target, float u1, float u2, int stride, int order, ReadOnlySpan<float> points)
        {
            fixed (float* points_ptr = points) // SpanOrArrayLayer
            {
                glInstance.Map1f(target, u1, u2, stride, order, points_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Map1f(this GL glInstance, MapTarget target, float u1, float u2, int stride, int order, float[] points)
        {
            fixed (float* points_ptr = points) // SpanOrArrayLayer
            {
                glInstance.Map1f(target, u1, u2, stride, order, points_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Map1f(this GL glInstance, MapTarget target, float u1, float u2, int stride, int order, in float points)
        {
            fixed (float* points_ptr = &points) // RefInsteadOfPointerLayer
            {
                glInstance.Map1f(target, u1, u2, stride, order, points_ptr);
            }
        }

        // Map2d overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Map2d(this GL glInstance, MapTarget target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, ReadOnlySpan<double> points)
        {
            fixed (double* points_ptr = points) // SpanOrArrayLayer
            {
                glInstance.Map2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Map2d(this GL glInstance, MapTarget target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double[] points)
        {
            fixed (double* points_ptr = points) // SpanOrArrayLayer
            {
                glInstance.Map2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Map2d(this GL glInstance, MapTarget target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, in double points)
        {
            fixed (double* points_ptr = &points) // RefInsteadOfPointerLayer
            {
                glInstance.Map2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_ptr);
            }
        }

        // Map2f overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Map2f(this GL glInstance, MapTarget target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, ReadOnlySpan<float> points)
        {
            fixed (float* points_ptr = points) // SpanOrArrayLayer
            {
                glInstance.Map2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Map2f(this GL glInstance, MapTarget target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float[] points)
        {
            fixed (float* points_ptr = points) // SpanOrArrayLayer
            {
                glInstance.Map2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Map2f(this GL glInstance, MapTarget target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, in float points)
        {
            fixed (float* points_ptr = &points) // RefInsteadOfPointerLayer
            {
                glInstance.Map2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_ptr);
            }
        }

        // EvalCoord1dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void EvalCoord1dv(this GL glInstance, ReadOnlySpan<double> u)
        {
            fixed (double* u_ptr = u) // SpanOrArrayLayer
            {
                glInstance.EvalCoord1dv(u_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void EvalCoord1dv(this GL glInstance, double[] u)
        {
            fixed (double* u_ptr = u) // SpanOrArrayLayer
            {
                glInstance.EvalCoord1dv(u_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void EvalCoord1dv(this GL glInstance, in double u)
        {
            fixed (double* u_ptr = &u) // RefInsteadOfPointerLayer
            {
                glInstance.EvalCoord1dv(u_ptr);
            }
        }

        // EvalCoord1fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void EvalCoord1fv(this GL glInstance, ReadOnlySpan<float> u)
        {
            fixed (float* u_ptr = u) // SpanOrArrayLayer
            {
                glInstance.EvalCoord1fv(u_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void EvalCoord1fv(this GL glInstance, float[] u)
        {
            fixed (float* u_ptr = u) // SpanOrArrayLayer
            {
                glInstance.EvalCoord1fv(u_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void EvalCoord1fv(this GL glInstance, in float u)
        {
            fixed (float* u_ptr = &u) // RefInsteadOfPointerLayer
            {
                glInstance.EvalCoord1fv(u_ptr);
            }
        }

        // EvalCoord2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void EvalCoord2dv(this GL glInstance, ReadOnlySpan<double> u)
        {
            fixed (double* u_ptr = u) // SpanOrArrayLayer
            {
                glInstance.EvalCoord2dv(u_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void EvalCoord2dv(this GL glInstance, double[] u)
        {
            fixed (double* u_ptr = u) // SpanOrArrayLayer
            {
                glInstance.EvalCoord2dv(u_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void EvalCoord2dv(this GL glInstance, in double u)
        {
            fixed (double* u_ptr = &u) // RefInsteadOfPointerLayer
            {
                glInstance.EvalCoord2dv(u_ptr);
            }
        }

        // EvalCoord2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void EvalCoord2fv(this GL glInstance, ReadOnlySpan<float> u)
        {
            fixed (float* u_ptr = u) // SpanOrArrayLayer
            {
                glInstance.EvalCoord2fv(u_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void EvalCoord2fv(this GL glInstance, float[] u)
        {
            fixed (float* u_ptr = u) // SpanOrArrayLayer
            {
                glInstance.EvalCoord2fv(u_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void EvalCoord2fv(this GL glInstance, in float u)
        {
            fixed (float* u_ptr = &u) // RefInsteadOfPointerLayer
            {
                glInstance.EvalCoord2fv(u_ptr);
            }
        }

        // PixelMapfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PixelMapf(this GL glInstance, PixelMap map, ReadOnlySpan<float> values)
        {
            var mapsize = (int)(values.Length);
            fixed (float* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.PixelMapfv(map, mapsize, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PixelMapf(this GL glInstance, PixelMap map, float[] values)
        {
            var mapsize = (int)(values.Length);
            fixed (float* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.PixelMapfv(map, mapsize, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void PixelMapf(this GL glInstance, PixelMap map, int mapsize, in float values)
        {
            fixed (float* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                glInstance.PixelMapfv(map, mapsize, values_ptr);
            }
        }

        // PixelMapuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PixelMapui(this GL glInstance, PixelMap map, ReadOnlySpan<uint> values)
        {
            var mapsize = (int)(values.Length);
            fixed (uint* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.PixelMapuiv(map, mapsize, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PixelMapui(this GL glInstance, PixelMap map, uint[] values)
        {
            var mapsize = (int)(values.Length);
            fixed (uint* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.PixelMapuiv(map, mapsize, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void PixelMapui(this GL glInstance, PixelMap map, int mapsize, in uint values)
        {
            fixed (uint* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                glInstance.PixelMapuiv(map, mapsize, values_ptr);
            }
        }

        // PixelMapusv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PixelMap(this GL glInstance, PixelMap map, ReadOnlySpan<ushort> values)
        {
            var mapsize = (int)(values.Length);
            fixed (ushort* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.PixelMapusv(map, mapsize, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PixelMap(this GL glInstance, PixelMap map, ushort[] values)
        {
            var mapsize = (int)(values.Length);
            fixed (ushort* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.PixelMapusv(map, mapsize, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void PixelMap(this GL glInstance, PixelMap map, int mapsize, in ushort values)
        {
            fixed (ushort* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                glInstance.PixelMapusv(map, mapsize, values_ptr);
            }
        }

        // DrawPixels overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void DrawPixels(this GL glInstance, int width, int height, PixelFormat format, PixelType type, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.DrawPixels(width, height, format, type, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DrawPixels<T1>(this GL glInstance, int width, int height, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.DrawPixels(width, height, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DrawPixels<T1>(this GL glInstance, int width, int height, PixelFormat format, PixelType type, T1[] pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.DrawPixels(width, height, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DrawPixels<T1>(this GL glInstance, int width, int height, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.DrawPixels(width, height, format, type, pixels_ptr);
            }
        }

        // GetClipPlane overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetClipPlane(this GL glInstance, ClipPlaneName plane, Span<double> equation)
        {
            fixed (double* equation_ptr = equation) // SpanOrArrayLayer
            {
                glInstance.GetClipPlane(plane, equation_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetClipPlane(this GL glInstance, ClipPlaneName plane, double[] equation)
        {
            fixed (double* equation_ptr = equation) // SpanOrArrayLayer
            {
                glInstance.GetClipPlane(plane, equation_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetClipPlane(this GL glInstance, ClipPlaneName plane, ref double equation)
        {
            fixed (double* equation_ptr = &equation) // RefInsteadOfPointerLayer
            {
                glInstance.GetClipPlane(plane, equation_ptr);
            }
        }

        // GetLightfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetLightf(this GL glInstance, LightName light, LightParameter pname, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetLightfv(light, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetLightf(this GL glInstance, LightName light, LightParameter pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetLightfv(light, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetLightf(this GL glInstance, LightName light, LightParameter pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetLightfv(light, pname, parameters_ptr);
            }
        }

        // GetLightiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetLighti(this GL glInstance, LightName light, LightParameter pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetLightiv(light, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetLighti(this GL glInstance, LightName light, LightParameter pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetLightiv(light, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetLighti(this GL glInstance, LightName light, LightParameter pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetLightiv(light, pname, parameters_ptr);
            }
        }

        // GetMapdv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetMapd(this GL glInstance, MapTarget target, GetMapQuery query, Span<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.GetMapdv(target, query, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetMapd(this GL glInstance, MapTarget target, GetMapQuery query, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.GetMapdv(target, query, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetMapd(this GL glInstance, MapTarget target, GetMapQuery query, ref double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.GetMapdv(target, query, v_ptr);
            }
        }

        // GetMapfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetMapf(this GL glInstance, MapTarget target, GetMapQuery query, Span<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.GetMapfv(target, query, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetMapf(this GL glInstance, MapTarget target, GetMapQuery query, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.GetMapfv(target, query, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetMapf(this GL glInstance, MapTarget target, GetMapQuery query, ref float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.GetMapfv(target, query, v_ptr);
            }
        }

        // GetMapiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetMapi(this GL glInstance, MapTarget target, GetMapQuery query, Span<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.GetMapiv(target, query, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetMapi(this GL glInstance, MapTarget target, GetMapQuery query, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.GetMapiv(target, query, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetMapi(this GL glInstance, MapTarget target, GetMapQuery query, ref int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.GetMapiv(target, query, v_ptr);
            }
        }

        // GetMaterialfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetMaterialf(this GL glInstance, MaterialFace face, MaterialParameter pname, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetMaterialfv(face, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetMaterialf(this GL glInstance, MaterialFace face, MaterialParameter pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetMaterialfv(face, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetMaterialf(this GL glInstance, MaterialFace face, MaterialParameter pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetMaterialfv(face, pname, parameters_ptr);
            }
        }

        // GetMaterialiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetMateriali(this GL glInstance, MaterialFace face, MaterialParameter pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetMaterialiv(face, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetMateriali(this GL glInstance, MaterialFace face, MaterialParameter pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetMaterialiv(face, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetMateriali(this GL glInstance, MaterialFace face, MaterialParameter pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetMaterialiv(face, pname, parameters_ptr);
            }
        }

        // GetPixelMapfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPixelMapf(this GL glInstance, PixelMap map, Span<float> values)
        {
            fixed (float* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.GetPixelMapfv(map, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPixelMapf(this GL glInstance, PixelMap map, float[] values)
        {
            fixed (float* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.GetPixelMapfv(map, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetPixelMapf(this GL glInstance, PixelMap map, ref float values)
        {
            fixed (float* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                glInstance.GetPixelMapfv(map, values_ptr);
            }
        }

        // GetPixelMapuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPixelMapui(this GL glInstance, PixelMap map, Span<uint> values)
        {
            fixed (uint* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.GetPixelMapuiv(map, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPixelMapui(this GL glInstance, PixelMap map, uint[] values)
        {
            fixed (uint* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.GetPixelMapuiv(map, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetPixelMapui(this GL glInstance, PixelMap map, ref uint values)
        {
            fixed (uint* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                glInstance.GetPixelMapuiv(map, values_ptr);
            }
        }

        // GetPixelMapusv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPixelMap(this GL glInstance, PixelMap map, Span<ushort> values)
        {
            fixed (ushort* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.GetPixelMapusv(map, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPixelMap(this GL glInstance, PixelMap map, ushort[] values)
        {
            fixed (ushort* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.GetPixelMapusv(map, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetPixelMap(this GL glInstance, PixelMap map, ref ushort values)
        {
            fixed (ushort* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                glInstance.GetPixelMapusv(map, values_ptr);
            }
        }

        // GetPolygonStipple overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPolygonStipple(this GL glInstance, Span<byte> mask)
        {
            fixed (byte* mask_ptr = mask) // SpanOrArrayLayer
            {
                glInstance.GetPolygonStipple(mask_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetPolygonStipple(this GL glInstance, byte[] mask)
        {
            fixed (byte* mask_ptr = mask) // SpanOrArrayLayer
            {
                glInstance.GetPolygonStipple(mask_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetPolygonStipple(this GL glInstance, ref byte mask)
        {
            fixed (byte* mask_ptr = &mask) // RefInsteadOfPointerLayer
            {
                glInstance.GetPolygonStipple(mask_ptr);
            }
        }

        // GetTexEnvfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexEnvf(this GL glInstance, TextureEnvTarget target, TextureEnvParameter pname, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexEnvfv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexEnvf(this GL glInstance, TextureEnvTarget target, TextureEnvParameter pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexEnvfv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTexEnvf(this GL glInstance, TextureEnvTarget target, TextureEnvParameter pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTexEnvfv(target, pname, parameters_ptr);
            }
        }

        // GetTexEnviv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexEnvi(this GL glInstance, TextureEnvTarget target, TextureEnvParameter pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexEnviv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexEnvi(this GL glInstance, TextureEnvTarget target, TextureEnvParameter pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexEnviv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTexEnvi(this GL glInstance, TextureEnvTarget target, TextureEnvParameter pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTexEnviv(target, pname, parameters_ptr);
            }
        }

        // GetTexGendv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexGend(this GL glInstance, TextureCoordName coord, TextureGenParameter pname, Span<double> parameters)
        {
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexGendv(coord, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexGend(this GL glInstance, TextureCoordName coord, TextureGenParameter pname, double[] parameters)
        {
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexGendv(coord, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTexGend(this GL glInstance, TextureCoordName coord, TextureGenParameter pname, ref double parameters)
        {
            fixed (double* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTexGendv(coord, pname, parameters_ptr);
            }
        }

        // GetTexGenfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexGenf(this GL glInstance, TextureCoordName coord, TextureGenParameter pname, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexGenfv(coord, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexGenf(this GL glInstance, TextureCoordName coord, TextureGenParameter pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexGenfv(coord, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTexGenf(this GL glInstance, TextureCoordName coord, TextureGenParameter pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTexGenfv(coord, pname, parameters_ptr);
            }
        }

        // GetTexGeniv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexGeni(this GL glInstance, TextureCoordName coord, TextureGenParameter pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexGeniv(coord, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexGeni(this GL glInstance, TextureCoordName coord, TextureGenParameter pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexGeniv(coord, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTexGeni(this GL glInstance, TextureCoordName coord, TextureGenParameter pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTexGeniv(coord, pname, parameters_ptr);
            }
        }

        // LoadMatrixf overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void LoadMatrixf(this GL glInstance, ReadOnlySpan<float> m)
        {
            fixed (float* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.LoadMatrixf(m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void LoadMatrixf(this GL glInstance, float[] m)
        {
            fixed (float* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.LoadMatrixf(m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void LoadMatrixf(this GL glInstance, in float m)
        {
            fixed (float* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.LoadMatrixf(m_ptr);
            }
        }

        // LoadMatrixd overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void LoadMatrixd(this GL glInstance, ReadOnlySpan<double> m)
        {
            fixed (double* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.LoadMatrixd(m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void LoadMatrixd(this GL glInstance, double[] m)
        {
            fixed (double* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.LoadMatrixd(m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void LoadMatrixd(this GL glInstance, in double m)
        {
            fixed (double* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.LoadMatrixd(m_ptr);
            }
        }

        // MultMatrixf overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultMatrixf(this GL glInstance, ReadOnlySpan<float> m)
        {
            fixed (float* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MultMatrixf(m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultMatrixf(this GL glInstance, float[] m)
        {
            fixed (float* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MultMatrixf(m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultMatrixf(this GL glInstance, in float m)
        {
            fixed (float* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.MultMatrixf(m_ptr);
            }
        }

        // MultMatrixd overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultMatrixd(this GL glInstance, ReadOnlySpan<double> m)
        {
            fixed (double* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MultMatrixd(m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultMatrixd(this GL glInstance, double[] m)
        {
            fixed (double* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MultMatrixd(m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultMatrixd(this GL glInstance, in double m)
        {
            fixed (double* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.MultMatrixd(m_ptr);
            }
        }

        // DrawElements overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void DrawElements(this GL glInstance, PrimitiveType mode, int count, DrawElementsType type, nint offset)
        {
            void* indices = (void*)offset;
            glInstance.DrawElements(mode, count, type, indices);
        }

        // GetPointerv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void GetPointer(this GL glInstance, GetPointervPName pname, void** parameters) =>
            glInstance.GetPointerv(pname, parameters);

        // TexSubImage1D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void TexSubImage1D(this GL glInstance, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.TexSubImage1D(target, level, xoffset, width, format, type, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexSubImage1D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.TexSubImage1D(target, level, xoffset, width, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexSubImage1D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, T1[] pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.TexSubImage1D(target, level, xoffset, width, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexSubImage1D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.TexSubImage1D(target, level, xoffset, width, format, type, pixels_ptr);
            }
        }

        // TexSubImage2D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void TexSubImage2D(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.TexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexSubImage2D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.TexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexSubImage2D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, T1[] pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.TexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexSubImage2D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.TexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
            }
        }

        // DeleteTextures overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void DeleteTexture(this GL glInstance, in TextureHandle textures)
        {
            int n = 1;
            fixed(TextureHandle* textures_handle = &textures) // DeleteOverloadLayer
                glInstance.DeleteTextures(n, textures_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteTextures(this GL glInstance, ReadOnlySpan<TextureHandle> textures)
        {
            var n = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures) // SpanOrArrayLayer
            {
                glInstance.DeleteTextures(n, textures_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteTextures(this GL glInstance, TextureHandle[] textures)
        {
            var n = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures) // SpanOrArrayLayer
            {
                glInstance.DeleteTextures(n, textures_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteTextures(this GL glInstance, int n, in TextureHandle textures)
        {
            fixed (TextureHandle* textures_ptr = &textures) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteTextures(n, textures_ptr);
            }
        }

        // GenTextures overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe TextureHandle GenTexture(this GL glInstance)
        {
            TextureHandle textures;
            int n = 1;
            Unsafe.SkipInit(out textures);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TextureHandle* textures_handle = (TextureHandle*)Unsafe.AsPointer(ref textures);
            glInstance.GenTextures(n, textures_handle);
            return textures;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void GenTexture(this GL glInstance, out TextureHandle textures)
        {
            int n = 1;
            Unsafe.SkipInit(out textures);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TextureHandle* textures_handle = (TextureHandle*)Unsafe.AsPointer(ref textures);
            glInstance.GenTextures(n, textures_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenTextures(this GL glInstance, Span<TextureHandle> textures)
        {
            var n = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures) // SpanOrArrayLayer
            {
                glInstance.GenTextures(n, textures_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenTextures(this GL glInstance, TextureHandle[] textures)
        {
            var n = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures) // SpanOrArrayLayer
            {
                glInstance.GenTextures(n, textures_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenTextures(this GL glInstance, int n, ref TextureHandle textures)
        {
            fixed (TextureHandle* textures_ptr = &textures) // RefInsteadOfPointerLayer
            {
                glInstance.GenTextures(n, textures_ptr);
            }
        }

        // ColorPointer overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ColorPointer(this GL glInstance, int size, ColorPointerType type, int stride, IntPtr pointer)
        {
            var pointer_vptr = (void*)pointer;
            glInstance.ColorPointer(size, type, stride, pointer_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ColorPointer<T1>(this GL glInstance, int size, ColorPointerType type, int stride, ReadOnlySpan<T1> pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.ColorPointer(size, type, stride, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ColorPointer<T1>(this GL glInstance, int size, ColorPointerType type, int stride, T1[] pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.ColorPointer(size, type, stride, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ColorPointer<T1>(this GL glInstance, int size, ColorPointerType type, int stride, in T1 pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = &pointer) // RefInsteadOfPointerLayer
            {
                glInstance.ColorPointer(size, type, stride, pointer_ptr);
            }
        }

        // EdgeFlagPointer overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void EdgeFlagPointer(this GL glInstance, int stride, IntPtr pointer)
        {
            var pointer_vptr = (void*)pointer;
            glInstance.EdgeFlagPointer(stride, pointer_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void EdgeFlagPointer<T1>(this GL glInstance, int stride, ReadOnlySpan<T1> pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.EdgeFlagPointer(stride, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void EdgeFlagPointer<T1>(this GL glInstance, int stride, T1[] pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.EdgeFlagPointer(stride, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void EdgeFlagPointer<T1>(this GL glInstance, int stride, in T1 pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = &pointer) // RefInsteadOfPointerLayer
            {
                glInstance.EdgeFlagPointer(stride, pointer_ptr);
            }
        }

        // IndexPointer overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void IndexPointer(this GL glInstance, IndexPointerType type, int stride, IntPtr pointer)
        {
            var pointer_vptr = (void*)pointer;
            glInstance.IndexPointer(type, stride, pointer_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void IndexPointer<T1>(this GL glInstance, IndexPointerType type, int stride, ReadOnlySpan<T1> pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.IndexPointer(type, stride, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void IndexPointer<T1>(this GL glInstance, IndexPointerType type, int stride, T1[] pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.IndexPointer(type, stride, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void IndexPointer<T1>(this GL glInstance, IndexPointerType type, int stride, in T1 pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = &pointer) // RefInsteadOfPointerLayer
            {
                glInstance.IndexPointer(type, stride, pointer_ptr);
            }
        }

        // InterleavedArrays overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void InterleavedArrays(this GL glInstance, InterleavedArrayFormat format, int stride, IntPtr pointer)
        {
            var pointer_vptr = (void*)pointer;
            glInstance.InterleavedArrays(format, stride, pointer_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void InterleavedArrays<T1>(this GL glInstance, InterleavedArrayFormat format, int stride, ReadOnlySpan<T1> pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.InterleavedArrays(format, stride, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void InterleavedArrays<T1>(this GL glInstance, InterleavedArrayFormat format, int stride, T1[] pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.InterleavedArrays(format, stride, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void InterleavedArrays<T1>(this GL glInstance, InterleavedArrayFormat format, int stride, in T1 pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = &pointer) // RefInsteadOfPointerLayer
            {
                glInstance.InterleavedArrays(format, stride, pointer_ptr);
            }
        }

        // NormalPointer overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void NormalPointer(this GL glInstance, NormalPointerType type, int stride, IntPtr pointer)
        {
            var pointer_vptr = (void*)pointer;
            glInstance.NormalPointer(type, stride, pointer_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void NormalPointer<T1>(this GL glInstance, NormalPointerType type, int stride, ReadOnlySpan<T1> pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.NormalPointer(type, stride, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void NormalPointer<T1>(this GL glInstance, NormalPointerType type, int stride, T1[] pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.NormalPointer(type, stride, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void NormalPointer<T1>(this GL glInstance, NormalPointerType type, int stride, in T1 pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = &pointer) // RefInsteadOfPointerLayer
            {
                glInstance.NormalPointer(type, stride, pointer_ptr);
            }
        }

        // TexCoordPointer overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void TexCoordPointer(this GL glInstance, int size, TexCoordPointerType type, int stride, IntPtr pointer)
        {
            var pointer_vptr = (void*)pointer;
            glInstance.TexCoordPointer(size, type, stride, pointer_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoordPointer<T1>(this GL glInstance, int size, TexCoordPointerType type, int stride, ReadOnlySpan<T1> pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.TexCoordPointer(size, type, stride, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoordPointer<T1>(this GL glInstance, int size, TexCoordPointerType type, int stride, T1[] pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.TexCoordPointer(size, type, stride, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoordPointer<T1>(this GL glInstance, int size, TexCoordPointerType type, int stride, in T1 pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = &pointer) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoordPointer(size, type, stride, pointer_ptr);
            }
        }

        // VertexPointer overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void VertexPointer(this GL glInstance, int size, VertexPointerType type, int stride, IntPtr pointer)
        {
            var pointer_vptr = (void*)pointer;
            glInstance.VertexPointer(size, type, stride, pointer_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexPointer<T1>(this GL glInstance, int size, VertexPointerType type, int stride, ReadOnlySpan<T1> pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.VertexPointer(size, type, stride, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexPointer<T1>(this GL glInstance, int size, VertexPointerType type, int stride, T1[] pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.VertexPointer(size, type, stride, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexPointer<T1>(this GL glInstance, int size, VertexPointerType type, int stride, in T1 pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = &pointer) // RefInsteadOfPointerLayer
            {
                glInstance.VertexPointer(size, type, stride, pointer_ptr);
            }
        }

        // AreTexturesResident overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe byte AreTexturesResident(this GL glInstance, int n, ReadOnlySpan<TextureHandle> textures, Span<byte> residences)
        {
            byte returnValue;
            fixed (TextureHandle* textures_ptr = textures) // SpanOrArrayLayer
            {
                fixed (byte* residences_ptr = residences) // SpanOrArrayLayer
                {
                    returnValue = glInstance.AreTexturesResident(n, textures_ptr, residences_ptr);
                }
            }
            return returnValue;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe byte AreTexturesResident(this GL glInstance, int n, TextureHandle[] textures, byte[] residences)
        {
            byte returnValue;
            fixed (TextureHandle* textures_ptr = textures) // SpanOrArrayLayer
            {
                fixed (byte* residences_ptr = residences) // SpanOrArrayLayer
                {
                    returnValue = glInstance.AreTexturesResident(n, textures_ptr, residences_ptr);
                }
            }
            return returnValue;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe byte AreTexturesResident(this GL glInstance, int n, in TextureHandle textures, ref byte residences)
        {
            byte returnValue;
            fixed (TextureHandle* textures_ptr = &textures) // RefInsteadOfPointerLayer
            fixed (byte* residences_ptr = &residences) // RefInsteadOfPointerLayer
            {
                returnValue = glInstance.AreTexturesResident(n, textures_ptr, residences_ptr);
            }
            return returnValue;
        }

        // PrioritizeTextures overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PrioritizeTextures(this GL glInstance, int n, ReadOnlySpan<TextureHandle> textures, ReadOnlySpan<float> priorities)
        {
            fixed (TextureHandle* textures_ptr = textures) // SpanOrArrayLayer
            {
                fixed (float* priorities_ptr = priorities) // SpanOrArrayLayer
                {
                    glInstance.PrioritizeTextures(n, textures_ptr, priorities_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PrioritizeTextures(this GL glInstance, int n, TextureHandle[] textures, float[] priorities)
        {
            fixed (TextureHandle* textures_ptr = textures) // SpanOrArrayLayer
            {
                fixed (float* priorities_ptr = priorities) // SpanOrArrayLayer
                {
                    glInstance.PrioritizeTextures(n, textures_ptr, priorities_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void PrioritizeTextures(this GL glInstance, int n, in TextureHandle textures, in float priorities)
        {
            fixed (TextureHandle* textures_ptr = &textures) // RefInsteadOfPointerLayer
            fixed (float* priorities_ptr = &priorities) // RefInsteadOfPointerLayer
            {
                glInstance.PrioritizeTextures(n, textures_ptr, priorities_ptr);
            }
        }

        // Indexub overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void Index(this GL glInstance, byte c) =>
            glInstance.Indexub(c);

        // Indexubv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Index(this GL glInstance, ReadOnlySpan<byte> c)
        {
            fixed (byte* c_ptr = c) // SpanOrArrayLayer
            {
                glInstance.Indexubv(c_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Index(this GL glInstance, byte[] c)
        {
            fixed (byte* c_ptr = c) // SpanOrArrayLayer
            {
                glInstance.Indexubv(c_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Index(this GL glInstance, in byte c)
        {
            fixed (byte* c_ptr = &c) // RefInsteadOfPointerLayer
            {
                glInstance.Indexubv(c_ptr);
            }
        }

        // DrawRangeElements overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void DrawRangeElements(this GL glInstance, PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, nint offset)
        {
            void* indices = (void*)offset;
            glInstance.DrawRangeElements(mode, start, end, count, type, indices);
        }

        // TexImage3D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void TexImage3D(this GL glInstance, TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.TexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexImage3D<T1>(this GL glInstance, TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.TexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexImage3D<T1>(this GL glInstance, TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, T1[] pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.TexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexImage3D<T1>(this GL glInstance, TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.TexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels_ptr);
            }
        }

        // TexSubImage3D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void TexSubImage3D(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexSubImage3D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexSubImage3D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, T1[] pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexSubImage3D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_ptr);
            }
        }

        // SampleCoverage overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void SampleCoverage(this GL glInstance, float value, bool invert)
        {
            var invert_byte = (byte)(invert ? 1 : 0);
            glInstance.SampleCoverage(value, invert_byte);
        }

        // CompressedTexImage3D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void CompressedTexImage3D(this GL glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.CompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexImage3D<T1>(this GL glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexImage3D<T1>(this GL glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, T1[] data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CompressedTexImage3D<T1>(this GL glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.CompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data_ptr);
            }
        }

        // CompressedTexImage2D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void CompressedTexImage2D(this GL glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexImage2D<T1>(this GL glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexImage2D<T1>(this GL glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, T1[] data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CompressedTexImage2D<T1>(this GL glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data_ptr);
            }
        }

        // CompressedTexImage1D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void CompressedTexImage1D(this GL glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.CompressedTexImage1D(target, level, internalformat, width, border, imageSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexImage1D<T1>(this GL glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int border, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexImage1D(target, level, internalformat, width, border, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexImage1D<T1>(this GL glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int border, T1[] data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexImage1D(target, level, internalformat, width, border, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CompressedTexImage1D<T1>(this GL glInstance, TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.CompressedTexImage1D(target, level, internalformat, width, border, imageSize, data_ptr);
            }
        }

        // CompressedTexSubImage3D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void CompressedTexSubImage3D(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexSubImage3D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexSubImage3D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, T1[] data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CompressedTexSubImage3D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_ptr);
            }
        }

        // CompressedTexSubImage2D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void CompressedTexSubImage2D(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexSubImage2D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexSubImage2D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, T1[] data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CompressedTexSubImage2D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data_ptr);
            }
        }

        // CompressedTexSubImage1D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void CompressedTexSubImage1D(this GL glInstance, TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.CompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexSubImage1D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int width, InternalFormat format, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CompressedTexSubImage1D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int width, InternalFormat format, T1[] data)
            where T1 : unmanaged
        {
            var imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.CompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CompressedTexSubImage1D<T1>(this GL glInstance, TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.CompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data_ptr);
            }
        }

        // GetCompressedTexImage overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetCompressedTexImage(this GL glInstance, TextureTarget target, int level, IntPtr img)
        {
            var img_vptr = (void*)img;
            glInstance.GetCompressedTexImage(target, level, img_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetCompressedTexImage<T1>(this GL glInstance, TextureTarget target, int level, Span<T1> img)
            where T1 : unmanaged
        {
            fixed (void* img_ptr = img) // SpanOrArrayLayer
            {
                glInstance.GetCompressedTexImage(target, level, img_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetCompressedTexImage<T1>(this GL glInstance, TextureTarget target, int level, T1[] img)
            where T1 : unmanaged
        {
            fixed (void* img_ptr = img) // SpanOrArrayLayer
            {
                glInstance.GetCompressedTexImage(target, level, img_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetCompressedTexImage<T1>(this GL glInstance, TextureTarget target, int level, ref T1 img)
            where T1 : unmanaged
        {
            fixed (void* img_ptr = &img) // RefInsteadOfPointerLayer
            {
                glInstance.GetCompressedTexImage(target, level, img_ptr);
            }
        }

        // MultiTexCoord1dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord1dv(this GL glInstance, TextureUnit target, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord1dv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord1dv(this GL glInstance, TextureUnit target, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord1dv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord1dv(this GL glInstance, TextureUnit target, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord1dv(target, v_ptr);
            }
        }

        // MultiTexCoord1fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord1fv(this GL glInstance, TextureUnit target, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord1fv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord1fv(this GL glInstance, TextureUnit target, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord1fv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord1fv(this GL glInstance, TextureUnit target, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord1fv(target, v_ptr);
            }
        }

        // MultiTexCoord1iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord1iv(this GL glInstance, TextureUnit target, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord1iv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord1iv(this GL glInstance, TextureUnit target, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord1iv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord1iv(this GL glInstance, TextureUnit target, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord1iv(target, v_ptr);
            }
        }

        // MultiTexCoord1s overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void MultiTexCoord1(this GL glInstance, TextureUnit target, short s) =>
            glInstance.MultiTexCoord1s(target, s);

        // MultiTexCoord1sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord1(this GL glInstance, TextureUnit target, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord1sv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord1(this GL glInstance, TextureUnit target, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord1sv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord1(this GL glInstance, TextureUnit target, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord1sv(target, v_ptr);
            }
        }

        // MultiTexCoord2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord2dv(this GL glInstance, TextureUnit target, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord2dv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord2dv(this GL glInstance, TextureUnit target, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord2dv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord2dv(this GL glInstance, TextureUnit target, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord2dv(target, v_ptr);
            }
        }

        // MultiTexCoord2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord2fv(this GL glInstance, TextureUnit target, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord2fv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord2fv(this GL glInstance, TextureUnit target, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord2fv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord2fv(this GL glInstance, TextureUnit target, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord2fv(target, v_ptr);
            }
        }

        // MultiTexCoord2iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord2iv(this GL glInstance, TextureUnit target, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord2iv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord2iv(this GL glInstance, TextureUnit target, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord2iv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord2iv(this GL glInstance, TextureUnit target, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord2iv(target, v_ptr);
            }
        }

        // MultiTexCoord2s overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void MultiTexCoord2(this GL glInstance, TextureUnit target, short s, short t) =>
            glInstance.MultiTexCoord2s(target, s, t);

        // MultiTexCoord2sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord2(this GL glInstance, TextureUnit target, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord2sv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord2(this GL glInstance, TextureUnit target, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord2sv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord2(this GL glInstance, TextureUnit target, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord2sv(target, v_ptr);
            }
        }

        // MultiTexCoord3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord3dv(this GL glInstance, TextureUnit target, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord3dv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord3dv(this GL glInstance, TextureUnit target, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord3dv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord3dv(this GL glInstance, TextureUnit target, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord3dv(target, v_ptr);
            }
        }

        // MultiTexCoord3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord3fv(this GL glInstance, TextureUnit target, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord3fv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord3fv(this GL glInstance, TextureUnit target, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord3fv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord3fv(this GL glInstance, TextureUnit target, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord3fv(target, v_ptr);
            }
        }

        // MultiTexCoord3iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord3iv(this GL glInstance, TextureUnit target, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord3iv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord3iv(this GL glInstance, TextureUnit target, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord3iv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord3iv(this GL glInstance, TextureUnit target, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord3iv(target, v_ptr);
            }
        }

        // MultiTexCoord3s overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void MultiTexCoord3(this GL glInstance, TextureUnit target, short s, short t, short r) =>
            glInstance.MultiTexCoord3s(target, s, t, r);

        // MultiTexCoord3sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord3(this GL glInstance, TextureUnit target, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord3sv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord3(this GL glInstance, TextureUnit target, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord3sv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord3(this GL glInstance, TextureUnit target, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord3sv(target, v_ptr);
            }
        }

        // MultiTexCoord4dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord4dv(this GL glInstance, TextureUnit target, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord4dv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord4dv(this GL glInstance, TextureUnit target, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord4dv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord4dv(this GL glInstance, TextureUnit target, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord4dv(target, v_ptr);
            }
        }

        // MultiTexCoord4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord4fv(this GL glInstance, TextureUnit target, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord4fv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord4fv(this GL glInstance, TextureUnit target, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord4fv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord4fv(this GL glInstance, TextureUnit target, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord4fv(target, v_ptr);
            }
        }

        // MultiTexCoord4iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord4iv(this GL glInstance, TextureUnit target, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord4iv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord4iv(this GL glInstance, TextureUnit target, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord4iv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord4iv(this GL glInstance, TextureUnit target, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord4iv(target, v_ptr);
            }
        }

        // MultiTexCoord4s overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void MultiTexCoord4(this GL glInstance, TextureUnit target, short s, short t, short r, short q) =>
            glInstance.MultiTexCoord4s(target, s, t, r, q);

        // MultiTexCoord4sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord4(this GL glInstance, TextureUnit target, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord4sv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoord4(this GL glInstance, TextureUnit target, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoord4sv(target, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoord4(this GL glInstance, TextureUnit target, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoord4sv(target, v_ptr);
            }
        }

        // LoadTransposeMatrixf overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void LoadTransposeMatrixf(this GL glInstance, ReadOnlySpan<float> m)
        {
            fixed (float* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.LoadTransposeMatrixf(m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void LoadTransposeMatrixf(this GL glInstance, float[] m)
        {
            fixed (float* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.LoadTransposeMatrixf(m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void LoadTransposeMatrixf(this GL glInstance, in float m)
        {
            fixed (float* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.LoadTransposeMatrixf(m_ptr);
            }
        }

        // LoadTransposeMatrixd overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void LoadTransposeMatrixd(this GL glInstance, ReadOnlySpan<double> m)
        {
            fixed (double* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.LoadTransposeMatrixd(m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void LoadTransposeMatrixd(this GL glInstance, double[] m)
        {
            fixed (double* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.LoadTransposeMatrixd(m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void LoadTransposeMatrixd(this GL glInstance, in double m)
        {
            fixed (double* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.LoadTransposeMatrixd(m_ptr);
            }
        }

        // MultTransposeMatrixf overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultTransposeMatrixf(this GL glInstance, ReadOnlySpan<float> m)
        {
            fixed (float* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MultTransposeMatrixf(m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultTransposeMatrixf(this GL glInstance, float[] m)
        {
            fixed (float* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MultTransposeMatrixf(m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultTransposeMatrixf(this GL glInstance, in float m)
        {
            fixed (float* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.MultTransposeMatrixf(m_ptr);
            }
        }

        // MultTransposeMatrixd overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultTransposeMatrixd(this GL glInstance, ReadOnlySpan<double> m)
        {
            fixed (double* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MultTransposeMatrixd(m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultTransposeMatrixd(this GL glInstance, double[] m)
        {
            fixed (double* m_ptr = m) // SpanOrArrayLayer
            {
                glInstance.MultTransposeMatrixd(m_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultTransposeMatrixd(this GL glInstance, in double m)
        {
            fixed (double* m_ptr = &m) // RefInsteadOfPointerLayer
            {
                glInstance.MultTransposeMatrixd(m_ptr);
            }
        }

        // MultiDrawArrays overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiDrawArrays(this GL glInstance, PrimitiveType mode, ReadOnlySpan<int> first, ReadOnlySpan<int> count, int drawcount)
        {
            fixed (int* first_ptr = first) // SpanOrArrayLayer
            {
                fixed (int* count_ptr = count) // SpanOrArrayLayer
                {
                    glInstance.MultiDrawArrays(mode, first_ptr, count_ptr, drawcount);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiDrawArrays(this GL glInstance, PrimitiveType mode, int[] first, int[] count, int drawcount)
        {
            fixed (int* first_ptr = first) // SpanOrArrayLayer
            {
                fixed (int* count_ptr = count) // SpanOrArrayLayer
                {
                    glInstance.MultiDrawArrays(mode, first_ptr, count_ptr, drawcount);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiDrawArrays(this GL glInstance, PrimitiveType mode, in int first, in int count, int drawcount)
        {
            fixed (int* first_ptr = &first) // RefInsteadOfPointerLayer
            fixed (int* count_ptr = &count) // RefInsteadOfPointerLayer
            {
                glInstance.MultiDrawArrays(mode, first_ptr, count_ptr, drawcount);
            }
        }

        // MultiDrawElements overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiDrawElements(this GL glInstance, PrimitiveType mode, ReadOnlySpan<int> count, DrawElementsType type, void** indices, int drawcount)
        {
            fixed (int* count_ptr = count) // SpanOrArrayLayer
            {
                glInstance.MultiDrawElements(mode, count_ptr, type, indices, drawcount);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiDrawElements(this GL glInstance, PrimitiveType mode, int[] count, DrawElementsType type, void** indices, int drawcount)
        {
            fixed (int* count_ptr = count) // SpanOrArrayLayer
            {
                glInstance.MultiDrawElements(mode, count_ptr, type, indices, drawcount);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiDrawElements(this GL glInstance, PrimitiveType mode, in int count, DrawElementsType type, void** indices, int drawcount)
        {
            fixed (int* count_ptr = &count) // RefInsteadOfPointerLayer
            {
                glInstance.MultiDrawElements(mode, count_ptr, type, indices, drawcount);
            }
        }

        // PointParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PointParameterf(this GL glInstance, PointParameterNameARB pname, ReadOnlySpan<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.PointParameterfv(pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PointParameterf(this GL glInstance, PointParameterNameARB pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.PointParameterfv(pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void PointParameterf(this GL glInstance, PointParameterNameARB pname, in float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.PointParameterfv(pname, parameters_ptr);
            }
        }

        // PointParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PointParameteri(this GL glInstance, PointParameterNameARB pname, ReadOnlySpan<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.PointParameteriv(pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PointParameteri(this GL glInstance, PointParameterNameARB pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.PointParameteriv(pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void PointParameteri(this GL glInstance, PointParameterNameARB pname, in int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.PointParameteriv(pname, parameters_ptr);
            }
        }

        // FogCoordfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void FogCoordf(this GL glInstance, ReadOnlySpan<float> coord)
        {
            fixed (float* coord_ptr = coord) // SpanOrArrayLayer
            {
                glInstance.FogCoordfv(coord_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void FogCoordf(this GL glInstance, float[] coord)
        {
            fixed (float* coord_ptr = coord) // SpanOrArrayLayer
            {
                glInstance.FogCoordfv(coord_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void FogCoordf(this GL glInstance, in float coord)
        {
            fixed (float* coord_ptr = &coord) // RefInsteadOfPointerLayer
            {
                glInstance.FogCoordfv(coord_ptr);
            }
        }

        // FogCoorddv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void FogCoordd(this GL glInstance, ReadOnlySpan<double> coord)
        {
            fixed (double* coord_ptr = coord) // SpanOrArrayLayer
            {
                glInstance.FogCoorddv(coord_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void FogCoordd(this GL glInstance, double[] coord)
        {
            fixed (double* coord_ptr = coord) // SpanOrArrayLayer
            {
                glInstance.FogCoorddv(coord_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void FogCoordd(this GL glInstance, in double coord)
        {
            fixed (double* coord_ptr = &coord) // RefInsteadOfPointerLayer
            {
                glInstance.FogCoorddv(coord_ptr);
            }
        }

        // FogCoordPointer overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void FogCoordPointer(this GL glInstance, FogPointerTypeEXT type, int stride, IntPtr pointer)
        {
            var pointer_vptr = (void*)pointer;
            glInstance.FogCoordPointer(type, stride, pointer_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void FogCoordPointer<T1>(this GL glInstance, FogPointerTypeEXT type, int stride, ReadOnlySpan<T1> pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.FogCoordPointer(type, stride, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void FogCoordPointer<T1>(this GL glInstance, FogPointerTypeEXT type, int stride, T1[] pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.FogCoordPointer(type, stride, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void FogCoordPointer<T1>(this GL glInstance, FogPointerTypeEXT type, int stride, in T1 pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = &pointer) // RefInsteadOfPointerLayer
            {
                glInstance.FogCoordPointer(type, stride, pointer_ptr);
            }
        }

        // SecondaryColor3b overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void SecondaryColor3(this GL glInstance, sbyte red, sbyte green, sbyte blue) =>
            glInstance.SecondaryColor3b(red, green, blue);

        // SecondaryColor3bv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SecondaryColor3(this GL glInstance, ReadOnlySpan<sbyte> v)
        {
            fixed (sbyte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.SecondaryColor3bv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SecondaryColor3(this GL glInstance, sbyte[] v)
        {
            fixed (sbyte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.SecondaryColor3bv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SecondaryColor3(this GL glInstance, in sbyte v)
        {
            fixed (sbyte* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.SecondaryColor3bv(v_ptr);
            }
        }

        // SecondaryColor3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SecondaryColor3dv(this GL glInstance, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.SecondaryColor3dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SecondaryColor3dv(this GL glInstance, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.SecondaryColor3dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SecondaryColor3dv(this GL glInstance, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.SecondaryColor3dv(v_ptr);
            }
        }

        // SecondaryColor3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SecondaryColor3fv(this GL glInstance, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.SecondaryColor3fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SecondaryColor3fv(this GL glInstance, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.SecondaryColor3fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SecondaryColor3fv(this GL glInstance, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.SecondaryColor3fv(v_ptr);
            }
        }

        // SecondaryColor3iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SecondaryColor3iv(this GL glInstance, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.SecondaryColor3iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SecondaryColor3iv(this GL glInstance, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.SecondaryColor3iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SecondaryColor3iv(this GL glInstance, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.SecondaryColor3iv(v_ptr);
            }
        }

        // SecondaryColor3s overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void SecondaryColor3(this GL glInstance, short red, short green, short blue) =>
            glInstance.SecondaryColor3s(red, green, blue);

        // SecondaryColor3sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SecondaryColor3(this GL glInstance, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.SecondaryColor3sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SecondaryColor3(this GL glInstance, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.SecondaryColor3sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SecondaryColor3(this GL glInstance, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.SecondaryColor3sv(v_ptr);
            }
        }

        // SecondaryColor3ub overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void SecondaryColor3(this GL glInstance, byte red, byte green, byte blue) =>
            glInstance.SecondaryColor3ub(red, green, blue);

        // SecondaryColor3ubv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SecondaryColor3(this GL glInstance, ReadOnlySpan<byte> v)
        {
            fixed (byte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.SecondaryColor3ubv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SecondaryColor3(this GL glInstance, byte[] v)
        {
            fixed (byte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.SecondaryColor3ubv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SecondaryColor3(this GL glInstance, in byte v)
        {
            fixed (byte* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.SecondaryColor3ubv(v_ptr);
            }
        }

        // SecondaryColor3uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SecondaryColor3ui(this GL glInstance, ReadOnlySpan<uint> v)
        {
            fixed (uint* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.SecondaryColor3uiv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SecondaryColor3ui(this GL glInstance, uint[] v)
        {
            fixed (uint* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.SecondaryColor3uiv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SecondaryColor3ui(this GL glInstance, in uint v)
        {
            fixed (uint* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.SecondaryColor3uiv(v_ptr);
            }
        }

        // SecondaryColor3us overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void SecondaryColor3(this GL glInstance, ushort red, ushort green, ushort blue) =>
            glInstance.SecondaryColor3us(red, green, blue);

        // SecondaryColor3usv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SecondaryColor3(this GL glInstance, ReadOnlySpan<ushort> v)
        {
            fixed (ushort* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.SecondaryColor3usv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SecondaryColor3(this GL glInstance, ushort[] v)
        {
            fixed (ushort* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.SecondaryColor3usv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SecondaryColor3(this GL glInstance, in ushort v)
        {
            fixed (ushort* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.SecondaryColor3usv(v_ptr);
            }
        }

        // SecondaryColorPointer overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void SecondaryColorPointer(this GL glInstance, int size, ColorPointerType type, int stride, IntPtr pointer)
        {
            var pointer_vptr = (void*)pointer;
            glInstance.SecondaryColorPointer(size, type, stride, pointer_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SecondaryColorPointer<T1>(this GL glInstance, int size, ColorPointerType type, int stride, ReadOnlySpan<T1> pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.SecondaryColorPointer(size, type, stride, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SecondaryColorPointer<T1>(this GL glInstance, int size, ColorPointerType type, int stride, T1[] pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = pointer) // SpanOrArrayLayer
            {
                glInstance.SecondaryColorPointer(size, type, stride, pointer_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SecondaryColorPointer<T1>(this GL glInstance, int size, ColorPointerType type, int stride, in T1 pointer)
            where T1 : unmanaged
        {
            fixed (void* pointer_ptr = &pointer) // RefInsteadOfPointerLayer
            {
                glInstance.SecondaryColorPointer(size, type, stride, pointer_ptr);
            }
        }

        // WindowPos2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos2dv(this GL glInstance, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos2dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos2dv(this GL glInstance, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos2dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WindowPos2dv(this GL glInstance, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.WindowPos2dv(v_ptr);
            }
        }

        // WindowPos2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos2fv(this GL glInstance, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos2fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos2fv(this GL glInstance, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos2fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WindowPos2fv(this GL glInstance, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.WindowPos2fv(v_ptr);
            }
        }

        // WindowPos2iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos2iv(this GL glInstance, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos2iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos2iv(this GL glInstance, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos2iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WindowPos2iv(this GL glInstance, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.WindowPos2iv(v_ptr);
            }
        }

        // WindowPos2s overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void WindowPos2(this GL glInstance, short x, short y) =>
            glInstance.WindowPos2s(x, y);

        // WindowPos2sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos2(this GL glInstance, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos2sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos2(this GL glInstance, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos2sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WindowPos2(this GL glInstance, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.WindowPos2sv(v_ptr);
            }
        }

        // WindowPos3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos3dv(this GL glInstance, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos3dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos3dv(this GL glInstance, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos3dv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WindowPos3dv(this GL glInstance, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.WindowPos3dv(v_ptr);
            }
        }

        // WindowPos3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos3fv(this GL glInstance, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos3fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos3fv(this GL glInstance, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos3fv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WindowPos3fv(this GL glInstance, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.WindowPos3fv(v_ptr);
            }
        }

        // WindowPos3iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos3iv(this GL glInstance, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos3iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos3iv(this GL glInstance, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos3iv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WindowPos3iv(this GL glInstance, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.WindowPos3iv(v_ptr);
            }
        }

        // WindowPos3s overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void WindowPos3(this GL glInstance, short x, short y, short z) =>
            glInstance.WindowPos3s(x, y, z);

        // WindowPos3sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos3(this GL glInstance, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos3sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void WindowPos3(this GL glInstance, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.WindowPos3sv(v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void WindowPos3(this GL glInstance, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.WindowPos3sv(v_ptr);
            }
        }

        // GenQueries overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe QueryHandle GenQuerie(this GL glInstance)
        {
            QueryHandle ids;
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            QueryHandle* ids_handle = (QueryHandle*)Unsafe.AsPointer(ref ids);
            glInstance.GenQueries(n, ids_handle);
            return ids;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void GenQuerie(this GL glInstance, out QueryHandle ids)
        {
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            QueryHandle* ids_handle = (QueryHandle*)Unsafe.AsPointer(ref ids);
            glInstance.GenQueries(n, ids_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenQueries(this GL glInstance, Span<QueryHandle> ids)
        {
            var n = (int)(ids.Length);
            fixed (QueryHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.GenQueries(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenQueries(this GL glInstance, QueryHandle[] ids)
        {
            var n = (int)(ids.Length);
            fixed (QueryHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.GenQueries(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenQueries(this GL glInstance, int n, ref QueryHandle ids)
        {
            fixed (QueryHandle* ids_ptr = &ids) // RefInsteadOfPointerLayer
            {
                glInstance.GenQueries(n, ids_ptr);
            }
        }

        // DeleteQueries overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void DeleteQuerie(this GL glInstance, in QueryHandle ids)
        {
            int n = 1;
            fixed(QueryHandle* ids_handle = &ids) // DeleteOverloadLayer
                glInstance.DeleteQueries(n, ids_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteQueries(this GL glInstance, ReadOnlySpan<QueryHandle> ids)
        {
            var n = (int)(ids.Length);
            fixed (QueryHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.DeleteQueries(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteQueries(this GL glInstance, QueryHandle[] ids)
        {
            var n = (int)(ids.Length);
            fixed (QueryHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.DeleteQueries(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteQueries(this GL glInstance, int n, in QueryHandle ids)
        {
            fixed (QueryHandle* ids_ptr = &ids) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteQueries(n, ids_ptr);
            }
        }

        // GetQueryiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryi(this GL glInstance, QueryTarget target, QueryParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryiv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryi(this GL glInstance, QueryTarget target, QueryParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryiv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetQueryi(this GL glInstance, QueryTarget target, QueryParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetQueryiv(target, pname, parameters_ptr);
            }
        }

        // GetQueryObjectiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryObjecti(this GL glInstance, QueryHandle id, QueryObjectParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryObjectiv(id, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryObjecti(this GL glInstance, QueryHandle id, QueryObjectParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryObjectiv(id, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetQueryObjecti(this GL glInstance, QueryHandle id, QueryObjectParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetQueryObjectiv(id, pname, parameters_ptr);
            }
        }

        // GetQueryObjectuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryObjectui(this GL glInstance, QueryHandle id, QueryObjectParameterName pname, Span<uint> parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryObjectuiv(id, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryObjectui(this GL glInstance, QueryHandle id, QueryObjectParameterName pname, uint[] parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryObjectuiv(id, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetQueryObjectui(this GL glInstance, QueryHandle id, QueryObjectParameterName pname, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetQueryObjectuiv(id, pname, parameters_ptr);
            }
        }

        // DeleteBuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void DeleteBuffer(this GL glInstance, in BufferHandle buffers)
        {
            int n = 1;
            fixed(BufferHandle* buffers_handle = &buffers) // DeleteOverloadLayer
                glInstance.DeleteBuffers(n, buffers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteBuffers(this GL glInstance, ReadOnlySpan<BufferHandle> buffers)
        {
            var n = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                glInstance.DeleteBuffers(n, buffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteBuffers(this GL glInstance, BufferHandle[] buffers)
        {
            var n = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                glInstance.DeleteBuffers(n, buffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteBuffers(this GL glInstance, int n, in BufferHandle buffers)
        {
            fixed (BufferHandle* buffers_ptr = &buffers) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteBuffers(n, buffers_ptr);
            }
        }

        // GenBuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe BufferHandle GenBuffer(this GL glInstance)
        {
            BufferHandle buffers;
            int n = 1;
            Unsafe.SkipInit(out buffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            BufferHandle* buffers_handle = (BufferHandle*)Unsafe.AsPointer(ref buffers);
            glInstance.GenBuffers(n, buffers_handle);
            return buffers;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void GenBuffer(this GL glInstance, out BufferHandle buffers)
        {
            int n = 1;
            Unsafe.SkipInit(out buffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            BufferHandle* buffers_handle = (BufferHandle*)Unsafe.AsPointer(ref buffers);
            glInstance.GenBuffers(n, buffers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenBuffers(this GL glInstance, Span<BufferHandle> buffers)
        {
            var n = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                glInstance.GenBuffers(n, buffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenBuffers(this GL glInstance, BufferHandle[] buffers)
        {
            var n = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                glInstance.GenBuffers(n, buffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenBuffers(this GL glInstance, int n, ref BufferHandle buffers)
        {
            fixed (BufferHandle* buffers_ptr = &buffers) // RefInsteadOfPointerLayer
            {
                glInstance.GenBuffers(n, buffers_ptr);
            }
        }

        // BufferData overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void BufferData(this GL glInstance, BufferTargetARB target, nint size, IntPtr data, BufferUsageARB usage)
        {
            var data_vptr = (void*)data;
            glInstance.BufferData(target, size, data_vptr, usage);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BufferData<T1>(this GL glInstance, BufferTargetARB target, ReadOnlySpan<T1> data, BufferUsageARB usage)
            where T1 : unmanaged
        {
            var size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.BufferData(target, size, data_ptr, usage);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BufferData<T1>(this GL glInstance, BufferTargetARB target, T1[] data, BufferUsageARB usage)
            where T1 : unmanaged
        {
            var size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.BufferData(target, size, data_ptr, usage);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void BufferData<T1>(this GL glInstance, BufferTargetARB target, nint size, in T1 data, BufferUsageARB usage)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.BufferData(target, size, data_ptr, usage);
            }
        }

        // BufferSubData overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void BufferSubData(this GL glInstance, BufferTargetARB target, IntPtr offset, nint size, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.BufferSubData(target, offset, size, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BufferSubData<T1>(this GL glInstance, BufferTargetARB target, IntPtr offset, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            var size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.BufferSubData(target, offset, size, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BufferSubData<T1>(this GL glInstance, BufferTargetARB target, IntPtr offset, T1[] data)
            where T1 : unmanaged
        {
            var size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.BufferSubData(target, offset, size, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void BufferSubData<T1>(this GL glInstance, BufferTargetARB target, IntPtr offset, nint size, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.BufferSubData(target, offset, size, data_ptr);
            }
        }

        // GetBufferSubData overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetBufferSubData(this GL glInstance, BufferTargetARB target, IntPtr offset, nint size, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.GetBufferSubData(target, offset, size, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetBufferSubData<T1>(this GL glInstance, BufferTargetARB target, IntPtr offset, Span<T1> data)
            where T1 : unmanaged
        {
            var size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetBufferSubData(target, offset, size, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetBufferSubData<T1>(this GL glInstance, BufferTargetARB target, IntPtr offset, T1[] data)
            where T1 : unmanaged
        {
            var size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetBufferSubData(target, offset, size, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetBufferSubData<T1>(this GL glInstance, BufferTargetARB target, IntPtr offset, nint size, ref T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetBufferSubData(target, offset, size, data_ptr);
            }
        }

        // GetBufferParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetBufferParameteri(this GL glInstance, BufferTargetARB target, BufferPNameARB pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetBufferParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetBufferParameteri(this GL glInstance, BufferTargetARB target, BufferPNameARB pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetBufferParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetBufferParameteri(this GL glInstance, BufferTargetARB target, BufferPNameARB pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetBufferParameteriv(target, pname, parameters_ptr);
            }
        }

        // GetBufferPointerv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void GetBufferPointer(this GL glInstance, BufferTargetARB target, BufferPointerNameARB pname, void** parameters) =>
            glInstance.GetBufferPointerv(target, pname, parameters);

        // DrawBuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DrawBuffers(this GL glInstance, ReadOnlySpan<DrawBufferMode> bufs)
        {
            var n = (int)(bufs.Length);
            fixed (DrawBufferMode* bufs_ptr = bufs) // SpanOrArrayLayer
            {
                glInstance.DrawBuffers(n, bufs_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DrawBuffers(this GL glInstance, DrawBufferMode[] bufs)
        {
            var n = (int)(bufs.Length);
            fixed (DrawBufferMode* bufs_ptr = bufs) // SpanOrArrayLayer
            {
                glInstance.DrawBuffers(n, bufs_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DrawBuffers(this GL glInstance, int n, in DrawBufferMode bufs)
        {
            fixed (DrawBufferMode* bufs_ptr = &bufs) // RefInsteadOfPointerLayer
            {
                glInstance.DrawBuffers(n, bufs_ptr);
            }
        }

        // BindAttribLocation overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe void BindAttribLocation(this GL glInstance, ProgramHandle program, uint index, string name)
        {
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            glInstance.BindAttribLocation(program, index, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
        }

        // GetActiveAttrib overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveAttrib(this GL glInstance, ProgramHandle program, uint index, int bufSize, Span<int> length, Span<int> size, Span<AttributeType> type)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (AttributeType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        glInstance.GetActiveAttrib(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveAttrib(this GL glInstance, ProgramHandle program, uint index, int bufSize, Span<int> length, Span<int> size, Span<AttributeType> type, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (AttributeType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        glInstance.GetActiveAttrib(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveAttrib(this GL glInstance, ProgramHandle program, uint index, int bufSize, int[] length, int[] size, AttributeType[] type)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (AttributeType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        glInstance.GetActiveAttrib(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveAttrib(this GL glInstance, ProgramHandle program, uint index, int bufSize, int[] length, int[] size, AttributeType[] type, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (AttributeType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        glInstance.GetActiveAttrib(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveAttrib(this GL glInstance, ProgramHandle program, uint index, int bufSize, ref int length, ref int size, ref AttributeType type)
        {
            string name;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (int* size_ptr = &size) // RefInsteadOfPointerLayer
            fixed (AttributeType* type_ptr = &type) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveAttrib(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveAttrib(this GL glInstance, ProgramHandle program, uint index, int bufSize, ref int length, ref int size, ref AttributeType type, out string name)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (int* size_ptr = &size) // RefInsteadOfPointerLayer
            fixed (AttributeType* type_ptr = &type) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveAttrib(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // GetActiveUniform overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveUniform(this GL glInstance, ProgramHandle program, uint index, int bufSize, Span<int> length, Span<int> size, Span<UniformType> type)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (UniformType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        glInstance.GetActiveUniform(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniform(this GL glInstance, ProgramHandle program, uint index, int bufSize, Span<int> length, Span<int> size, Span<UniformType> type, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (UniformType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        glInstance.GetActiveUniform(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveUniform(this GL glInstance, ProgramHandle program, uint index, int bufSize, int[] length, int[] size, UniformType[] type)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (UniformType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        glInstance.GetActiveUniform(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniform(this GL glInstance, ProgramHandle program, uint index, int bufSize, int[] length, int[] size, UniformType[] type, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (UniformType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        glInstance.GetActiveUniform(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveUniform(this GL glInstance, ProgramHandle program, uint index, int bufSize, ref int length, ref int size, ref UniformType type)
        {
            string name;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (int* size_ptr = &size) // RefInsteadOfPointerLayer
            fixed (UniformType* type_ptr = &type) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniform(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveUniform(this GL glInstance, ProgramHandle program, uint index, int bufSize, ref int length, ref int size, ref UniformType type, out string name)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (int* size_ptr = &size) // RefInsteadOfPointerLayer
            fixed (UniformType* type_ptr = &type) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniform(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // GetAttachedShaders overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetAttachedShaders(this GL glInstance, ProgramHandle program, Span<int> count, Span<ShaderHandle> shaders)
        {
            fixed (int* count_ptr = count) // SpanOrArrayLayer
            {
                var maxCount = (int)(shaders.Length);
                fixed (ShaderHandle* shaders_ptr = shaders) // SpanOrArrayLayer
                {
                    glInstance.GetAttachedShaders(program, maxCount, count_ptr, shaders_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetAttachedShaders(this GL glInstance, ProgramHandle program, int[] count, ShaderHandle[] shaders)
        {
            fixed (int* count_ptr = count) // SpanOrArrayLayer
            {
                var maxCount = (int)(shaders.Length);
                fixed (ShaderHandle* shaders_ptr = shaders) // SpanOrArrayLayer
                {
                    glInstance.GetAttachedShaders(program, maxCount, count_ptr, shaders_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetAttachedShaders(this GL glInstance, ProgramHandle program, int maxCount, ref int count, ref ShaderHandle shaders)
        {
            fixed (int* count_ptr = &count) // RefInsteadOfPointerLayer
            fixed (ShaderHandle* shaders_ptr = &shaders) // RefInsteadOfPointerLayer
            {
                glInstance.GetAttachedShaders(program, maxCount, count_ptr, shaders_ptr);
            }
        }

        // GetAttribLocation overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe int GetAttribLocation(this GL glInstance, ProgramHandle program, string name)
        {
            int returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = glInstance.GetAttribLocation(program, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }

        // GetProgramiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgrami(this GL glInstance, ProgramHandle program, ProgramPropertyARB pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramiv(program, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgrami(this GL glInstance, ProgramHandle program, ProgramPropertyARB pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramiv(program, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgrami(this GL glInstance, ProgramHandle program, ProgramPropertyARB pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetProgramiv(program, pname, parameters_ptr);
            }
        }

        // GetProgramInfoLog overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetProgramInfoLog(this GL glInstance, ProgramHandle program, int bufSize, Span<int> length)
        {
            string infoLog;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramInfoLog(program, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramInfoLog(this GL glInstance, ProgramHandle program, int bufSize, Span<int> length, out string infoLog)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramInfoLog(program, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetProgramInfoLog(this GL glInstance, ProgramHandle program, int bufSize, int[] length)
        {
            string infoLog;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramInfoLog(program, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramInfoLog(this GL glInstance, ProgramHandle program, int bufSize, int[] length, out string infoLog)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramInfoLog(program, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetProgramInfoLog(this GL glInstance, ProgramHandle program, int bufSize, ref int length)
        {
            string infoLog;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramInfoLog(program, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramInfoLog(this GL glInstance, ProgramHandle program, int bufSize, ref int length, out string infoLog)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramInfoLog(program, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }

        // GetShaderiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetShaderi(this GL glInstance, ShaderHandle shader, ShaderParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetShaderiv(shader, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetShaderi(this GL glInstance, ShaderHandle shader, ShaderParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetShaderiv(shader, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetShaderi(this GL glInstance, ShaderHandle shader, ShaderParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetShaderiv(shader, pname, parameters_ptr);
            }
        }

        // GetShaderInfoLog overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetShaderInfoLog(this GL glInstance, ShaderHandle shader, int bufSize, Span<int> length)
        {
            string infoLog;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetShaderInfoLog(shader, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetShaderInfoLog(this GL glInstance, ShaderHandle shader, int bufSize, Span<int> length, out string infoLog)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetShaderInfoLog(shader, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetShaderInfoLog(this GL glInstance, ShaderHandle shader, int bufSize, int[] length)
        {
            string infoLog;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetShaderInfoLog(shader, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetShaderInfoLog(this GL glInstance, ShaderHandle shader, int bufSize, int[] length, out string infoLog)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetShaderInfoLog(shader, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetShaderInfoLog(this GL glInstance, ShaderHandle shader, int bufSize, ref int length)
        {
            string infoLog;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetShaderInfoLog(shader, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetShaderInfoLog(this GL glInstance, ShaderHandle shader, int bufSize, ref int length, out string infoLog)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetShaderInfoLog(shader, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }

        // GetShaderSource overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetShaderSource(this GL glInstance, ShaderHandle shader, int bufSize, Span<int> length)
        {
            string source;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var source_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetShaderSource(shader, bufSize, length_ptr, source_ptr);
                source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)source_ptr);
            }
            return source;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetShaderSource(this GL glInstance, ShaderHandle shader, int bufSize, Span<int> length, out string source)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var source_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetShaderSource(shader, bufSize, length_ptr, source_ptr);
                source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)source_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetShaderSource(this GL glInstance, ShaderHandle shader, int bufSize, int[] length)
        {
            string source;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var source_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetShaderSource(shader, bufSize, length_ptr, source_ptr);
                source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)source_ptr);
            }
            return source;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetShaderSource(this GL glInstance, ShaderHandle shader, int bufSize, int[] length, out string source)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var source_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetShaderSource(shader, bufSize, length_ptr, source_ptr);
                source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)source_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetShaderSource(this GL glInstance, ShaderHandle shader, int bufSize, ref int length)
        {
            string source;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var source_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetShaderSource(shader, bufSize, length_ptr, source_ptr);
                source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)source_ptr);
            }
            return source;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetShaderSource(this GL glInstance, ShaderHandle shader, int bufSize, ref int length, out string source)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var source_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetShaderSource(shader, bufSize, length_ptr, source_ptr);
                source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)source_ptr);
            }
        }

        // GetUniformLocation overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe int GetUniformLocation(this GL glInstance, ProgramHandle program, string name)
        {
            int returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = glInstance.GetUniformLocation(program, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }

        // GetUniformfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformf(this GL glInstance, ProgramHandle program, int location, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformfv(program, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformf(this GL glInstance, ProgramHandle program, int location, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformfv(program, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetUniformf(this GL glInstance, ProgramHandle program, int location, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetUniformfv(program, location, parameters_ptr);
            }
        }

        // GetUniformiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformi(this GL glInstance, ProgramHandle program, int location, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformiv(program, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformi(this GL glInstance, ProgramHandle program, int location, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformiv(program, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetUniformi(this GL glInstance, ProgramHandle program, int location, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetUniformiv(program, location, parameters_ptr);
            }
        }

        // GetVertexAttribdv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribd(this GL glInstance, uint index, VertexAttribPropertyARB pname, Span<double> parameters)
        {
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribdv(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribd(this GL glInstance, uint index, VertexAttribPropertyARB pname, double[] parameters)
        {
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribdv(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetVertexAttribd(this GL glInstance, uint index, VertexAttribPropertyARB pname, ref double parameters)
        {
            fixed (double* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetVertexAttribdv(index, pname, parameters_ptr);
            }
        }

        // GetVertexAttribfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribf(this GL glInstance, uint index, VertexAttribPropertyARB pname, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribfv(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribf(this GL glInstance, uint index, VertexAttribPropertyARB pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribfv(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetVertexAttribf(this GL glInstance, uint index, VertexAttribPropertyARB pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetVertexAttribfv(index, pname, parameters_ptr);
            }
        }

        // GetVertexAttribiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribi(this GL glInstance, uint index, VertexAttribPropertyARB pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribiv(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribi(this GL glInstance, uint index, VertexAttribPropertyARB pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribiv(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetVertexAttribi(this GL glInstance, uint index, VertexAttribPropertyARB pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetVertexAttribiv(index, pname, parameters_ptr);
            }
        }

        // GetVertexAttribPointerv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void GetVertexAttribPointer(this GL glInstance, uint index, VertexAttribPointerPropertyARB pname, void** pointer) =>
            glInstance.GetVertexAttribPointerv(index, pname, pointer);

        // ShaderSource overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ShaderSource(this GL glInstance, ShaderHandle shader, int count, byte** str, ReadOnlySpan<int> length)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                glInstance.ShaderSource(shader, count, str, length_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ShaderSource(this GL glInstance, ShaderHandle shader, int count, byte** str, int[] length)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                glInstance.ShaderSource(shader, count, str, length_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ShaderSource(this GL glInstance, ShaderHandle shader, int count, byte** str, in int length)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                glInstance.ShaderSource(shader, count, str, length_ptr);
            }
        }

        // Uniform1fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1fv(this GL glInstance, int location, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 1);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1fv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1fv(this GL glInstance, int location, float[] value)
        {
            var count = (int)(value.Length / 1);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1fv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform1fv(this GL glInstance, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform1fv(location, count, value_ptr);
            }
        }

        // Uniform2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2fv(this GL glInstance, int location, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 2);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2fv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2fv(this GL glInstance, int location, float[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2fv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform2fv(this GL glInstance, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform2fv(location, count, value_ptr);
            }
        }

        // Uniform3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3fv(this GL glInstance, int location, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 3);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3fv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3fv(this GL glInstance, int location, float[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3fv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform3fv(this GL glInstance, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform3fv(location, count, value_ptr);
            }
        }

        // Uniform4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4fv(this GL glInstance, int location, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 4);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4fv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4fv(this GL glInstance, int location, float[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4fv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform4fv(this GL glInstance, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform4fv(location, count, value_ptr);
            }
        }

        // Uniform1iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1iv(this GL glInstance, int location, ReadOnlySpan<int> value)
        {
            var count = (int)(value.Length / 1);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1iv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1iv(this GL glInstance, int location, int[] value)
        {
            var count = (int)(value.Length / 1);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1iv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform1iv(this GL glInstance, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform1iv(location, count, value_ptr);
            }
        }

        // Uniform2iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2iv(this GL glInstance, int location, ReadOnlySpan<int> value)
        {
            var count = (int)(value.Length / 2);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2iv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2iv(this GL glInstance, int location, int[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2iv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform2iv(this GL glInstance, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform2iv(location, count, value_ptr);
            }
        }

        // Uniform3iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3iv(this GL glInstance, int location, ReadOnlySpan<int> value)
        {
            var count = (int)(value.Length / 3);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3iv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3iv(this GL glInstance, int location, int[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3iv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform3iv(this GL glInstance, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform3iv(location, count, value_ptr);
            }
        }

        // Uniform4iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4iv(this GL glInstance, int location, ReadOnlySpan<int> value)
        {
            var count = (int)(value.Length / 4);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4iv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4iv(this GL glInstance, int location, int[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4iv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform4iv(this GL glInstance, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform4iv(location, count, value_ptr);
            }
        }

        // UniformMatrix2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2fv(this GL glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 4);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2fv(this GL glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix2fv(this GL glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2fv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3fv(this GL glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 9);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3fv(this GL glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 9);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix3fv(this GL glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3fv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4fv(this GL glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 16);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4fv(this GL glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 16);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix4fv(this GL glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4fv(location, count, transpose_byte, value_ptr);
            }
        }

        // VertexAttrib1dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib1dv(this GL glInstance, uint index, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib1dv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib1dv(this GL glInstance, uint index, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib1dv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib1dv(this GL glInstance, uint index, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib1dv(index, v_ptr);
            }
        }

        // VertexAttrib1fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib1fv(this GL glInstance, uint index, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib1fv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib1fv(this GL glInstance, uint index, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib1fv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib1fv(this GL glInstance, uint index, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib1fv(index, v_ptr);
            }
        }

        // VertexAttrib1s overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void VertexAttrib1(this GL glInstance, uint index, short x) =>
            glInstance.VertexAttrib1s(index, x);

        // VertexAttrib1sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib1(this GL glInstance, uint index, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib1sv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib1(this GL glInstance, uint index, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib1sv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib1(this GL glInstance, uint index, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib1sv(index, v_ptr);
            }
        }

        // VertexAttrib2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib2dv(this GL glInstance, uint index, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib2dv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib2dv(this GL glInstance, uint index, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib2dv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib2dv(this GL glInstance, uint index, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib2dv(index, v_ptr);
            }
        }

        // VertexAttrib2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib2fv(this GL glInstance, uint index, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib2fv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib2fv(this GL glInstance, uint index, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib2fv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib2fv(this GL glInstance, uint index, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib2fv(index, v_ptr);
            }
        }

        // VertexAttrib2s overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void VertexAttrib2(this GL glInstance, uint index, short x, short y) =>
            glInstance.VertexAttrib2s(index, x, y);

        // VertexAttrib2sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib2(this GL glInstance, uint index, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib2sv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib2(this GL glInstance, uint index, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib2sv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib2(this GL glInstance, uint index, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib2sv(index, v_ptr);
            }
        }

        // VertexAttrib3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib3dv(this GL glInstance, uint index, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib3dv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib3dv(this GL glInstance, uint index, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib3dv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib3dv(this GL glInstance, uint index, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib3dv(index, v_ptr);
            }
        }

        // VertexAttrib3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib3fv(this GL glInstance, uint index, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib3fv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib3fv(this GL glInstance, uint index, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib3fv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib3fv(this GL glInstance, uint index, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib3fv(index, v_ptr);
            }
        }

        // VertexAttrib3s overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void VertexAttrib3(this GL glInstance, uint index, short x, short y, short z) =>
            glInstance.VertexAttrib3s(index, x, y, z);

        // VertexAttrib3sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib3(this GL glInstance, uint index, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib3sv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib3(this GL glInstance, uint index, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib3sv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib3(this GL glInstance, uint index, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib3sv(index, v_ptr);
            }
        }

        // VertexAttrib4Nbv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4N(this GL glInstance, uint index, ReadOnlySpan<sbyte> v)
        {
            fixed (sbyte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4Nbv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4N(this GL glInstance, uint index, sbyte[] v)
        {
            fixed (sbyte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4Nbv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4N(this GL glInstance, uint index, in sbyte v)
        {
            fixed (sbyte* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4Nbv(index, v_ptr);
            }
        }

        // VertexAttrib4Niv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4Ni(this GL glInstance, uint index, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4Niv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4Ni(this GL glInstance, uint index, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4Niv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4Ni(this GL glInstance, uint index, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4Niv(index, v_ptr);
            }
        }

        // VertexAttrib4Nsv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4N(this GL glInstance, uint index, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4Nsv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4N(this GL glInstance, uint index, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4Nsv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4N(this GL glInstance, uint index, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4Nsv(index, v_ptr);
            }
        }

        // VertexAttrib4Nub overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void VertexAttrib4N(this GL glInstance, uint index, byte x, byte y, byte z, byte w) =>
            glInstance.VertexAttrib4Nub(index, x, y, z, w);

        // VertexAttrib4Nubv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4N(this GL glInstance, uint index, ReadOnlySpan<byte> v)
        {
            fixed (byte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4Nubv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4N(this GL glInstance, uint index, byte[] v)
        {
            fixed (byte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4Nubv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4N(this GL glInstance, uint index, in byte v)
        {
            fixed (byte* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4Nubv(index, v_ptr);
            }
        }

        // VertexAttrib4Nuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4Nui(this GL glInstance, uint index, ReadOnlySpan<uint> v)
        {
            fixed (uint* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4Nuiv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4Nui(this GL glInstance, uint index, uint[] v)
        {
            fixed (uint* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4Nuiv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4Nui(this GL glInstance, uint index, in uint v)
        {
            fixed (uint* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4Nuiv(index, v_ptr);
            }
        }

        // VertexAttrib4Nusv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4N(this GL glInstance, uint index, ReadOnlySpan<ushort> v)
        {
            fixed (ushort* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4Nusv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4N(this GL glInstance, uint index, ushort[] v)
        {
            fixed (ushort* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4Nusv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4N(this GL glInstance, uint index, in ushort v)
        {
            fixed (ushort* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4Nusv(index, v_ptr);
            }
        }

        // VertexAttrib4bv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4(this GL glInstance, uint index, ReadOnlySpan<sbyte> v)
        {
            fixed (sbyte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4bv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4(this GL glInstance, uint index, sbyte[] v)
        {
            fixed (sbyte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4bv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4(this GL glInstance, uint index, in sbyte v)
        {
            fixed (sbyte* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4bv(index, v_ptr);
            }
        }

        // VertexAttrib4dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4dv(this GL glInstance, uint index, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4dv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4dv(this GL glInstance, uint index, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4dv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4dv(this GL glInstance, uint index, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4dv(index, v_ptr);
            }
        }

        // VertexAttrib4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4fv(this GL glInstance, uint index, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4fv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4fv(this GL glInstance, uint index, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4fv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4fv(this GL glInstance, uint index, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4fv(index, v_ptr);
            }
        }

        // VertexAttrib4iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4iv(this GL glInstance, uint index, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4iv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4iv(this GL glInstance, uint index, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4iv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4iv(this GL glInstance, uint index, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4iv(index, v_ptr);
            }
        }

        // VertexAttrib4s overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void VertexAttrib4(this GL glInstance, uint index, short x, short y, short z, short w) =>
            glInstance.VertexAttrib4s(index, x, y, z, w);

        // VertexAttrib4sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4(this GL glInstance, uint index, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4sv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4(this GL glInstance, uint index, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4sv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4(this GL glInstance, uint index, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4sv(index, v_ptr);
            }
        }

        // VertexAttrib4ubv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4(this GL glInstance, uint index, ReadOnlySpan<byte> v)
        {
            fixed (byte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4ubv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4(this GL glInstance, uint index, byte[] v)
        {
            fixed (byte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4ubv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4(this GL glInstance, uint index, in byte v)
        {
            fixed (byte* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4ubv(index, v_ptr);
            }
        }

        // VertexAttrib4uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4ui(this GL glInstance, uint index, ReadOnlySpan<uint> v)
        {
            fixed (uint* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4uiv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4ui(this GL glInstance, uint index, uint[] v)
        {
            fixed (uint* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4uiv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4ui(this GL glInstance, uint index, in uint v)
        {
            fixed (uint* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4uiv(index, v_ptr);
            }
        }

        // VertexAttrib4usv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4(this GL glInstance, uint index, ReadOnlySpan<ushort> v)
        {
            fixed (ushort* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4usv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttrib4(this GL glInstance, uint index, ushort[] v)
        {
            fixed (ushort* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttrib4usv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttrib4(this GL glInstance, uint index, in ushort v)
        {
            fixed (ushort* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttrib4usv(index, v_ptr);
            }
        }

        // VertexAttribPointer overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void VertexAttribPointer(this GL glInstance, uint index, int size, VertexAttribPointerType type, bool normalized, int stride, nint offset)
        {
            void* pointer = (void*)offset;
            var normalized_byte = (byte)(normalized ? 1 : 0);
            glInstance.VertexAttribPointer(index, size, type, normalized_byte, stride, pointer);
        }

        // UniformMatrix2x3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2x3fv(this GL glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 6);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x3fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2x3fv(this GL glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 6);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x3fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix2x3fv(this GL glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x3fv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix3x2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3x2fv(this GL glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 6);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x2fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3x2fv(this GL glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 6);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x2fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix3x2fv(this GL glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x2fv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix2x4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2x4fv(this GL glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 8);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x4fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2x4fv(this GL glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 8);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x4fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix2x4fv(this GL glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x4fv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix4x2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4x2fv(this GL glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 8);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x2fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4x2fv(this GL glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 8);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x2fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix4x2fv(this GL glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x2fv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix3x4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3x4fv(this GL glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 12);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x4fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3x4fv(this GL glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 12);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x4fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix3x4fv(this GL glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x4fv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix4x3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4x3fv(this GL glInstance, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 12);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x3fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4x3fv(this GL glInstance, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 12);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x3fv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix4x3fv(this GL glInstance, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x3fv(location, count, transpose_byte, value_ptr);
            }
        }

        // ColorMaski overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void ColorMaski(this GL glInstance, uint index, bool r, bool g, bool b, bool a)
        {
            var r_byte = (byte)(r ? 1 : 0);
            var g_byte = (byte)(g ? 1 : 0);
            var b_byte = (byte)(b ? 1 : 0);
            var a_byte = (byte)(a ? 1 : 0);
            glInstance.ColorMaski(index, r_byte, g_byte, b_byte, a_byte);
        }

        // GetBooleani_v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetBoolean(this GL glInstance, BufferTargetARB target, uint index, Span<byte> data)
        {
            fixed (byte* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetBooleani_v(target, index, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetBoolean(this GL glInstance, BufferTargetARB target, uint index, byte[] data)
        {
            fixed (byte* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetBooleani_v(target, index, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetBoolean(this GL glInstance, BufferTargetARB target, uint index, ref byte data)
        {
            fixed (byte* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetBooleani_v(target, index, data_ptr);
            }
        }

        // GetIntegeri_v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInteger(this GL glInstance, GetPName target, uint index, Span<int> data)
        {
            fixed (int* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetIntegeri_v(target, index, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInteger(this GL glInstance, GetPName target, uint index, int[] data)
        {
            fixed (int* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetIntegeri_v(target, index, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetInteger(this GL glInstance, GetPName target, uint index, ref int data)
        {
            fixed (int* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetIntegeri_v(target, index, data_ptr);
            }
        }

        // GetTransformFeedbackVarying overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetTransformFeedbackVarying(this GL glInstance, ProgramHandle program, uint index, int bufSize, Span<int> length, Span<int> size, Span<AttributeType> type)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (AttributeType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        glInstance.GetTransformFeedbackVarying(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTransformFeedbackVarying(this GL glInstance, ProgramHandle program, uint index, int bufSize, Span<int> length, Span<int> size, Span<AttributeType> type, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (AttributeType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        glInstance.GetTransformFeedbackVarying(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetTransformFeedbackVarying(this GL glInstance, ProgramHandle program, uint index, int bufSize, int[] length, int[] size, AttributeType[] type)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (AttributeType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        glInstance.GetTransformFeedbackVarying(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTransformFeedbackVarying(this GL glInstance, ProgramHandle program, uint index, int bufSize, int[] length, int[] size, AttributeType[] type, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (int* size_ptr = size) // SpanOrArrayLayer
                {
                    fixed (AttributeType* type_ptr = type) // SpanOrArrayLayer
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        glInstance.GetTransformFeedbackVarying(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetTransformFeedbackVarying(this GL glInstance, ProgramHandle program, uint index, int bufSize, ref int length, ref int size, ref AttributeType type)
        {
            string name;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (int* size_ptr = &size) // RefInsteadOfPointerLayer
            fixed (AttributeType* type_ptr = &type) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetTransformFeedbackVarying(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTransformFeedbackVarying(this GL glInstance, ProgramHandle program, uint index, int bufSize, ref int length, ref int size, ref AttributeType type, out string name)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (int* size_ptr = &size) // RefInsteadOfPointerLayer
            fixed (AttributeType* type_ptr = &type) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetTransformFeedbackVarying(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // VertexAttribIPointer overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void VertexAttribIPointer(this GL glInstance, uint index, int size, VertexAttribIType type, int stride, nint offset)
        {
            void* pointer = (void*)offset;
            glInstance.VertexAttribIPointer(index, size, type, stride, pointer);
        }

        // GetVertexAttribIiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribIi(this GL glInstance, uint index, VertexAttribEnum pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribIiv(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribIi(this GL glInstance, uint index, VertexAttribEnum pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribIiv(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetVertexAttribIi(this GL glInstance, uint index, VertexAttribEnum pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetVertexAttribIiv(index, pname, parameters_ptr);
            }
        }

        // GetVertexAttribIuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribIui(this GL glInstance, uint index, VertexAttribEnum pname, Span<uint> parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribIuiv(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribIui(this GL glInstance, uint index, VertexAttribEnum pname, uint[] parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribIuiv(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetVertexAttribIui(this GL glInstance, uint index, VertexAttribEnum pname, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetVertexAttribIuiv(index, pname, parameters_ptr);
            }
        }

        // VertexAttribI1iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI1iv(this GL glInstance, uint index, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI1iv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI1iv(this GL glInstance, uint index, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI1iv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribI1iv(this GL glInstance, uint index, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttribI1iv(index, v_ptr);
            }
        }

        // VertexAttribI2iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI2iv(this GL glInstance, uint index, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI2iv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI2iv(this GL glInstance, uint index, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI2iv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribI2iv(this GL glInstance, uint index, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttribI2iv(index, v_ptr);
            }
        }

        // VertexAttribI3iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI3iv(this GL glInstance, uint index, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI3iv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI3iv(this GL glInstance, uint index, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI3iv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribI3iv(this GL glInstance, uint index, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttribI3iv(index, v_ptr);
            }
        }

        // VertexAttribI4iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI4iv(this GL glInstance, uint index, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI4iv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI4iv(this GL glInstance, uint index, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI4iv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribI4iv(this GL glInstance, uint index, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttribI4iv(index, v_ptr);
            }
        }

        // VertexAttribI1uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI1ui(this GL glInstance, uint index, ReadOnlySpan<uint> v)
        {
            fixed (uint* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI1uiv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI1ui(this GL glInstance, uint index, uint[] v)
        {
            fixed (uint* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI1uiv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribI1ui(this GL glInstance, uint index, in uint v)
        {
            fixed (uint* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttribI1uiv(index, v_ptr);
            }
        }

        // VertexAttribI2uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI2ui(this GL glInstance, uint index, ReadOnlySpan<uint> v)
        {
            fixed (uint* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI2uiv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI2ui(this GL glInstance, uint index, uint[] v)
        {
            fixed (uint* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI2uiv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribI2ui(this GL glInstance, uint index, in uint v)
        {
            fixed (uint* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttribI2uiv(index, v_ptr);
            }
        }

        // VertexAttribI3uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI3ui(this GL glInstance, uint index, ReadOnlySpan<uint> v)
        {
            fixed (uint* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI3uiv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI3ui(this GL glInstance, uint index, uint[] v)
        {
            fixed (uint* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI3uiv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribI3ui(this GL glInstance, uint index, in uint v)
        {
            fixed (uint* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttribI3uiv(index, v_ptr);
            }
        }

        // VertexAttribI4uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI4ui(this GL glInstance, uint index, ReadOnlySpan<uint> v)
        {
            fixed (uint* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI4uiv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI4ui(this GL glInstance, uint index, uint[] v)
        {
            fixed (uint* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI4uiv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribI4ui(this GL glInstance, uint index, in uint v)
        {
            fixed (uint* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttribI4uiv(index, v_ptr);
            }
        }

        // VertexAttribI4bv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI4(this GL glInstance, uint index, ReadOnlySpan<sbyte> v)
        {
            fixed (sbyte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI4bv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI4(this GL glInstance, uint index, sbyte[] v)
        {
            fixed (sbyte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI4bv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribI4(this GL glInstance, uint index, in sbyte v)
        {
            fixed (sbyte* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttribI4bv(index, v_ptr);
            }
        }

        // VertexAttribI4sv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI4(this GL glInstance, uint index, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI4sv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI4(this GL glInstance, uint index, short[] v)
        {
            fixed (short* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI4sv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribI4(this GL glInstance, uint index, in short v)
        {
            fixed (short* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttribI4sv(index, v_ptr);
            }
        }

        // VertexAttribI4ubv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI4(this GL glInstance, uint index, ReadOnlySpan<byte> v)
        {
            fixed (byte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI4ubv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI4(this GL glInstance, uint index, byte[] v)
        {
            fixed (byte* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI4ubv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribI4(this GL glInstance, uint index, in byte v)
        {
            fixed (byte* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttribI4ubv(index, v_ptr);
            }
        }

        // VertexAttribI4usv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI4(this GL glInstance, uint index, ReadOnlySpan<ushort> v)
        {
            fixed (ushort* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI4usv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribI4(this GL glInstance, uint index, ushort[] v)
        {
            fixed (ushort* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribI4usv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribI4(this GL glInstance, uint index, in ushort v)
        {
            fixed (ushort* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttribI4usv(index, v_ptr);
            }
        }

        // GetUniformuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformui(this GL glInstance, ProgramHandle program, int location, Span<uint> parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformuiv(program, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformui(this GL glInstance, ProgramHandle program, int location, uint[] parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformuiv(program, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetUniformui(this GL glInstance, ProgramHandle program, int location, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetUniformuiv(program, location, parameters_ptr);
            }
        }

        // BindFragDataLocation overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe void BindFragDataLocation(this GL glInstance, ProgramHandle program, uint color, string name)
        {
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            glInstance.BindFragDataLocation(program, color, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
        }

        // GetFragDataLocation overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe int GetFragDataLocation(this GL glInstance, ProgramHandle program, string name)
        {
            int returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = glInstance.GetFragDataLocation(program, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }

        // Uniform1uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1ui(this GL glInstance, int location, ReadOnlySpan<uint> value)
        {
            var count = (int)(value.Length / 1);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1uiv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1ui(this GL glInstance, int location, uint[] value)
        {
            var count = (int)(value.Length / 1);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1uiv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform1ui(this GL glInstance, int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform1uiv(location, count, value_ptr);
            }
        }

        // Uniform2uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2ui(this GL glInstance, int location, ReadOnlySpan<uint> value)
        {
            var count = (int)(value.Length / 2);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2uiv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2ui(this GL glInstance, int location, uint[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2uiv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform2ui(this GL glInstance, int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform2uiv(location, count, value_ptr);
            }
        }

        // Uniform3uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3ui(this GL glInstance, int location, ReadOnlySpan<uint> value)
        {
            var count = (int)(value.Length / 3);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3uiv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3ui(this GL glInstance, int location, uint[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3uiv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform3ui(this GL glInstance, int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform3uiv(location, count, value_ptr);
            }
        }

        // Uniform4uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4ui(this GL glInstance, int location, ReadOnlySpan<uint> value)
        {
            var count = (int)(value.Length / 4);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4uiv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4ui(this GL glInstance, int location, uint[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4uiv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform4ui(this GL glInstance, int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform4uiv(location, count, value_ptr);
            }
        }

        // TexParameterIiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexParameterIi(this GL glInstance, TextureTarget target, TextureParameterName pname, ReadOnlySpan<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexParameterIiv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexParameterIi(this GL glInstance, TextureTarget target, TextureParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexParameterIiv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexParameterIi(this GL glInstance, TextureTarget target, TextureParameterName pname, in int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.TexParameterIiv(target, pname, parameters_ptr);
            }
        }

        // TexParameterIuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexParameterIui(this GL glInstance, TextureTarget target, TextureParameterName pname, ReadOnlySpan<uint> parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexParameterIuiv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexParameterIui(this GL glInstance, TextureTarget target, TextureParameterName pname, uint[] parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.TexParameterIuiv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexParameterIui(this GL glInstance, TextureTarget target, TextureParameterName pname, in uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.TexParameterIuiv(target, pname, parameters_ptr);
            }
        }

        // GetTexParameterIiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexParameterIi(this GL glInstance, TextureTarget target, GetTextureParameter pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexParameterIiv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexParameterIi(this GL glInstance, TextureTarget target, GetTextureParameter pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexParameterIiv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTexParameterIi(this GL glInstance, TextureTarget target, GetTextureParameter pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTexParameterIiv(target, pname, parameters_ptr);
            }
        }

        // GetTexParameterIuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexParameterIui(this GL glInstance, TextureTarget target, GetTextureParameter pname, Span<uint> parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexParameterIuiv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetTexParameterIui(this GL glInstance, TextureTarget target, GetTextureParameter pname, uint[] parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetTexParameterIuiv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTexParameterIui(this GL glInstance, TextureTarget target, GetTextureParameter pname, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTexParameterIuiv(target, pname, parameters_ptr);
            }
        }

        // ClearBufferiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearBufferi(this GL glInstance, Buffer buffer, int drawbuffer, ReadOnlySpan<int> value)
        {
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ClearBufferiv(buffer, drawbuffer, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearBufferi(this GL glInstance, Buffer buffer, int drawbuffer, int[] value)
        {
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ClearBufferiv(buffer, drawbuffer, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClearBufferi(this GL glInstance, Buffer buffer, int drawbuffer, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ClearBufferiv(buffer, drawbuffer, value_ptr);
            }
        }

        // ClearBufferuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearBufferui(this GL glInstance, Buffer buffer, int drawbuffer, ReadOnlySpan<uint> value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ClearBufferuiv(buffer, drawbuffer, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearBufferui(this GL glInstance, Buffer buffer, int drawbuffer, uint[] value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ClearBufferuiv(buffer, drawbuffer, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClearBufferui(this GL glInstance, Buffer buffer, int drawbuffer, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ClearBufferuiv(buffer, drawbuffer, value_ptr);
            }
        }

        // ClearBufferfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearBufferf(this GL glInstance, Buffer buffer, int drawbuffer, ReadOnlySpan<float> value)
        {
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ClearBufferfv(buffer, drawbuffer, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearBufferf(this GL glInstance, Buffer buffer, int drawbuffer, float[] value)
        {
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ClearBufferfv(buffer, drawbuffer, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClearBufferf(this GL glInstance, Buffer buffer, int drawbuffer, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ClearBufferfv(buffer, drawbuffer, value_ptr);
            }
        }

        // ClearBufferfi overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void ClearBuffer(this GL glInstance, Buffer buffer, int drawbuffer, float depth, int stencil) =>
            glInstance.ClearBufferfi(buffer, drawbuffer, depth, stencil);

        // GetStringi_ overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.StringReturnOverloader
        public static unsafe string? GetStringi(this GL glInstance, StringName name, uint index)
        {
            byte* returnValue;
            string? returnValue_str;
            returnValue = glInstance.GetStringi_(name, index);
            returnValue_str = Marshaller.PtrToString((nint)returnValue);
            return returnValue_str;
        }

        // DeleteRenderbuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void DeleteRenderbuffer(this GL glInstance, in RenderbufferHandle renderbuffers)
        {
            int n = 1;
            fixed(RenderbufferHandle* renderbuffers_handle = &renderbuffers) // DeleteOverloadLayer
                glInstance.DeleteRenderbuffers(n, renderbuffers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteRenderbuffers(this GL glInstance, ReadOnlySpan<RenderbufferHandle> renderbuffers)
        {
            var n = (int)(renderbuffers.Length);
            fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers) // SpanOrArrayLayer
            {
                glInstance.DeleteRenderbuffers(n, renderbuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteRenderbuffers(this GL glInstance, RenderbufferHandle[] renderbuffers)
        {
            var n = (int)(renderbuffers.Length);
            fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers) // SpanOrArrayLayer
            {
                glInstance.DeleteRenderbuffers(n, renderbuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteRenderbuffers(this GL glInstance, int n, in RenderbufferHandle renderbuffers)
        {
            fixed (RenderbufferHandle* renderbuffers_ptr = &renderbuffers) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteRenderbuffers(n, renderbuffers_ptr);
            }
        }

        // GenRenderbuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe RenderbufferHandle GenRenderbuffer(this GL glInstance)
        {
            RenderbufferHandle renderbuffers;
            int n = 1;
            Unsafe.SkipInit(out renderbuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            RenderbufferHandle* renderbuffers_handle = (RenderbufferHandle*)Unsafe.AsPointer(ref renderbuffers);
            glInstance.GenRenderbuffers(n, renderbuffers_handle);
            return renderbuffers;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void GenRenderbuffer(this GL glInstance, out RenderbufferHandle renderbuffers)
        {
            int n = 1;
            Unsafe.SkipInit(out renderbuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            RenderbufferHandle* renderbuffers_handle = (RenderbufferHandle*)Unsafe.AsPointer(ref renderbuffers);
            glInstance.GenRenderbuffers(n, renderbuffers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenRenderbuffers(this GL glInstance, Span<RenderbufferHandle> renderbuffers)
        {
            var n = (int)(renderbuffers.Length);
            fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers) // SpanOrArrayLayer
            {
                glInstance.GenRenderbuffers(n, renderbuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenRenderbuffers(this GL glInstance, RenderbufferHandle[] renderbuffers)
        {
            var n = (int)(renderbuffers.Length);
            fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers) // SpanOrArrayLayer
            {
                glInstance.GenRenderbuffers(n, renderbuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenRenderbuffers(this GL glInstance, int n, ref RenderbufferHandle renderbuffers)
        {
            fixed (RenderbufferHandle* renderbuffers_ptr = &renderbuffers) // RefInsteadOfPointerLayer
            {
                glInstance.GenRenderbuffers(n, renderbuffers_ptr);
            }
        }

        // GetRenderbufferParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetRenderbufferParameteri(this GL glInstance, RenderbufferTarget target, RenderbufferParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetRenderbufferParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetRenderbufferParameteri(this GL glInstance, RenderbufferTarget target, RenderbufferParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetRenderbufferParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetRenderbufferParameteri(this GL glInstance, RenderbufferTarget target, RenderbufferParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetRenderbufferParameteriv(target, pname, parameters_ptr);
            }
        }

        // DeleteFramebuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void DeleteFramebuffer(this GL glInstance, in FramebufferHandle framebuffers)
        {
            int n = 1;
            fixed(FramebufferHandle* framebuffers_handle = &framebuffers) // DeleteOverloadLayer
                glInstance.DeleteFramebuffers(n, framebuffers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteFramebuffers(this GL glInstance, ReadOnlySpan<FramebufferHandle> framebuffers)
        {
            var n = (int)(framebuffers.Length);
            fixed (FramebufferHandle* framebuffers_ptr = framebuffers) // SpanOrArrayLayer
            {
                glInstance.DeleteFramebuffers(n, framebuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteFramebuffers(this GL glInstance, FramebufferHandle[] framebuffers)
        {
            var n = (int)(framebuffers.Length);
            fixed (FramebufferHandle* framebuffers_ptr = framebuffers) // SpanOrArrayLayer
            {
                glInstance.DeleteFramebuffers(n, framebuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteFramebuffers(this GL glInstance, int n, in FramebufferHandle framebuffers)
        {
            fixed (FramebufferHandle* framebuffers_ptr = &framebuffers) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteFramebuffers(n, framebuffers_ptr);
            }
        }

        // GenFramebuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe FramebufferHandle GenFramebuffer(this GL glInstance)
        {
            FramebufferHandle framebuffers;
            int n = 1;
            Unsafe.SkipInit(out framebuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            FramebufferHandle* framebuffers_handle = (FramebufferHandle*)Unsafe.AsPointer(ref framebuffers);
            glInstance.GenFramebuffers(n, framebuffers_handle);
            return framebuffers;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void GenFramebuffer(this GL glInstance, out FramebufferHandle framebuffers)
        {
            int n = 1;
            Unsafe.SkipInit(out framebuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            FramebufferHandle* framebuffers_handle = (FramebufferHandle*)Unsafe.AsPointer(ref framebuffers);
            glInstance.GenFramebuffers(n, framebuffers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenFramebuffers(this GL glInstance, Span<FramebufferHandle> framebuffers)
        {
            var n = (int)(framebuffers.Length);
            fixed (FramebufferHandle* framebuffers_ptr = framebuffers) // SpanOrArrayLayer
            {
                glInstance.GenFramebuffers(n, framebuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenFramebuffers(this GL glInstance, FramebufferHandle[] framebuffers)
        {
            var n = (int)(framebuffers.Length);
            fixed (FramebufferHandle* framebuffers_ptr = framebuffers) // SpanOrArrayLayer
            {
                glInstance.GenFramebuffers(n, framebuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenFramebuffers(this GL glInstance, int n, ref FramebufferHandle framebuffers)
        {
            fixed (FramebufferHandle* framebuffers_ptr = &framebuffers) // RefInsteadOfPointerLayer
            {
                glInstance.GenFramebuffers(n, framebuffers_ptr);
            }
        }

        // GetFramebufferAttachmentParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetFramebufferAttachmentParameteri(this GL glInstance, FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetFramebufferAttachmentParameteriv(target, attachment, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetFramebufferAttachmentParameteri(this GL glInstance, FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetFramebufferAttachmentParameteriv(target, attachment, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetFramebufferAttachmentParameteri(this GL glInstance, FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetFramebufferAttachmentParameteriv(target, attachment, pname, parameters_ptr);
            }
        }

        // DeleteVertexArrays overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void DeleteVertexArray(this GL glInstance, in VertexArrayHandle arrays)
        {
            int n = 1;
            fixed(VertexArrayHandle* arrays_handle = &arrays) // DeleteOverloadLayer
                glInstance.DeleteVertexArrays(n, arrays_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteVertexArrays(this GL glInstance, ReadOnlySpan<VertexArrayHandle> arrays)
        {
            var n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays) // SpanOrArrayLayer
            {
                glInstance.DeleteVertexArrays(n, arrays_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteVertexArrays(this GL glInstance, VertexArrayHandle[] arrays)
        {
            var n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays) // SpanOrArrayLayer
            {
                glInstance.DeleteVertexArrays(n, arrays_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteVertexArrays(this GL glInstance, int n, in VertexArrayHandle arrays)
        {
            fixed (VertexArrayHandle* arrays_ptr = &arrays) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteVertexArrays(n, arrays_ptr);
            }
        }

        // GenVertexArrays overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe VertexArrayHandle GenVertexArray(this GL glInstance)
        {
            VertexArrayHandle arrays;
            int n = 1;
            Unsafe.SkipInit(out arrays);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            VertexArrayHandle* arrays_handle = (VertexArrayHandle*)Unsafe.AsPointer(ref arrays);
            glInstance.GenVertexArrays(n, arrays_handle);
            return arrays;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void GenVertexArray(this GL glInstance, out VertexArrayHandle arrays)
        {
            int n = 1;
            Unsafe.SkipInit(out arrays);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            VertexArrayHandle* arrays_handle = (VertexArrayHandle*)Unsafe.AsPointer(ref arrays);
            glInstance.GenVertexArrays(n, arrays_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenVertexArrays(this GL glInstance, Span<VertexArrayHandle> arrays)
        {
            var n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays) // SpanOrArrayLayer
            {
                glInstance.GenVertexArrays(n, arrays_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenVertexArrays(this GL glInstance, VertexArrayHandle[] arrays)
        {
            var n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays) // SpanOrArrayLayer
            {
                glInstance.GenVertexArrays(n, arrays_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenVertexArrays(this GL glInstance, int n, ref VertexArrayHandle arrays)
        {
            fixed (VertexArrayHandle* arrays_ptr = &arrays) // RefInsteadOfPointerLayer
            {
                glInstance.GenVertexArrays(n, arrays_ptr);
            }
        }

        // DrawElementsInstanced overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void DrawElementsInstanced(this GL glInstance, PrimitiveType mode, int count, DrawElementsType type, nint offset, int instancecount)
        {
            void* indices = (void*)offset;
            glInstance.DrawElementsInstanced(mode, count, type, indices, instancecount);
        }

        // GetUniformIndices overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformIndices(this GL glInstance, ProgramHandle program, int uniformCount, byte** uniformNames, Span<uint> uniformIndices)
        {
            fixed (uint* uniformIndices_ptr = uniformIndices) // SpanOrArrayLayer
            {
                glInstance.GetUniformIndices(program, uniformCount, uniformNames, uniformIndices_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformIndices(this GL glInstance, ProgramHandle program, int uniformCount, byte** uniformNames, uint[] uniformIndices)
        {
            fixed (uint* uniformIndices_ptr = uniformIndices) // SpanOrArrayLayer
            {
                glInstance.GetUniformIndices(program, uniformCount, uniformNames, uniformIndices_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetUniformIndices(this GL glInstance, ProgramHandle program, int uniformCount, byte** uniformNames, ref uint uniformIndices)
        {
            fixed (uint* uniformIndices_ptr = &uniformIndices) // RefInsteadOfPointerLayer
            {
                glInstance.GetUniformIndices(program, uniformCount, uniformNames, uniformIndices_ptr);
            }
        }

        // GetActiveUniformsiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniformsi(this GL glInstance, ProgramHandle program, ReadOnlySpan<uint> uniformIndices, UniformPName pname, Span<int> parameters)
        {
            var uniformCount = (int)(uniformIndices.Length);
            fixed (uint* uniformIndices_ptr = uniformIndices) // SpanOrArrayLayer
            {
                fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
                {
                    glInstance.GetActiveUniformsiv(program, uniformCount, uniformIndices_ptr, pname, parameters_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniformsi(this GL glInstance, ProgramHandle program, uint[] uniformIndices, UniformPName pname, int[] parameters)
        {
            var uniformCount = (int)(uniformIndices.Length);
            fixed (uint* uniformIndices_ptr = uniformIndices) // SpanOrArrayLayer
            {
                fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
                {
                    glInstance.GetActiveUniformsiv(program, uniformCount, uniformIndices_ptr, pname, parameters_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveUniformsi(this GL glInstance, ProgramHandle program, int uniformCount, in uint uniformIndices, UniformPName pname, ref int parameters)
        {
            fixed (uint* uniformIndices_ptr = &uniformIndices) // RefInsteadOfPointerLayer
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetActiveUniformsiv(program, uniformCount, uniformIndices_ptr, pname, parameters_ptr);
            }
        }

        // GetActiveUniformName overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveUniformName(this GL glInstance, ProgramHandle program, uint uniformIndex, int bufSize, Span<int> length)
        {
            string uniformName;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var uniformName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformName(program, uniformIndex, bufSize, length_ptr, uniformName_ptr);
                uniformName = Marshal.PtrToStringUTF8((IntPtr)uniformName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformName_ptr);
            }
            return uniformName;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniformName(this GL glInstance, ProgramHandle program, uint uniformIndex, int bufSize, Span<int> length, out string uniformName)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var uniformName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformName(program, uniformIndex, bufSize, length_ptr, uniformName_ptr);
                uniformName = Marshal.PtrToStringUTF8((IntPtr)uniformName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformName_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveUniformName(this GL glInstance, ProgramHandle program, uint uniformIndex, int bufSize, int[] length)
        {
            string uniformName;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var uniformName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformName(program, uniformIndex, bufSize, length_ptr, uniformName_ptr);
                uniformName = Marshal.PtrToStringUTF8((IntPtr)uniformName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformName_ptr);
            }
            return uniformName;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniformName(this GL glInstance, ProgramHandle program, uint uniformIndex, int bufSize, int[] length, out string uniformName)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var uniformName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformName(program, uniformIndex, bufSize, length_ptr, uniformName_ptr);
                uniformName = Marshal.PtrToStringUTF8((IntPtr)uniformName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformName_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveUniformName(this GL glInstance, ProgramHandle program, uint uniformIndex, int bufSize, ref int length)
        {
            string uniformName;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var uniformName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformName(program, uniformIndex, bufSize, length_ptr, uniformName_ptr);
                uniformName = Marshal.PtrToStringUTF8((IntPtr)uniformName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformName_ptr);
            }
            return uniformName;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveUniformName(this GL glInstance, ProgramHandle program, uint uniformIndex, int bufSize, ref int length, out string uniformName)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var uniformName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformName(program, uniformIndex, bufSize, length_ptr, uniformName_ptr);
                uniformName = Marshal.PtrToStringUTF8((IntPtr)uniformName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformName_ptr);
            }
        }

        // GetUniformBlockIndex overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe uint GetUniformBlockIndex(this GL glInstance, ProgramHandle program, string uniformBlockName)
        {
            uint returnValue;
            byte* uniformBlockName_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(uniformBlockName);
            returnValue = glInstance.GetUniformBlockIndex(program, uniformBlockName_ptr);
            Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            return returnValue;
        }

        // GetActiveUniformBlockiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniformBlocki(this GL glInstance, ProgramHandle program, uint uniformBlockIndex, UniformBlockPName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetActiveUniformBlockiv(program, uniformBlockIndex, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniformBlocki(this GL glInstance, ProgramHandle program, uint uniformBlockIndex, UniformBlockPName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetActiveUniformBlockiv(program, uniformBlockIndex, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveUniformBlocki(this GL glInstance, ProgramHandle program, uint uniformBlockIndex, UniformBlockPName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetActiveUniformBlockiv(program, uniformBlockIndex, pname, parameters_ptr);
            }
        }

        // GetActiveUniformBlockName overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveUniformBlockName(this GL glInstance, ProgramHandle program, uint uniformBlockIndex, int bufSize, Span<int> length)
        {
            string uniformBlockName;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            }
            return uniformBlockName;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniformBlockName(this GL glInstance, ProgramHandle program, uint uniformBlockIndex, int bufSize, Span<int> length, out string uniformBlockName)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveUniformBlockName(this GL glInstance, ProgramHandle program, uint uniformBlockIndex, int bufSize, int[] length)
        {
            string uniformBlockName;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            }
            return uniformBlockName;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveUniformBlockName(this GL glInstance, ProgramHandle program, uint uniformBlockIndex, int bufSize, int[] length, out string uniformBlockName)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveUniformBlockName(this GL glInstance, ProgramHandle program, uint uniformBlockIndex, int bufSize, ref int length)
        {
            string uniformBlockName;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            }
            return uniformBlockName;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveUniformBlockName(this GL glInstance, ProgramHandle program, uint uniformBlockIndex, int bufSize, ref int length, out string uniformBlockName)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            }
        }

        // DrawElementsBaseVertex overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void DrawElementsBaseVertex(this GL glInstance, PrimitiveType mode, int count, DrawElementsType type, nint offset, int basevertex)
        {
            void* indices = (void*)offset;
            glInstance.DrawElementsBaseVertex(mode, count, type, indices, basevertex);
        }

        // DrawRangeElementsBaseVertex overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void DrawRangeElementsBaseVertex(this GL glInstance, PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, nint offset, int basevertex)
        {
            void* indices = (void*)offset;
            glInstance.DrawRangeElementsBaseVertex(mode, start, end, count, type, indices, basevertex);
        }

        // DrawElementsInstancedBaseVertex overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void DrawElementsInstancedBaseVertex(this GL glInstance, PrimitiveType mode, int count, DrawElementsType type, nint offset, int instancecount, int basevertex)
        {
            void* indices = (void*)offset;
            glInstance.DrawElementsInstancedBaseVertex(mode, count, type, indices, instancecount, basevertex);
        }

        // MultiDrawElementsBaseVertex overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiDrawElementsBaseVertex(this GL glInstance, PrimitiveType mode, ReadOnlySpan<int> count, DrawElementsType type, void** indices, int drawcount, ReadOnlySpan<int> basevertex)
        {
            fixed (int* count_ptr = count) // SpanOrArrayLayer
            {
                fixed (int* basevertex_ptr = basevertex) // SpanOrArrayLayer
                {
                    glInstance.MultiDrawElementsBaseVertex(mode, count_ptr, type, indices, drawcount, basevertex_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiDrawElementsBaseVertex(this GL glInstance, PrimitiveType mode, int[] count, DrawElementsType type, void** indices, int drawcount, int[] basevertex)
        {
            fixed (int* count_ptr = count) // SpanOrArrayLayer
            {
                fixed (int* basevertex_ptr = basevertex) // SpanOrArrayLayer
                {
                    glInstance.MultiDrawElementsBaseVertex(mode, count_ptr, type, indices, drawcount, basevertex_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiDrawElementsBaseVertex(this GL glInstance, PrimitiveType mode, in int count, DrawElementsType type, void** indices, int drawcount, in int basevertex)
        {
            fixed (int* count_ptr = &count) // RefInsteadOfPointerLayer
            fixed (int* basevertex_ptr = &basevertex) // RefInsteadOfPointerLayer
            {
                glInstance.MultiDrawElementsBaseVertex(mode, count_ptr, type, indices, drawcount, basevertex_ptr);
            }
        }

        // GetInteger64v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInteger64(this GL glInstance, GetPName pname, Span<long> data)
        {
            fixed (long* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetInteger64v(pname, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInteger64(this GL glInstance, GetPName pname, long[] data)
        {
            fixed (long* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetInteger64v(pname, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetInteger64(this GL glInstance, GetPName pname, ref long data)
        {
            fixed (long* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetInteger64v(pname, data_ptr);
            }
        }

        // GetSynciv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSynci(this GL glInstance, GLSync sync, SyncParameterName pname, Span<int> length, Span<int> values)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var count = (int)(values.Length);
                fixed (int* values_ptr = values) // SpanOrArrayLayer
                {
                    glInstance.GetSynciv(sync, pname, count, length_ptr, values_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSynci(this GL glInstance, GLSync sync, SyncParameterName pname, int[] length, int[] values)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var count = (int)(values.Length);
                fixed (int* values_ptr = values) // SpanOrArrayLayer
                {
                    glInstance.GetSynciv(sync, pname, count, length_ptr, values_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetSynci(this GL glInstance, GLSync sync, SyncParameterName pname, int count, ref int length, ref int values)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (int* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                glInstance.GetSynciv(sync, pname, count, length_ptr, values_ptr);
            }
        }

        // GetInteger64i_v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInteger64(this GL glInstance, GetPName target, uint index, Span<long> data)
        {
            fixed (long* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetInteger64i_v(target, index, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInteger64(this GL glInstance, GetPName target, uint index, long[] data)
        {
            fixed (long* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetInteger64i_v(target, index, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetInteger64(this GL glInstance, GetPName target, uint index, ref long data)
        {
            fixed (long* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetInteger64i_v(target, index, data_ptr);
            }
        }

        // GetBufferParameteri64v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetBufferParameteri64(this GL glInstance, BufferTargetARB target, BufferPNameARB pname, Span<long> parameters)
        {
            fixed (long* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetBufferParameteri64v(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetBufferParameteri64(this GL glInstance, BufferTargetARB target, BufferPNameARB pname, long[] parameters)
        {
            fixed (long* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetBufferParameteri64v(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetBufferParameteri64(this GL glInstance, BufferTargetARB target, BufferPNameARB pname, ref long parameters)
        {
            fixed (long* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetBufferParameteri64v(target, pname, parameters_ptr);
            }
        }

        // TexImage2DMultisample overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void TexImage2DMultisample(this GL glInstance, TextureTarget target, int samples, InternalFormat internalformat, int width, int height, bool fixedsamplelocations)
        {
            var fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
            glInstance.TexImage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations_byte);
        }

        // TexImage3DMultisample overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void TexImage3DMultisample(this GL glInstance, TextureTarget target, int samples, InternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
        {
            var fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
            glInstance.TexImage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations_byte);
        }

        // GetMultisamplefv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetMultisamplef(this GL glInstance, GetMultisamplePNameNV pname, uint index, Span<float> val)
        {
            fixed (float* val_ptr = val) // SpanOrArrayLayer
            {
                glInstance.GetMultisamplefv(pname, index, val_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetMultisamplef(this GL glInstance, GetMultisamplePNameNV pname, uint index, float[] val)
        {
            fixed (float* val_ptr = val) // SpanOrArrayLayer
            {
                glInstance.GetMultisamplefv(pname, index, val_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetMultisamplef(this GL glInstance, GetMultisamplePNameNV pname, uint index, ref float val)
        {
            fixed (float* val_ptr = &val) // RefInsteadOfPointerLayer
            {
                glInstance.GetMultisamplefv(pname, index, val_ptr);
            }
        }

        // BindFragDataLocationIndexed overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe void BindFragDataLocationIndexed(this GL glInstance, ProgramHandle program, uint colorNumber, uint index, string name)
        {
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            glInstance.BindFragDataLocationIndexed(program, colorNumber, index, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
        }

        // GetFragDataIndex overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe int GetFragDataIndex(this GL glInstance, ProgramHandle program, string name)
        {
            int returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = glInstance.GetFragDataIndex(program, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }

        // GenSamplers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe SamplerHandle GenSampler(this GL glInstance)
        {
            SamplerHandle samplers;
            int count = 1;
            Unsafe.SkipInit(out samplers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            SamplerHandle* samplers_handle = (SamplerHandle*)Unsafe.AsPointer(ref samplers);
            glInstance.GenSamplers(count, samplers_handle);
            return samplers;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void GenSampler(this GL glInstance, out SamplerHandle samplers)
        {
            int count = 1;
            Unsafe.SkipInit(out samplers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            SamplerHandle* samplers_handle = (SamplerHandle*)Unsafe.AsPointer(ref samplers);
            glInstance.GenSamplers(count, samplers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenSamplers(this GL glInstance, Span<SamplerHandle> samplers)
        {
            var count = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers) // SpanOrArrayLayer
            {
                glInstance.GenSamplers(count, samplers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenSamplers(this GL glInstance, SamplerHandle[] samplers)
        {
            var count = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers) // SpanOrArrayLayer
            {
                glInstance.GenSamplers(count, samplers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenSamplers(this GL glInstance, int count, ref SamplerHandle samplers)
        {
            fixed (SamplerHandle* samplers_ptr = &samplers) // RefInsteadOfPointerLayer
            {
                glInstance.GenSamplers(count, samplers_ptr);
            }
        }

        // DeleteSamplers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void DeleteSampler(this GL glInstance, in SamplerHandle samplers)
        {
            int count = 1;
            fixed(SamplerHandle* samplers_handle = &samplers) // DeleteOverloadLayer
                glInstance.DeleteSamplers(count, samplers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteSamplers(this GL glInstance, ReadOnlySpan<SamplerHandle> samplers)
        {
            var count = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers) // SpanOrArrayLayer
            {
                glInstance.DeleteSamplers(count, samplers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteSamplers(this GL glInstance, SamplerHandle[] samplers)
        {
            var count = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers) // SpanOrArrayLayer
            {
                glInstance.DeleteSamplers(count, samplers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteSamplers(this GL glInstance, int count, in SamplerHandle samplers)
        {
            fixed (SamplerHandle* samplers_ptr = &samplers) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteSamplers(count, samplers_ptr);
            }
        }

        // SamplerParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SamplerParameteri(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, ReadOnlySpan<int> param)
        {
            fixed (int* param_ptr = param) // SpanOrArrayLayer
            {
                glInstance.SamplerParameteriv(sampler, pname, param_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SamplerParameteri(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, int[] param)
        {
            fixed (int* param_ptr = param) // SpanOrArrayLayer
            {
                glInstance.SamplerParameteriv(sampler, pname, param_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SamplerParameteri(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, in int param)
        {
            fixed (int* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.SamplerParameteriv(sampler, pname, param_ptr);
            }
        }

        // SamplerParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SamplerParameterf(this GL glInstance, SamplerHandle sampler, SamplerParameterF pname, ReadOnlySpan<float> param)
        {
            fixed (float* param_ptr = param) // SpanOrArrayLayer
            {
                glInstance.SamplerParameterfv(sampler, pname, param_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SamplerParameterf(this GL glInstance, SamplerHandle sampler, SamplerParameterF pname, float[] param)
        {
            fixed (float* param_ptr = param) // SpanOrArrayLayer
            {
                glInstance.SamplerParameterfv(sampler, pname, param_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SamplerParameterf(this GL glInstance, SamplerHandle sampler, SamplerParameterF pname, in float param)
        {
            fixed (float* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.SamplerParameterfv(sampler, pname, param_ptr);
            }
        }

        // SamplerParameterIiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SamplerParameterIi(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, ReadOnlySpan<int> param)
        {
            fixed (int* param_ptr = param) // SpanOrArrayLayer
            {
                glInstance.SamplerParameterIiv(sampler, pname, param_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SamplerParameterIi(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, int[] param)
        {
            fixed (int* param_ptr = param) // SpanOrArrayLayer
            {
                glInstance.SamplerParameterIiv(sampler, pname, param_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SamplerParameterIi(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, in int param)
        {
            fixed (int* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.SamplerParameterIiv(sampler, pname, param_ptr);
            }
        }

        // SamplerParameterIuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SamplerParameterIui(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, ReadOnlySpan<uint> param)
        {
            fixed (uint* param_ptr = param) // SpanOrArrayLayer
            {
                glInstance.SamplerParameterIuiv(sampler, pname, param_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SamplerParameterIui(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, uint[] param)
        {
            fixed (uint* param_ptr = param) // SpanOrArrayLayer
            {
                glInstance.SamplerParameterIuiv(sampler, pname, param_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SamplerParameterIui(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, in uint param)
        {
            fixed (uint* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.SamplerParameterIuiv(sampler, pname, param_ptr);
            }
        }

        // GetSamplerParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSamplerParameteri(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetSamplerParameteriv(sampler, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSamplerParameteri(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetSamplerParameteriv(sampler, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetSamplerParameteri(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetSamplerParameteriv(sampler, pname, parameters_ptr);
            }
        }

        // GetSamplerParameterIiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSamplerParameterIi(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetSamplerParameterIiv(sampler, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSamplerParameterIi(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetSamplerParameterIiv(sampler, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetSamplerParameterIi(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetSamplerParameterIiv(sampler, pname, parameters_ptr);
            }
        }

        // GetSamplerParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSamplerParameterf(this GL glInstance, SamplerHandle sampler, SamplerParameterF pname, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetSamplerParameterfv(sampler, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSamplerParameterf(this GL glInstance, SamplerHandle sampler, SamplerParameterF pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetSamplerParameterfv(sampler, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetSamplerParameterf(this GL glInstance, SamplerHandle sampler, SamplerParameterF pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetSamplerParameterfv(sampler, pname, parameters_ptr);
            }
        }

        // GetSamplerParameterIuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSamplerParameterIui(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, Span<uint> parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetSamplerParameterIuiv(sampler, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetSamplerParameterIui(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, uint[] parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetSamplerParameterIuiv(sampler, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetSamplerParameterIui(this GL glInstance, SamplerHandle sampler, SamplerParameterI pname, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetSamplerParameterIuiv(sampler, pname, parameters_ptr);
            }
        }

        // GetQueryObjecti64v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryObjecti64(this GL glInstance, QueryHandle id, QueryObjectParameterName pname, Span<long> parameters)
        {
            fixed (long* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryObjecti64v(id, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryObjecti64(this GL glInstance, QueryHandle id, QueryObjectParameterName pname, long[] parameters)
        {
            fixed (long* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryObjecti64v(id, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetQueryObjecti64(this GL glInstance, QueryHandle id, QueryObjectParameterName pname, ref long parameters)
        {
            fixed (long* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetQueryObjecti64v(id, pname, parameters_ptr);
            }
        }

        // GetQueryObjectui64v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryObjectui64(this GL glInstance, QueryHandle id, QueryObjectParameterName pname, Span<ulong> parameters)
        {
            fixed (ulong* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryObjectui64v(id, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryObjectui64(this GL glInstance, QueryHandle id, QueryObjectParameterName pname, ulong[] parameters)
        {
            fixed (ulong* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryObjectui64v(id, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetQueryObjectui64(this GL glInstance, QueryHandle id, QueryObjectParameterName pname, ref ulong parameters)
        {
            fixed (ulong* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetQueryObjectui64v(id, pname, parameters_ptr);
            }
        }

        // VertexAttribP1ui overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void VertexAttribP1ui(this GL glInstance, uint index, VertexAttribPointerType type, bool normalized, uint value)
        {
            var normalized_byte = (byte)(normalized ? 1 : 0);
            glInstance.VertexAttribP1ui(index, type, normalized_byte, value);
        }

        // VertexAttribP1uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribP1ui(this GL glInstance, uint index, VertexAttribPointerType type, bool normalized, ReadOnlySpan<uint> value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribP1uiv(index, type, normalized_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribP1ui(this GL glInstance, uint index, VertexAttribPointerType type, bool normalized, uint[] value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribP1uiv(index, type, normalized_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribP1ui(this GL glInstance, uint index, VertexAttribPointerType type, bool normalized, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribP1uiv(index, type, normalized_byte, value_ptr);
            }
        }

        // VertexAttribP2ui overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void VertexAttribP2ui(this GL glInstance, uint index, VertexAttribPointerType type, bool normalized, uint value)
        {
            var normalized_byte = (byte)(normalized ? 1 : 0);
            glInstance.VertexAttribP2ui(index, type, normalized_byte, value);
        }

        // VertexAttribP2uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribP2ui(this GL glInstance, uint index, VertexAttribPointerType type, bool normalized, ReadOnlySpan<uint> value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribP2uiv(index, type, normalized_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribP2ui(this GL glInstance, uint index, VertexAttribPointerType type, bool normalized, uint[] value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribP2uiv(index, type, normalized_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribP2ui(this GL glInstance, uint index, VertexAttribPointerType type, bool normalized, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribP2uiv(index, type, normalized_byte, value_ptr);
            }
        }

        // VertexAttribP3ui overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void VertexAttribP3ui(this GL glInstance, uint index, VertexAttribPointerType type, bool normalized, uint value)
        {
            var normalized_byte = (byte)(normalized ? 1 : 0);
            glInstance.VertexAttribP3ui(index, type, normalized_byte, value);
        }

        // VertexAttribP3uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribP3ui(this GL glInstance, uint index, VertexAttribPointerType type, bool normalized, ReadOnlySpan<uint> value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribP3uiv(index, type, normalized_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribP3ui(this GL glInstance, uint index, VertexAttribPointerType type, bool normalized, uint[] value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribP3uiv(index, type, normalized_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribP3ui(this GL glInstance, uint index, VertexAttribPointerType type, bool normalized, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribP3uiv(index, type, normalized_byte, value_ptr);
            }
        }

        // VertexAttribP4ui overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void VertexAttribP4ui(this GL glInstance, uint index, VertexAttribPointerType type, bool normalized, uint value)
        {
            var normalized_byte = (byte)(normalized ? 1 : 0);
            glInstance.VertexAttribP4ui(index, type, normalized_byte, value);
        }

        // VertexAttribP4uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribP4ui(this GL glInstance, uint index, VertexAttribPointerType type, bool normalized, ReadOnlySpan<uint> value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribP4uiv(index, type, normalized_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribP4ui(this GL glInstance, uint index, VertexAttribPointerType type, bool normalized, uint[] value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribP4uiv(index, type, normalized_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribP4ui(this GL glInstance, uint index, VertexAttribPointerType type, bool normalized, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var normalized_byte = (byte)(normalized ? 1 : 0);
                glInstance.VertexAttribP4uiv(index, type, normalized_byte, value_ptr);
            }
        }

        // VertexP2uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexP2ui(this GL glInstance, VertexPointerType type, ReadOnlySpan<uint> value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.VertexP2uiv(type, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexP2ui(this GL glInstance, VertexPointerType type, uint[] value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.VertexP2uiv(type, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexP2ui(this GL glInstance, VertexPointerType type, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.VertexP2uiv(type, value_ptr);
            }
        }

        // VertexP3uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexP3ui(this GL glInstance, VertexPointerType type, ReadOnlySpan<uint> value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.VertexP3uiv(type, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexP3ui(this GL glInstance, VertexPointerType type, uint[] value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.VertexP3uiv(type, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexP3ui(this GL glInstance, VertexPointerType type, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.VertexP3uiv(type, value_ptr);
            }
        }

        // VertexP4uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexP4ui(this GL glInstance, VertexPointerType type, ReadOnlySpan<uint> value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.VertexP4uiv(type, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexP4ui(this GL glInstance, VertexPointerType type, uint[] value)
        {
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.VertexP4uiv(type, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexP4ui(this GL glInstance, VertexPointerType type, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.VertexP4uiv(type, value_ptr);
            }
        }

        // TexCoordP1uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoordP1ui(this GL glInstance, TexCoordPointerType type, ReadOnlySpan<uint> coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.TexCoordP1uiv(type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoordP1ui(this GL glInstance, TexCoordPointerType type, uint[] coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.TexCoordP1uiv(type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoordP1ui(this GL glInstance, TexCoordPointerType type, in uint coords)
        {
            fixed (uint* coords_ptr = &coords) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoordP1uiv(type, coords_ptr);
            }
        }

        // TexCoordP2uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoordP2ui(this GL glInstance, TexCoordPointerType type, ReadOnlySpan<uint> coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.TexCoordP2uiv(type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoordP2ui(this GL glInstance, TexCoordPointerType type, uint[] coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.TexCoordP2uiv(type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoordP2ui(this GL glInstance, TexCoordPointerType type, in uint coords)
        {
            fixed (uint* coords_ptr = &coords) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoordP2uiv(type, coords_ptr);
            }
        }

        // TexCoordP3uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoordP3ui(this GL glInstance, TexCoordPointerType type, ReadOnlySpan<uint> coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.TexCoordP3uiv(type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoordP3ui(this GL glInstance, TexCoordPointerType type, uint[] coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.TexCoordP3uiv(type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoordP3ui(this GL glInstance, TexCoordPointerType type, in uint coords)
        {
            fixed (uint* coords_ptr = &coords) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoordP3uiv(type, coords_ptr);
            }
        }

        // TexCoordP4uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoordP4ui(this GL glInstance, TexCoordPointerType type, ReadOnlySpan<uint> coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.TexCoordP4uiv(type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void TexCoordP4ui(this GL glInstance, TexCoordPointerType type, uint[] coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.TexCoordP4uiv(type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TexCoordP4ui(this GL glInstance, TexCoordPointerType type, in uint coords)
        {
            fixed (uint* coords_ptr = &coords) // RefInsteadOfPointerLayer
            {
                glInstance.TexCoordP4uiv(type, coords_ptr);
            }
        }

        // MultiTexCoordP1uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoordP1ui(this GL glInstance, TextureUnit texture, TexCoordPointerType type, ReadOnlySpan<uint> coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoordP1uiv(texture, type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoordP1ui(this GL glInstance, TextureUnit texture, TexCoordPointerType type, uint[] coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoordP1uiv(texture, type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoordP1ui(this GL glInstance, TextureUnit texture, TexCoordPointerType type, in uint coords)
        {
            fixed (uint* coords_ptr = &coords) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoordP1uiv(texture, type, coords_ptr);
            }
        }

        // MultiTexCoordP2uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoordP2ui(this GL glInstance, TextureUnit texture, TexCoordPointerType type, ReadOnlySpan<uint> coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoordP2uiv(texture, type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoordP2ui(this GL glInstance, TextureUnit texture, TexCoordPointerType type, uint[] coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoordP2uiv(texture, type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoordP2ui(this GL glInstance, TextureUnit texture, TexCoordPointerType type, in uint coords)
        {
            fixed (uint* coords_ptr = &coords) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoordP2uiv(texture, type, coords_ptr);
            }
        }

        // MultiTexCoordP3uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoordP3ui(this GL glInstance, TextureUnit texture, TexCoordPointerType type, ReadOnlySpan<uint> coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoordP3uiv(texture, type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoordP3ui(this GL glInstance, TextureUnit texture, TexCoordPointerType type, uint[] coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoordP3uiv(texture, type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoordP3ui(this GL glInstance, TextureUnit texture, TexCoordPointerType type, in uint coords)
        {
            fixed (uint* coords_ptr = &coords) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoordP3uiv(texture, type, coords_ptr);
            }
        }

        // MultiTexCoordP4uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoordP4ui(this GL glInstance, TextureUnit texture, TexCoordPointerType type, ReadOnlySpan<uint> coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoordP4uiv(texture, type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiTexCoordP4ui(this GL glInstance, TextureUnit texture, TexCoordPointerType type, uint[] coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.MultiTexCoordP4uiv(texture, type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiTexCoordP4ui(this GL glInstance, TextureUnit texture, TexCoordPointerType type, in uint coords)
        {
            fixed (uint* coords_ptr = &coords) // RefInsteadOfPointerLayer
            {
                glInstance.MultiTexCoordP4uiv(texture, type, coords_ptr);
            }
        }

        // NormalP3uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void NormalP3ui(this GL glInstance, NormalPointerType type, ReadOnlySpan<uint> coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.NormalP3uiv(type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void NormalP3ui(this GL glInstance, NormalPointerType type, uint[] coords)
        {
            fixed (uint* coords_ptr = coords) // SpanOrArrayLayer
            {
                glInstance.NormalP3uiv(type, coords_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void NormalP3ui(this GL glInstance, NormalPointerType type, in uint coords)
        {
            fixed (uint* coords_ptr = &coords) // RefInsteadOfPointerLayer
            {
                glInstance.NormalP3uiv(type, coords_ptr);
            }
        }

        // ColorP3uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ColorP3ui(this GL glInstance, ColorPointerType type, ReadOnlySpan<uint> color)
        {
            fixed (uint* color_ptr = color) // SpanOrArrayLayer
            {
                glInstance.ColorP3uiv(type, color_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ColorP3ui(this GL glInstance, ColorPointerType type, uint[] color)
        {
            fixed (uint* color_ptr = color) // SpanOrArrayLayer
            {
                glInstance.ColorP3uiv(type, color_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ColorP3ui(this GL glInstance, ColorPointerType type, in uint color)
        {
            fixed (uint* color_ptr = &color) // RefInsteadOfPointerLayer
            {
                glInstance.ColorP3uiv(type, color_ptr);
            }
        }

        // ColorP4uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ColorP4ui(this GL glInstance, ColorPointerType type, ReadOnlySpan<uint> color)
        {
            fixed (uint* color_ptr = color) // SpanOrArrayLayer
            {
                glInstance.ColorP4uiv(type, color_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ColorP4ui(this GL glInstance, ColorPointerType type, uint[] color)
        {
            fixed (uint* color_ptr = color) // SpanOrArrayLayer
            {
                glInstance.ColorP4uiv(type, color_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ColorP4ui(this GL glInstance, ColorPointerType type, in uint color)
        {
            fixed (uint* color_ptr = &color) // RefInsteadOfPointerLayer
            {
                glInstance.ColorP4uiv(type, color_ptr);
            }
        }

        // SecondaryColorP3uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SecondaryColorP3ui(this GL glInstance, ColorPointerType type, ReadOnlySpan<uint> color)
        {
            fixed (uint* color_ptr = color) // SpanOrArrayLayer
            {
                glInstance.SecondaryColorP3uiv(type, color_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void SecondaryColorP3ui(this GL glInstance, ColorPointerType type, uint[] color)
        {
            fixed (uint* color_ptr = color) // SpanOrArrayLayer
            {
                glInstance.SecondaryColorP3uiv(type, color_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SecondaryColorP3ui(this GL glInstance, ColorPointerType type, in uint color)
        {
            fixed (uint* color_ptr = &color) // RefInsteadOfPointerLayer
            {
                glInstance.SecondaryColorP3uiv(type, color_ptr);
            }
        }

        // DrawArraysIndirect overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void DrawArraysIndirect(this GL glInstance, PrimitiveType mode, IntPtr indirect)
        {
            var indirect_vptr = (void*)indirect;
            glInstance.DrawArraysIndirect(mode, indirect_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DrawArraysIndirect<T1>(this GL glInstance, PrimitiveType mode, in T1 indirect)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = &indirect) // RefInsteadOfPointerLayer
            {
                glInstance.DrawArraysIndirect(mode, indirect_ptr);
            }
        }

        // DrawElementsIndirect overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void DrawElementsIndirect(this GL glInstance, PrimitiveType mode, DrawElementsType type, IntPtr indirect)
        {
            var indirect_vptr = (void*)indirect;
            glInstance.DrawElementsIndirect(mode, type, indirect_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DrawElementsIndirect<T1>(this GL glInstance, PrimitiveType mode, DrawElementsType type, in T1 indirect)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = &indirect) // RefInsteadOfPointerLayer
            {
                glInstance.DrawElementsIndirect(mode, type, indirect_ptr);
            }
        }

        // Uniform1dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1dv(this GL glInstance, int location, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 1);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1dv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform1dv(this GL glInstance, int location, double[] value)
        {
            var count = (int)(value.Length / 1);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform1dv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform1dv(this GL glInstance, int location, int count, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform1dv(location, count, value_ptr);
            }
        }

        // Uniform2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2dv(this GL glInstance, int location, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 2);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2dv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform2dv(this GL glInstance, int location, double[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform2dv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform2dv(this GL glInstance, int location, int count, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform2dv(location, count, value_ptr);
            }
        }

        // Uniform3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3dv(this GL glInstance, int location, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 3);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3dv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform3dv(this GL glInstance, int location, double[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform3dv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform3dv(this GL glInstance, int location, int count, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform3dv(location, count, value_ptr);
            }
        }

        // Uniform4dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4dv(this GL glInstance, int location, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 4);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4dv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void Uniform4dv(this GL glInstance, int location, double[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.Uniform4dv(location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void Uniform4dv(this GL glInstance, int location, int count, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.Uniform4dv(location, count, value_ptr);
            }
        }

        // UniformMatrix2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2dv(this GL glInstance, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 4);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2dv(this GL glInstance, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix2dv(this GL glInstance, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2dv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3dv(this GL glInstance, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 9);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3dv(this GL glInstance, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 9);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix3dv(this GL glInstance, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3dv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix4dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4dv(this GL glInstance, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 16);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4dv(this GL glInstance, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 16);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix4dv(this GL glInstance, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4dv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix2x3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2x3dv(this GL glInstance, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 6);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x3dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2x3dv(this GL glInstance, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 6);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x3dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix2x3dv(this GL glInstance, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x3dv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix2x4dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2x4dv(this GL glInstance, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 8);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x4dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix2x4dv(this GL glInstance, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 8);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x4dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix2x4dv(this GL glInstance, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix2x4dv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix3x2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3x2dv(this GL glInstance, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 6);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x2dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3x2dv(this GL glInstance, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 6);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x2dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix3x2dv(this GL glInstance, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x2dv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix3x4dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3x4dv(this GL glInstance, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 12);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x4dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix3x4dv(this GL glInstance, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 12);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x4dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix3x4dv(this GL glInstance, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix3x4dv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix4x2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4x2dv(this GL glInstance, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 8);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x2dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4x2dv(this GL glInstance, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 8);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x2dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix4x2dv(this GL glInstance, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x2dv(location, count, transpose_byte, value_ptr);
            }
        }

        // UniformMatrix4x3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4x3dv(this GL glInstance, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 12);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x3dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformMatrix4x3dv(this GL glInstance, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 12);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x3dv(location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformMatrix4x3dv(this GL glInstance, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.UniformMatrix4x3dv(location, count, transpose_byte, value_ptr);
            }
        }

        // GetUniformdv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformd(this GL glInstance, ProgramHandle program, int location, Span<double> parameters)
        {
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformdv(program, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformd(this GL glInstance, ProgramHandle program, int location, double[] parameters)
        {
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformdv(program, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetUniformd(this GL glInstance, ProgramHandle program, int location, ref double parameters)
        {
            fixed (double* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetUniformdv(program, location, parameters_ptr);
            }
        }

        // GetSubroutineUniformLocation overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe int GetSubroutineUniformLocation(this GL glInstance, ProgramHandle program, ShaderType shadertype, string name)
        {
            int returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = glInstance.GetSubroutineUniformLocation(program, shadertype, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }

        // GetSubroutineIndex overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe uint GetSubroutineIndex(this GL glInstance, ProgramHandle program, ShaderType shadertype, string name)
        {
            uint returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = glInstance.GetSubroutineIndex(program, shadertype, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }

        // GetActiveSubroutineUniformiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveSubroutineUniformi(this GL glInstance, ProgramHandle program, ShaderType shadertype, uint index, SubroutineParameterName pname, Span<int> values)
        {
            fixed (int* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.GetActiveSubroutineUniformiv(program, shadertype, index, pname, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveSubroutineUniformi(this GL glInstance, ProgramHandle program, ShaderType shadertype, uint index, SubroutineParameterName pname, int[] values)
        {
            fixed (int* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.GetActiveSubroutineUniformiv(program, shadertype, index, pname, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveSubroutineUniformi(this GL glInstance, ProgramHandle program, ShaderType shadertype, uint index, SubroutineParameterName pname, ref int values)
        {
            fixed (int* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                glInstance.GetActiveSubroutineUniformiv(program, shadertype, index, pname, values_ptr);
            }
        }

        // GetActiveSubroutineUniformName overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveSubroutineUniformName(this GL glInstance, ProgramHandle program, ShaderType shadertype, uint index, int bufSize, Span<int> length)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveSubroutineUniformName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveSubroutineUniformName(this GL glInstance, ProgramHandle program, ShaderType shadertype, uint index, int bufSize, Span<int> length, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveSubroutineUniformName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveSubroutineUniformName(this GL glInstance, ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int[] length)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveSubroutineUniformName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveSubroutineUniformName(this GL glInstance, ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int[] length, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveSubroutineUniformName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveSubroutineUniformName(this GL glInstance, ProgramHandle program, ShaderType shadertype, uint index, int bufSize, ref int length)
        {
            string name;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveSubroutineUniformName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveSubroutineUniformName(this GL glInstance, ProgramHandle program, ShaderType shadertype, uint index, int bufSize, ref int length, out string name)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveSubroutineUniformName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // GetActiveSubroutineName overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveSubroutineName(this GL glInstance, ProgramHandle program, ShaderType shadertype, uint index, int bufSize, Span<int> length)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveSubroutineName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveSubroutineName(this GL glInstance, ProgramHandle program, ShaderType shadertype, uint index, int bufSize, Span<int> length, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveSubroutineName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveSubroutineName(this GL glInstance, ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int[] length)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveSubroutineName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveSubroutineName(this GL glInstance, ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int[] length, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveSubroutineName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetActiveSubroutineName(this GL glInstance, ProgramHandle program, ShaderType shadertype, uint index, int bufSize, ref int length)
        {
            string name;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveSubroutineName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveSubroutineName(this GL glInstance, ProgramHandle program, ShaderType shadertype, uint index, int bufSize, ref int length, out string name)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetActiveSubroutineName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // UniformSubroutinesuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformSubroutinesui(this GL glInstance, ShaderType shadertype, ReadOnlySpan<uint> indices)
        {
            var count = (int)(indices.Length);
            fixed (uint* indices_ptr = indices) // SpanOrArrayLayer
            {
                glInstance.UniformSubroutinesuiv(shadertype, count, indices_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void UniformSubroutinesui(this GL glInstance, ShaderType shadertype, uint[] indices)
        {
            var count = (int)(indices.Length);
            fixed (uint* indices_ptr = indices) // SpanOrArrayLayer
            {
                glInstance.UniformSubroutinesuiv(shadertype, count, indices_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void UniformSubroutinesui(this GL glInstance, ShaderType shadertype, int count, in uint indices)
        {
            fixed (uint* indices_ptr = &indices) // RefInsteadOfPointerLayer
            {
                glInstance.UniformSubroutinesuiv(shadertype, count, indices_ptr);
            }
        }

        // GetUniformSubroutineuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformSubroutineui(this GL glInstance, ShaderType shadertype, int location, Span<uint> parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformSubroutineuiv(shadertype, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetUniformSubroutineui(this GL glInstance, ShaderType shadertype, int location, uint[] parameters)
        {
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetUniformSubroutineuiv(shadertype, location, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetUniformSubroutineui(this GL glInstance, ShaderType shadertype, int location, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetUniformSubroutineuiv(shadertype, location, parameters_ptr);
            }
        }

        // GetProgramStageiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramStagei(this GL glInstance, ProgramHandle program, ShaderType shadertype, ProgramStagePName pname, Span<int> values)
        {
            fixed (int* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.GetProgramStageiv(program, shadertype, pname, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramStagei(this GL glInstance, ProgramHandle program, ShaderType shadertype, ProgramStagePName pname, int[] values)
        {
            fixed (int* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.GetProgramStageiv(program, shadertype, pname, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramStagei(this GL glInstance, ProgramHandle program, ShaderType shadertype, ProgramStagePName pname, ref int values)
        {
            fixed (int* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                glInstance.GetProgramStageiv(program, shadertype, pname, values_ptr);
            }
        }

        // PatchParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PatchParameterf(this GL glInstance, PatchParameterName pname, ReadOnlySpan<float> values)
        {
            fixed (float* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.PatchParameterfv(pname, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void PatchParameterf(this GL glInstance, PatchParameterName pname, float[] values)
        {
            fixed (float* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.PatchParameterfv(pname, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void PatchParameterf(this GL glInstance, PatchParameterName pname, in float values)
        {
            fixed (float* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                glInstance.PatchParameterfv(pname, values_ptr);
            }
        }

        // DeleteTransformFeedbacks overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void DeleteTransformFeedback(this GL glInstance, in TransformFeedbackHandle ids)
        {
            int n = 1;
            fixed(TransformFeedbackHandle* ids_handle = &ids) // DeleteOverloadLayer
                glInstance.DeleteTransformFeedbacks(n, ids_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteTransformFeedbacks(this GL glInstance, ReadOnlySpan<TransformFeedbackHandle> ids)
        {
            var n = (int)(ids.Length);
            fixed (TransformFeedbackHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.DeleteTransformFeedbacks(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteTransformFeedbacks(this GL glInstance, TransformFeedbackHandle[] ids)
        {
            var n = (int)(ids.Length);
            fixed (TransformFeedbackHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.DeleteTransformFeedbacks(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteTransformFeedbacks(this GL glInstance, int n, in TransformFeedbackHandle ids)
        {
            fixed (TransformFeedbackHandle* ids_ptr = &ids) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteTransformFeedbacks(n, ids_ptr);
            }
        }

        // GenTransformFeedbacks overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe TransformFeedbackHandle GenTransformFeedback(this GL glInstance)
        {
            TransformFeedbackHandle ids;
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TransformFeedbackHandle* ids_handle = (TransformFeedbackHandle*)Unsafe.AsPointer(ref ids);
            glInstance.GenTransformFeedbacks(n, ids_handle);
            return ids;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void GenTransformFeedback(this GL glInstance, out TransformFeedbackHandle ids)
        {
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TransformFeedbackHandle* ids_handle = (TransformFeedbackHandle*)Unsafe.AsPointer(ref ids);
            glInstance.GenTransformFeedbacks(n, ids_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenTransformFeedbacks(this GL glInstance, Span<TransformFeedbackHandle> ids)
        {
            var n = (int)(ids.Length);
            fixed (TransformFeedbackHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.GenTransformFeedbacks(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenTransformFeedbacks(this GL glInstance, TransformFeedbackHandle[] ids)
        {
            var n = (int)(ids.Length);
            fixed (TransformFeedbackHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.GenTransformFeedbacks(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenTransformFeedbacks(this GL glInstance, int n, ref TransformFeedbackHandle ids)
        {
            fixed (TransformFeedbackHandle* ids_ptr = &ids) // RefInsteadOfPointerLayer
            {
                glInstance.GenTransformFeedbacks(n, ids_ptr);
            }
        }

        // GetQueryIndexediv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryIndexedi(this GL glInstance, QueryTarget target, uint index, QueryParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryIndexediv(target, index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetQueryIndexedi(this GL glInstance, QueryTarget target, uint index, QueryParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetQueryIndexediv(target, index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetQueryIndexedi(this GL glInstance, QueryTarget target, uint index, QueryParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetQueryIndexediv(target, index, pname, parameters_ptr);
            }
        }

        // ShaderBinary overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ShaderBinary(this GL glInstance, ReadOnlySpan<ShaderHandle> shaders, ShaderBinaryFormat binaryFormat, IntPtr binary, int length)
        {
            var count = (int)(shaders.Length);
            fixed (ShaderHandle* shaders_ptr = shaders) // SpanOrArrayLayer
            {
                var binary_vptr = (void*)binary;
                glInstance.ShaderBinary(count, shaders_ptr, binaryFormat, binary_vptr, length);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ShaderBinary(this GL glInstance, ShaderHandle[] shaders, ShaderBinaryFormat binaryFormat, IntPtr binary, int length)
        {
            var count = (int)(shaders.Length);
            fixed (ShaderHandle* shaders_ptr = shaders) // SpanOrArrayLayer
            {
                var binary_vptr = (void*)binary;
                glInstance.ShaderBinary(count, shaders_ptr, binaryFormat, binary_vptr, length);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ShaderBinary(this GL glInstance, int count, in ShaderHandle shaders, ShaderBinaryFormat binaryFormat, IntPtr binary, int length)
        {
            fixed (ShaderHandle* shaders_ptr = &shaders) // RefInsteadOfPointerLayer
            {
                var binary_vptr = (void*)binary;
                glInstance.ShaderBinary(count, shaders_ptr, binaryFormat, binary_vptr, length);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ShaderBinary<T1>(this GL glInstance, ReadOnlySpan<ShaderHandle> shaders, ShaderBinaryFormat binaryFormat, ReadOnlySpan<T1> binary)
            where T1 : unmanaged
        {
            var count = (int)(shaders.Length);
            fixed (ShaderHandle* shaders_ptr = shaders) // SpanOrArrayLayer
            {
                var length = (int)(binary.Length * sizeof(T1));
                fixed (void* binary_ptr = binary) // SpanOrArrayLayer
                {
                    glInstance.ShaderBinary(count, shaders_ptr, binaryFormat, binary_ptr, length);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ShaderBinary<T1>(this GL glInstance, ShaderHandle[] shaders, ShaderBinaryFormat binaryFormat, T1[] binary)
            where T1 : unmanaged
        {
            var count = (int)(shaders.Length);
            fixed (ShaderHandle* shaders_ptr = shaders) // SpanOrArrayLayer
            {
                var length = (int)(binary.Length * sizeof(T1));
                fixed (void* binary_ptr = binary) // SpanOrArrayLayer
                {
                    glInstance.ShaderBinary(count, shaders_ptr, binaryFormat, binary_ptr, length);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ShaderBinary<T1>(this GL glInstance, int count, in ShaderHandle shaders, ShaderBinaryFormat binaryFormat, in T1 binary, int length)
            where T1 : unmanaged
        {
            fixed (ShaderHandle* shaders_ptr = &shaders) // RefInsteadOfPointerLayer
            fixed (void* binary_ptr = &binary) // RefInsteadOfPointerLayer
            {
                glInstance.ShaderBinary(count, shaders_ptr, binaryFormat, binary_ptr, length);
            }
        }

        // GetShaderPrecisionFormat overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetShaderPrecisionFormat(this GL glInstance, ShaderType shadertype, PrecisionType precisiontype, Span<int> range, Span<int> precision)
        {
            fixed (int* range_ptr = range) // SpanOrArrayLayer
            {
                fixed (int* precision_ptr = precision) // SpanOrArrayLayer
                {
                    glInstance.GetShaderPrecisionFormat(shadertype, precisiontype, range_ptr, precision_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetShaderPrecisionFormat(this GL glInstance, ShaderType shadertype, PrecisionType precisiontype, int[] range, int[] precision)
        {
            fixed (int* range_ptr = range) // SpanOrArrayLayer
            {
                fixed (int* precision_ptr = precision) // SpanOrArrayLayer
                {
                    glInstance.GetShaderPrecisionFormat(shadertype, precisiontype, range_ptr, precision_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetShaderPrecisionFormat(this GL glInstance, ShaderType shadertype, PrecisionType precisiontype, ref int range, ref int precision)
        {
            fixed (int* range_ptr = &range) // RefInsteadOfPointerLayer
            fixed (int* precision_ptr = &precision) // RefInsteadOfPointerLayer
            {
                glInstance.GetShaderPrecisionFormat(shadertype, precisiontype, range_ptr, precision_ptr);
            }
        }

        // GetProgramBinary overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramBinary(this GL glInstance, ProgramHandle program, int bufSize, Span<int> length, Span<GLEnum> binaryFormat, IntPtr binary)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (GLEnum* binaryFormat_ptr = binaryFormat) // SpanOrArrayLayer
                {
                    var binary_vptr = (void*)binary;
                    glInstance.GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_vptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramBinary(this GL glInstance, ProgramHandle program, int bufSize, int[] length, GLEnum[] binaryFormat, IntPtr binary)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (GLEnum* binaryFormat_ptr = binaryFormat) // SpanOrArrayLayer
                {
                    var binary_vptr = (void*)binary;
                    glInstance.GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_vptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramBinary(this GL glInstance, ProgramHandle program, int bufSize, ref int length, ref GLEnum binaryFormat, IntPtr binary)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (GLEnum* binaryFormat_ptr = &binaryFormat) // RefInsteadOfPointerLayer
            {
                var binary_vptr = (void*)binary;
                glInstance.GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_vptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramBinary<T1>(this GL glInstance, ProgramHandle program, Span<int> length, Span<GLEnum> binaryFormat, Span<T1> binary)
            where T1 : unmanaged
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (GLEnum* binaryFormat_ptr = binaryFormat) // SpanOrArrayLayer
                {
                    var bufSize = (int)(binary.Length * sizeof(T1));
                    fixed (void* binary_ptr = binary) // SpanOrArrayLayer
                    {
                        glInstance.GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramBinary<T1>(this GL glInstance, ProgramHandle program, int[] length, GLEnum[] binaryFormat, T1[] binary)
            where T1 : unmanaged
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                fixed (GLEnum* binaryFormat_ptr = binaryFormat) // SpanOrArrayLayer
                {
                    var bufSize = (int)(binary.Length * sizeof(T1));
                    fixed (void* binary_ptr = binary) // SpanOrArrayLayer
                    {
                        glInstance.GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramBinary<T1>(this GL glInstance, ProgramHandle program, int bufSize, ref int length, ref GLEnum binaryFormat, ref T1 binary)
            where T1 : unmanaged
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (GLEnum* binaryFormat_ptr = &binaryFormat) // RefInsteadOfPointerLayer
            fixed (void* binary_ptr = &binary) // RefInsteadOfPointerLayer
            {
                glInstance.GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_ptr);
            }
        }

        // ProgramBinary overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ProgramBinary(this GL glInstance, ProgramHandle program, GLEnum binaryFormat, IntPtr binary, int length)
        {
            var binary_vptr = (void*)binary;
            glInstance.ProgramBinary(program, binaryFormat, binary_vptr, length);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramBinary<T1>(this GL glInstance, ProgramHandle program, GLEnum binaryFormat, ReadOnlySpan<T1> binary)
            where T1 : unmanaged
        {
            var length = (int)(binary.Length * sizeof(T1));
            fixed (void* binary_ptr = binary) // SpanOrArrayLayer
            {
                glInstance.ProgramBinary(program, binaryFormat, binary_ptr, length);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramBinary<T1>(this GL glInstance, ProgramHandle program, GLEnum binaryFormat, T1[] binary)
            where T1 : unmanaged
        {
            var length = (int)(binary.Length * sizeof(T1));
            fixed (void* binary_ptr = binary) // SpanOrArrayLayer
            {
                glInstance.ProgramBinary(program, binaryFormat, binary_ptr, length);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramBinary<T1>(this GL glInstance, ProgramHandle program, GLEnum binaryFormat, in T1 binary, int length)
            where T1 : unmanaged
        {
            fixed (void* binary_ptr = &binary) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramBinary(program, binaryFormat, binary_ptr, length);
            }
        }

        // CreateShaderProgramv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe ProgramHandle CreateShaderProgram(this GL glInstance, ShaderType type, int count, byte** strings)
        {
            ProgramHandle returnValue;
            returnValue = glInstance.CreateShaderProgramv(type, count, strings);
            return returnValue;
        }

        // DeleteProgramPipelines overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void DeleteProgramPipeline(this GL glInstance, in ProgramPipelineHandle pipelines)
        {
            int n = 1;
            fixed(ProgramPipelineHandle* pipelines_handle = &pipelines) // DeleteOverloadLayer
                glInstance.DeleteProgramPipelines(n, pipelines_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteProgramPipelines(this GL glInstance, ReadOnlySpan<ProgramPipelineHandle> pipelines)
        {
            var n = (int)(pipelines.Length);
            fixed (ProgramPipelineHandle* pipelines_ptr = pipelines) // SpanOrArrayLayer
            {
                glInstance.DeleteProgramPipelines(n, pipelines_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DeleteProgramPipelines(this GL glInstance, ProgramPipelineHandle[] pipelines)
        {
            var n = (int)(pipelines.Length);
            fixed (ProgramPipelineHandle* pipelines_ptr = pipelines) // SpanOrArrayLayer
            {
                glInstance.DeleteProgramPipelines(n, pipelines_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DeleteProgramPipelines(this GL glInstance, int n, in ProgramPipelineHandle pipelines)
        {
            fixed (ProgramPipelineHandle* pipelines_ptr = &pipelines) // RefInsteadOfPointerLayer
            {
                glInstance.DeleteProgramPipelines(n, pipelines_ptr);
            }
        }

        // GenProgramPipelines overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe ProgramPipelineHandle GenProgramPipeline(this GL glInstance)
        {
            ProgramPipelineHandle pipelines;
            int n = 1;
            Unsafe.SkipInit(out pipelines);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            ProgramPipelineHandle* pipelines_handle = (ProgramPipelineHandle*)Unsafe.AsPointer(ref pipelines);
            glInstance.GenProgramPipelines(n, pipelines_handle);
            return pipelines;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void GenProgramPipeline(this GL glInstance, out ProgramPipelineHandle pipelines)
        {
            int n = 1;
            Unsafe.SkipInit(out pipelines);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            ProgramPipelineHandle* pipelines_handle = (ProgramPipelineHandle*)Unsafe.AsPointer(ref pipelines);
            glInstance.GenProgramPipelines(n, pipelines_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenProgramPipelines(this GL glInstance, Span<ProgramPipelineHandle> pipelines)
        {
            var n = (int)(pipelines.Length);
            fixed (ProgramPipelineHandle* pipelines_ptr = pipelines) // SpanOrArrayLayer
            {
                glInstance.GenProgramPipelines(n, pipelines_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GenProgramPipelines(this GL glInstance, ProgramPipelineHandle[] pipelines)
        {
            var n = (int)(pipelines.Length);
            fixed (ProgramPipelineHandle* pipelines_ptr = pipelines) // SpanOrArrayLayer
            {
                glInstance.GenProgramPipelines(n, pipelines_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GenProgramPipelines(this GL glInstance, int n, ref ProgramPipelineHandle pipelines)
        {
            fixed (ProgramPipelineHandle* pipelines_ptr = &pipelines) // RefInsteadOfPointerLayer
            {
                glInstance.GenProgramPipelines(n, pipelines_ptr);
            }
        }

        // GetProgramPipelineiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramPipelinei(this GL glInstance, ProgramPipelineHandle pipeline, PipelineParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramPipelineiv(pipeline, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramPipelinei(this GL glInstance, ProgramPipelineHandle pipeline, PipelineParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramPipelineiv(pipeline, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramPipelinei(this GL glInstance, ProgramPipelineHandle pipeline, PipelineParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetProgramPipelineiv(pipeline, pname, parameters_ptr);
            }
        }

        // ProgramUniform1iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1iv(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<int> value)
        {
            var count = (int)(value.Length);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1iv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1iv(this GL glInstance, ProgramHandle program, int location, int[] value)
        {
            var count = (int)(value.Length);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1iv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform1iv(this GL glInstance, ProgramHandle program, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform1iv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform1fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1fv(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1fv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1fv(this GL glInstance, ProgramHandle program, int location, float[] value)
        {
            var count = (int)(value.Length);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1fv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform1fv(this GL glInstance, ProgramHandle program, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform1fv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform1dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1dv(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1dv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1dv(this GL glInstance, ProgramHandle program, int location, double[] value)
        {
            var count = (int)(value.Length);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1dv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform1dv(this GL glInstance, ProgramHandle program, int location, int count, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform1dv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform1uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1ui(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<uint> value)
        {
            var count = (int)(value.Length);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1uiv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform1ui(this GL glInstance, ProgramHandle program, int location, uint[] value)
        {
            var count = (int)(value.Length);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform1uiv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform1ui(this GL glInstance, ProgramHandle program, int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform1uiv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform2iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2iv(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<int> value)
        {
            var count = (int)(value.Length / 2);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2iv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2iv(this GL glInstance, ProgramHandle program, int location, int[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2iv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform2iv(this GL glInstance, ProgramHandle program, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform2iv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2fv(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 2);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2fv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2fv(this GL glInstance, ProgramHandle program, int location, float[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2fv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform2fv(this GL glInstance, ProgramHandle program, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform2fv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2dv(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 2);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2dv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2dv(this GL glInstance, ProgramHandle program, int location, double[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2dv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform2dv(this GL glInstance, ProgramHandle program, int location, int count, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform2dv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform2uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2ui(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<uint> value)
        {
            var count = (int)(value.Length / 2);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2uiv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform2ui(this GL glInstance, ProgramHandle program, int location, uint[] value)
        {
            var count = (int)(value.Length / 2);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform2uiv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform2ui(this GL glInstance, ProgramHandle program, int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform2uiv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform3iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3iv(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<int> value)
        {
            var count = (int)(value.Length / 3);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3iv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3iv(this GL glInstance, ProgramHandle program, int location, int[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3iv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform3iv(this GL glInstance, ProgramHandle program, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform3iv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3fv(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 3);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3fv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3fv(this GL glInstance, ProgramHandle program, int location, float[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3fv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform3fv(this GL glInstance, ProgramHandle program, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform3fv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3dv(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 3);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3dv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3dv(this GL glInstance, ProgramHandle program, int location, double[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3dv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform3dv(this GL glInstance, ProgramHandle program, int location, int count, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform3dv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform3uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3ui(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<uint> value)
        {
            var count = (int)(value.Length / 3);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3uiv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform3ui(this GL glInstance, ProgramHandle program, int location, uint[] value)
        {
            var count = (int)(value.Length / 3);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform3uiv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform3ui(this GL glInstance, ProgramHandle program, int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform3uiv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform4iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4iv(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<int> value)
        {
            var count = (int)(value.Length / 4);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4iv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4iv(this GL glInstance, ProgramHandle program, int location, int[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (int* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4iv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform4iv(this GL glInstance, ProgramHandle program, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform4iv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4fv(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 4);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4fv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4fv(this GL glInstance, ProgramHandle program, int location, float[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4fv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform4fv(this GL glInstance, ProgramHandle program, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform4fv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform4dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4dv(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 4);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4dv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4dv(this GL glInstance, ProgramHandle program, int location, double[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4dv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform4dv(this GL glInstance, ProgramHandle program, int location, int count, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform4dv(program, location, count, value_ptr);
            }
        }

        // ProgramUniform4uiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4ui(this GL glInstance, ProgramHandle program, int location, ReadOnlySpan<uint> value)
        {
            var count = (int)(value.Length / 4);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4uiv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniform4ui(this GL glInstance, ProgramHandle program, int location, uint[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (uint* value_ptr = value) // SpanOrArrayLayer
            {
                glInstance.ProgramUniform4uiv(program, location, count, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniform4ui(this GL glInstance, ProgramHandle program, int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ProgramUniform4uiv(program, location, count, value_ptr);
            }
        }

        // ProgramUniformMatrix2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2fv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 4);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2fv(this GL glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix2fv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3fv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 9);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3fv(this GL glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 9);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix3fv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4fv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 16);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4fv(this GL glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 16);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix4fv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2dv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 4);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2dv(this GL glInstance, ProgramHandle program, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 4);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix2dv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3dv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 9);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3dv(this GL glInstance, ProgramHandle program, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 9);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix3dv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix4dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4dv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 16);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4dv(this GL glInstance, ProgramHandle program, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 16);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix4dv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix2x3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2x3fv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 6);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2x3fv(this GL glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 6);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix2x3fv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix3x2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3x2fv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 6);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3x2fv(this GL glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 6);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix3x2fv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix2x4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2x4fv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 8);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2x4fv(this GL glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 8);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix2x4fv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix4x2fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4x2fv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 8);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4x2fv(this GL glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 8);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix4x2fv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x2fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix3x4fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3x4fv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 12);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3x4fv(this GL glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 12);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix3x4fv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x4fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix4x3fv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4x3fv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
        {
            var count = (int)(value.Length / 12);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4x3fv(this GL glInstance, ProgramHandle program, int location, bool transpose, float[] value)
        {
            var count = (int)(value.Length / 12);
            fixed (float* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix4x3fv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x3fv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix2x3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2x3dv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 6);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x3dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2x3dv(this GL glInstance, ProgramHandle program, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 6);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x3dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix2x3dv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x3dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix3x2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3x2dv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 6);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x2dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3x2dv(this GL glInstance, ProgramHandle program, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 6);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x2dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix3x2dv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x2dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix2x4dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2x4dv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 8);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x4dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix2x4dv(this GL glInstance, ProgramHandle program, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 8);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x4dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix2x4dv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix2x4dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix4x2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4x2dv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 8);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x2dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4x2dv(this GL glInstance, ProgramHandle program, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 8);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x2dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix4x2dv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x2dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix3x4dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3x4dv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 12);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x4dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix3x4dv(this GL glInstance, ProgramHandle program, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 12);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x4dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix3x4dv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix3x4dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // ProgramUniformMatrix4x3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4x3dv(this GL glInstance, ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
        {
            var count = (int)(value.Length / 12);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x3dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ProgramUniformMatrix4x3dv(this GL glInstance, ProgramHandle program, int location, bool transpose, double[] value)
        {
            var count = (int)(value.Length / 12);
            fixed (double* value_ptr = value) // SpanOrArrayLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x3dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ProgramUniformMatrix4x3dv(this GL glInstance, ProgramHandle program, int location, int count, bool transpose, in double value)
        {
            fixed (double* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                var transpose_byte = (byte)(transpose ? 1 : 0);
                glInstance.ProgramUniformMatrix4x3dv(program, location, count, transpose_byte, value_ptr);
            }
        }

        // GetProgramPipelineInfoLog overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetProgramPipelineInfoLog(this GL glInstance, ProgramPipelineHandle pipeline, int bufSize, Span<int> length)
        {
            string infoLog;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramPipelineInfoLog(this GL glInstance, ProgramPipelineHandle pipeline, int bufSize, Span<int> length, out string infoLog)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetProgramPipelineInfoLog(this GL glInstance, ProgramPipelineHandle pipeline, int bufSize, int[] length)
        {
            string infoLog;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramPipelineInfoLog(this GL glInstance, ProgramPipelineHandle pipeline, int bufSize, int[] length, out string infoLog)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetProgramPipelineInfoLog(this GL glInstance, ProgramPipelineHandle pipeline, int bufSize, ref int length)
        {
            string infoLog;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramPipelineInfoLog(this GL glInstance, ProgramPipelineHandle pipeline, int bufSize, ref int length, out string infoLog)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }

        // VertexAttribL1dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribL1dv(this GL glInstance, uint index, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribL1dv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribL1dv(this GL glInstance, uint index, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribL1dv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribL1dv(this GL glInstance, uint index, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttribL1dv(index, v_ptr);
            }
        }

        // VertexAttribL2dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribL2dv(this GL glInstance, uint index, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribL2dv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribL2dv(this GL glInstance, uint index, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribL2dv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribL2dv(this GL glInstance, uint index, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttribL2dv(index, v_ptr);
            }
        }

        // VertexAttribL3dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribL3dv(this GL glInstance, uint index, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribL3dv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribL3dv(this GL glInstance, uint index, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribL3dv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribL3dv(this GL glInstance, uint index, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttribL3dv(index, v_ptr);
            }
        }

        // VertexAttribL4dv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribL4dv(this GL glInstance, uint index, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribL4dv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void VertexAttribL4dv(this GL glInstance, uint index, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.VertexAttribL4dv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexAttribL4dv(this GL glInstance, uint index, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.VertexAttribL4dv(index, v_ptr);
            }
        }

        // VertexAttribLPointer overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void VertexAttribLPointer(this GL glInstance, uint index, int size, VertexAttribLType type, int stride, nint offset)
        {
            void* pointer = (void*)offset;
            glInstance.VertexAttribLPointer(index, size, type, stride, pointer);
        }

        // GetVertexAttribLdv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribLd(this GL glInstance, uint index, VertexAttribEnum pname, Span<double> parameters)
        {
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribLdv(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetVertexAttribLd(this GL glInstance, uint index, VertexAttribEnum pname, double[] parameters)
        {
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetVertexAttribLdv(index, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetVertexAttribLd(this GL glInstance, uint index, VertexAttribEnum pname, ref double parameters)
        {
            fixed (double* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetVertexAttribLdv(index, pname, parameters_ptr);
            }
        }

        // ViewportArrayv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ViewportArray(this GL glInstance, uint first, int count, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ViewportArrayv(first, count, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ViewportArray(this GL glInstance, uint first, int count, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ViewportArrayv(first, count, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ViewportArray(this GL glInstance, uint first, int count, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.ViewportArrayv(first, count, v_ptr);
            }
        }

        // ViewportIndexedfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ViewportIndexedf(this GL glInstance, uint index, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ViewportIndexedfv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ViewportIndexedf(this GL glInstance, uint index, float[] v)
        {
            fixed (float* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ViewportIndexedfv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ViewportIndexedf(this GL glInstance, uint index, in float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.ViewportIndexedfv(index, v_ptr);
            }
        }

        // ScissorArrayv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ScissorArray(this GL glInstance, uint first, int count, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ScissorArrayv(first, count, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ScissorArray(this GL glInstance, uint first, int count, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ScissorArrayv(first, count, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ScissorArray(this GL glInstance, uint first, int count, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.ScissorArrayv(first, count, v_ptr);
            }
        }

        // ScissorIndexedv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ScissorIndexedv(this GL glInstance, uint index, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ScissorIndexedv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ScissorIndexedv(this GL glInstance, uint index, int[] v)
        {
            fixed (int* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.ScissorIndexedv(index, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ScissorIndexedv(this GL glInstance, uint index, in int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.ScissorIndexedv(index, v_ptr);
            }
        }

        // DepthRangeArrayv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DepthRangeArray(this GL glInstance, uint first, int count, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.DepthRangeArrayv(first, count, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DepthRangeArray(this GL glInstance, uint first, int count, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.DepthRangeArrayv(first, count, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DepthRangeArray(this GL glInstance, uint first, int count, in double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.DepthRangeArrayv(first, count, v_ptr);
            }
        }

        // GetFloati_v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetFloat(this GL glInstance, GetPName target, uint index, Span<float> data)
        {
            fixed (float* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetFloati_v(target, index, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetFloat(this GL glInstance, GetPName target, uint index, float[] data)
        {
            fixed (float* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetFloati_v(target, index, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetFloat(this GL glInstance, GetPName target, uint index, ref float data)
        {
            fixed (float* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetFloati_v(target, index, data_ptr);
            }
        }

        // GetDoublei_v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetDouble(this GL glInstance, GetPName target, uint index, Span<double> data)
        {
            fixed (double* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetDoublei_v(target, index, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetDouble(this GL glInstance, GetPName target, uint index, double[] data)
        {
            fixed (double* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.GetDoublei_v(target, index, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetDouble(this GL glInstance, GetPName target, uint index, ref double data)
        {
            fixed (double* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetDoublei_v(target, index, data_ptr);
            }
        }

        // DrawElementsInstancedBaseInstance overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void DrawElementsInstancedBaseInstance(this GL glInstance, PrimitiveType mode, int count, PrimitiveType type, nint offset, int instancecount, uint baseinstance)
        {
            void* indices = (void*)offset;
            glInstance.DrawElementsInstancedBaseInstance(mode, count, type, indices, instancecount, baseinstance);
        }

        // DrawElementsInstancedBaseVertexBaseInstance overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.PointerToOffsetOverloader
        public static unsafe void DrawElementsInstancedBaseVertexBaseInstance(this GL glInstance, PrimitiveType mode, int count, DrawElementsType type, nint offset, int instancecount, int basevertex, uint baseinstance)
        {
            void* indices = (void*)offset;
            glInstance.DrawElementsInstancedBaseVertexBaseInstance(mode, count, type, indices, instancecount, basevertex, baseinstance);
        }

        // GetInternalformativ overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInternalformati(this GL glInstance, TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, Span<int> parameters)
        {
            var count = (int)(parameters.Length);
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetInternalformativ(target, internalformat, pname, count, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInternalformati(this GL glInstance, TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int[] parameters)
        {
            var count = (int)(parameters.Length);
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetInternalformativ(target, internalformat, pname, count, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetInternalformati(this GL glInstance, TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetInternalformativ(target, internalformat, pname, count, parameters_ptr);
            }
        }

        // GetActiveAtomicCounterBufferiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveAtomicCounterBufferi(this GL glInstance, ProgramHandle program, uint bufferIndex, AtomicCounterBufferPName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetActiveAtomicCounterBufferiv(program, bufferIndex, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetActiveAtomicCounterBufferi(this GL glInstance, ProgramHandle program, uint bufferIndex, AtomicCounterBufferPName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetActiveAtomicCounterBufferiv(program, bufferIndex, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetActiveAtomicCounterBufferi(this GL glInstance, ProgramHandle program, uint bufferIndex, AtomicCounterBufferPName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetActiveAtomicCounterBufferiv(program, bufferIndex, pname, parameters_ptr);
            }
        }

        // BindImageTexture overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void BindImageTexture(this GL glInstance, uint unit, TextureHandle texture, int level, bool layered, int layer, BufferAccessARB access, InternalFormat format)
        {
            var layered_byte = (byte)(layered ? 1 : 0);
            glInstance.BindImageTexture(unit, texture, level, layered_byte, layer, access, format);
        }

        // ClearBufferData overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ClearBufferData(this GL glInstance, BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.ClearBufferData(target, internalformat, format, type, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearBufferData<T1>(this GL glInstance, BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.ClearBufferData(target, internalformat, format, type, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearBufferData<T1>(this GL glInstance, BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, T1[] data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.ClearBufferData(target, internalformat, format, type, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClearBufferData<T1>(this GL glInstance, BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.ClearBufferData(target, internalformat, format, type, data_ptr);
            }
        }

        // ClearBufferSubData overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ClearBufferSubData(this GL glInstance, BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.ClearBufferSubData(target, internalformat, offset, size, format, type, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearBufferSubData<T1>(this GL glInstance, BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.ClearBufferSubData(target, internalformat, offset, size, format, type, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearBufferSubData<T1>(this GL glInstance, BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, T1[] data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.ClearBufferSubData(target, internalformat, offset, size, format, type, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClearBufferSubData<T1>(this GL glInstance, BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.ClearBufferSubData(target, internalformat, offset, size, format, type, data_ptr);
            }
        }

        // GetFramebufferParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetFramebufferParameteri(this GL glInstance, FramebufferTarget target, FramebufferAttachmentParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetFramebufferParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetFramebufferParameteri(this GL glInstance, FramebufferTarget target, FramebufferAttachmentParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetFramebufferParameteriv(target, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetFramebufferParameteri(this GL glInstance, FramebufferTarget target, FramebufferAttachmentParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetFramebufferParameteriv(target, pname, parameters_ptr);
            }
        }

        // GetInternalformati64v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInternalformati64(this GL glInstance, TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, Span<long> parameters)
        {
            var count = (int)(parameters.Length);
            fixed (long* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetInternalformati64v(target, internalformat, pname, count, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetInternalformati64(this GL glInstance, TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, long[] parameters)
        {
            var count = (int)(parameters.Length);
            fixed (long* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetInternalformati64v(target, internalformat, pname, count, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetInternalformati64(this GL glInstance, TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, ref long parameters)
        {
            fixed (long* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetInternalformati64v(target, internalformat, pname, count, parameters_ptr);
            }
        }

        // InvalidateFramebuffer overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void InvalidateFramebuffer(this GL glInstance, FramebufferTarget target, ReadOnlySpan<InvalidateFramebufferAttachment> attachments)
        {
            var numAttachments = (int)(attachments.Length);
            fixed (InvalidateFramebufferAttachment* attachments_ptr = attachments) // SpanOrArrayLayer
            {
                glInstance.InvalidateFramebuffer(target, numAttachments, attachments_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void InvalidateFramebuffer(this GL glInstance, FramebufferTarget target, InvalidateFramebufferAttachment[] attachments)
        {
            var numAttachments = (int)(attachments.Length);
            fixed (InvalidateFramebufferAttachment* attachments_ptr = attachments) // SpanOrArrayLayer
            {
                glInstance.InvalidateFramebuffer(target, numAttachments, attachments_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void InvalidateFramebuffer(this GL glInstance, FramebufferTarget target, int numAttachments, in InvalidateFramebufferAttachment attachments)
        {
            fixed (InvalidateFramebufferAttachment* attachments_ptr = &attachments) // RefInsteadOfPointerLayer
            {
                glInstance.InvalidateFramebuffer(target, numAttachments, attachments_ptr);
            }
        }

        // InvalidateSubFramebuffer overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void InvalidateSubFramebuffer(this GL glInstance, FramebufferTarget target, ReadOnlySpan<InvalidateFramebufferAttachment> attachments, int x, int y, int width, int height)
        {
            var numAttachments = (int)(attachments.Length);
            fixed (InvalidateFramebufferAttachment* attachments_ptr = attachments) // SpanOrArrayLayer
            {
                glInstance.InvalidateSubFramebuffer(target, numAttachments, attachments_ptr, x, y, width, height);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void InvalidateSubFramebuffer(this GL glInstance, FramebufferTarget target, InvalidateFramebufferAttachment[] attachments, int x, int y, int width, int height)
        {
            var numAttachments = (int)(attachments.Length);
            fixed (InvalidateFramebufferAttachment* attachments_ptr = attachments) // SpanOrArrayLayer
            {
                glInstance.InvalidateSubFramebuffer(target, numAttachments, attachments_ptr, x, y, width, height);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void InvalidateSubFramebuffer(this GL glInstance, FramebufferTarget target, int numAttachments, in InvalidateFramebufferAttachment attachments, int x, int y, int width, int height)
        {
            fixed (InvalidateFramebufferAttachment* attachments_ptr = &attachments) // RefInsteadOfPointerLayer
            {
                glInstance.InvalidateSubFramebuffer(target, numAttachments, attachments_ptr, x, y, width, height);
            }
        }

        // MultiDrawArraysIndirect overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void MultiDrawArraysIndirect(this GL glInstance, PrimitiveType mode, IntPtr indirect, int drawcount, int stride)
        {
            var indirect_vptr = (void*)indirect;
            glInstance.MultiDrawArraysIndirect(mode, indirect_vptr, drawcount, stride);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiDrawArraysIndirect<T1>(this GL glInstance, PrimitiveType mode, ReadOnlySpan<T1> indirect, int drawcount, int stride)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = indirect) // SpanOrArrayLayer
            {
                glInstance.MultiDrawArraysIndirect(mode, indirect_ptr, drawcount, stride);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiDrawArraysIndirect<T1>(this GL glInstance, PrimitiveType mode, T1[] indirect, int drawcount, int stride)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = indirect) // SpanOrArrayLayer
            {
                glInstance.MultiDrawArraysIndirect(mode, indirect_ptr, drawcount, stride);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiDrawArraysIndirect<T1>(this GL glInstance, PrimitiveType mode, in T1 indirect, int drawcount, int stride)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = &indirect) // RefInsteadOfPointerLayer
            {
                glInstance.MultiDrawArraysIndirect(mode, indirect_ptr, drawcount, stride);
            }
        }

        // MultiDrawElementsIndirect overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void MultiDrawElementsIndirect(this GL glInstance, PrimitiveType mode, DrawElementsType type, IntPtr indirect, int drawcount, int stride)
        {
            var indirect_vptr = (void*)indirect;
            glInstance.MultiDrawElementsIndirect(mode, type, indirect_vptr, drawcount, stride);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiDrawElementsIndirect<T1>(this GL glInstance, PrimitiveType mode, DrawElementsType type, ReadOnlySpan<T1> indirect, int drawcount, int stride)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = indirect) // SpanOrArrayLayer
            {
                glInstance.MultiDrawElementsIndirect(mode, type, indirect_ptr, drawcount, stride);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void MultiDrawElementsIndirect<T1>(this GL glInstance, PrimitiveType mode, DrawElementsType type, T1[] indirect, int drawcount, int stride)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = indirect) // SpanOrArrayLayer
            {
                glInstance.MultiDrawElementsIndirect(mode, type, indirect_ptr, drawcount, stride);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiDrawElementsIndirect<T1>(this GL glInstance, PrimitiveType mode, DrawElementsType type, in T1 indirect, int drawcount, int stride)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = &indirect) // RefInsteadOfPointerLayer
            {
                glInstance.MultiDrawElementsIndirect(mode, type, indirect_ptr, drawcount, stride);
            }
        }

        // GetProgramInterfaceiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramInterfacei(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, ProgramInterfacePName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramInterfaceiv(program, programInterface, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramInterfacei(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, ProgramInterfacePName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetProgramInterfaceiv(program, programInterface, pname, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramInterfacei(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, ProgramInterfacePName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetProgramInterfaceiv(program, programInterface, pname, parameters_ptr);
            }
        }

        // GetProgramResourceIndex overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe uint GetProgramResourceIndex(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, string name)
        {
            uint returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = glInstance.GetProgramResourceIndex(program, programInterface, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }

        // GetProgramResourceName overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetProgramResourceName(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, Span<int> length)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramResourceName(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, Span<int> length, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetProgramResourceName(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, int[] length)
        {
            string name;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramResourceName(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, int[] length, out string name)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetProgramResourceName(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, ref int length)
        {
            string name;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramResourceName(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, ref int length, out string name)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }

        // GetProgramResourceiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramResourcei(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, ReadOnlySpan<ProgramResourceProperty> props, Span<int> length, Span<int> parameters)
        {
            var propCount = (int)(props.Length);
            fixed (ProgramResourceProperty* props_ptr = props) // SpanOrArrayLayer
            {
                fixed (int* length_ptr = length) // SpanOrArrayLayer
                {
                    var count = (int)(parameters.Length);
                    fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
                    {
                        glInstance.GetProgramResourceiv(program, programInterface, index, propCount, props_ptr, count, length_ptr, parameters_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetProgramResourcei(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, ProgramResourceProperty[] props, int[] length, int[] parameters)
        {
            var propCount = (int)(props.Length);
            fixed (ProgramResourceProperty* props_ptr = props) // SpanOrArrayLayer
            {
                fixed (int* length_ptr = length) // SpanOrArrayLayer
                {
                    var count = (int)(parameters.Length);
                    fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
                    {
                        glInstance.GetProgramResourceiv(program, programInterface, index, propCount, props_ptr, count, length_ptr, parameters_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetProgramResourcei(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, uint index, int propCount, in ProgramResourceProperty props, int count, ref int length, ref int parameters)
        {
            fixed (ProgramResourceProperty* props_ptr = &props) // RefInsteadOfPointerLayer
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetProgramResourceiv(program, programInterface, index, propCount, props_ptr, count, length_ptr, parameters_ptr);
            }
        }

        // GetProgramResourceLocation overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe int GetProgramResourceLocation(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, string name)
        {
            int returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = glInstance.GetProgramResourceLocation(program, programInterface, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }

        // GetProgramResourceLocationIndex overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe int GetProgramResourceLocationIndex(this GL glInstance, ProgramHandle program, ProgramInterface programInterface, string name)
        {
            int returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = glInstance.GetProgramResourceLocationIndex(program, programInterface, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }

        // TexStorage2DMultisample overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void TexStorage2DMultisample(this GL glInstance, TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations)
        {
            var fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
            glInstance.TexStorage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations_byte);
        }

        // TexStorage3DMultisample overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void TexStorage3DMultisample(this GL glInstance, TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
        {
            var fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
            glInstance.TexStorage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations_byte);
        }

        // VertexAttribFormat overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void VertexAttribFormat(this GL glInstance, uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset)
        {
            var normalized_byte = (byte)(normalized ? 1 : 0);
            glInstance.VertexAttribFormat(attribindex, size, type, normalized_byte, relativeoffset);
        }

        // DebugMessageControl overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DebugMessageControl(this GL glInstance, DebugSource source, DebugType type, DebugSeverity severity, ReadOnlySpan<uint> ids, bool enabled)
        {
            var count = (int)(ids.Length);
            fixed (uint* ids_ptr = ids) // SpanOrArrayLayer
            {
                var enabled_byte = (byte)(enabled ? 1 : 0);
                glInstance.DebugMessageControl(source, type, severity, count, ids_ptr, enabled_byte);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void DebugMessageControl(this GL glInstance, DebugSource source, DebugType type, DebugSeverity severity, uint[] ids, bool enabled)
        {
            var count = (int)(ids.Length);
            fixed (uint* ids_ptr = ids) // SpanOrArrayLayer
            {
                var enabled_byte = (byte)(enabled ? 1 : 0);
                glInstance.DebugMessageControl(source, type, severity, count, ids_ptr, enabled_byte);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DebugMessageControl(this GL glInstance, DebugSource source, DebugType type, DebugSeverity severity, int count, in uint ids, bool enabled)
        {
            fixed (uint* ids_ptr = &ids) // RefInsteadOfPointerLayer
            {
                var enabled_byte = (byte)(enabled ? 1 : 0);
                glInstance.DebugMessageControl(source, type, severity, count, ids_ptr, enabled_byte);
            }
        }

        // DebugMessageInsert overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe void DebugMessageInsert(this GL glInstance, DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, string buf)
        {
            byte* buf_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(buf);
            glInstance.DebugMessageInsert(source, type, id, severity, length, buf_ptr);
            Marshal.FreeCoTaskMem((IntPtr)buf_ptr);
        }

        // DebugMessageCallback overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void DebugMessageCallback(this GL glInstance, GLDebugProc callback, IntPtr userParam)
        {
            var userParam_vptr = (void*)userParam;
            IntPtr callback_ptr = Marshal.GetFunctionPointerForDelegate(callback);
            glInstance.DebugMessageCallback(callback_ptr, userParam_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void DebugMessageCallback<T1>(this GL glInstance, GLDebugProc callback, in T1 userParam)
            where T1 : unmanaged
        {
            fixed (void* userParam_ptr = &userParam) // RefInsteadOfPointerLayer
            {
                IntPtr callback_ptr = Marshal.GetFunctionPointerForDelegate(callback);
                glInstance.DebugMessageCallback(callback_ptr, userParam_ptr);
            }
        }

        // GetDebugMessageLog overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe uint GetDebugMessageLog(this GL glInstance, uint count, int bufSize, Span<DebugSource> sources, Span<DebugType> types, Span<uint> ids, Span<DebugSeverity> severities, Span<int> lengths, out string messageLog)
        {
            uint returnValue;
            fixed (DebugSource* sources_ptr = sources) // SpanOrArrayLayer
            {
                fixed (DebugType* types_ptr = types) // SpanOrArrayLayer
                {
                    fixed (uint* ids_ptr = ids) // SpanOrArrayLayer
                    {
                        fixed (DebugSeverity* severities_ptr = severities) // SpanOrArrayLayer
                        {
                            fixed (int* lengths_ptr = lengths) // SpanOrArrayLayer
                            {
                                var messageLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                                returnValue = glInstance.GetDebugMessageLog(count, bufSize, sources_ptr, types_ptr, ids_ptr, severities_ptr, lengths_ptr, messageLog_ptr);
                                messageLog = Marshal.PtrToStringUTF8((IntPtr)messageLog_ptr)!;
                                Marshal.FreeCoTaskMem((IntPtr)messageLog_ptr);
                            }
                        }
                    }
                }
            }
            return returnValue;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe uint GetDebugMessageLog(this GL glInstance, uint count, int bufSize, DebugSource[] sources, DebugType[] types, uint[] ids, DebugSeverity[] severities, int[] lengths, out string messageLog)
        {
            uint returnValue;
            fixed (DebugSource* sources_ptr = sources) // SpanOrArrayLayer
            {
                fixed (DebugType* types_ptr = types) // SpanOrArrayLayer
                {
                    fixed (uint* ids_ptr = ids) // SpanOrArrayLayer
                    {
                        fixed (DebugSeverity* severities_ptr = severities) // SpanOrArrayLayer
                        {
                            fixed (int* lengths_ptr = lengths) // SpanOrArrayLayer
                            {
                                var messageLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                                returnValue = glInstance.GetDebugMessageLog(count, bufSize, sources_ptr, types_ptr, ids_ptr, severities_ptr, lengths_ptr, messageLog_ptr);
                                messageLog = Marshal.PtrToStringUTF8((IntPtr)messageLog_ptr)!;
                                Marshal.FreeCoTaskMem((IntPtr)messageLog_ptr);
                            }
                        }
                    }
                }
            }
            return returnValue;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe uint GetDebugMessageLog(this GL glInstance, uint count, int bufSize, ref DebugSource sources, ref DebugType types, ref uint ids, ref DebugSeverity severities, ref int lengths, out string messageLog)
        {
            uint returnValue;
            fixed (DebugSource* sources_ptr = &sources) // RefInsteadOfPointerLayer
            fixed (DebugType* types_ptr = &types) // RefInsteadOfPointerLayer
            fixed (uint* ids_ptr = &ids) // RefInsteadOfPointerLayer
            fixed (DebugSeverity* severities_ptr = &severities) // RefInsteadOfPointerLayer
            fixed (int* lengths_ptr = &lengths) // RefInsteadOfPointerLayer
            {
                var messageLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                returnValue = glInstance.GetDebugMessageLog(count, bufSize, sources_ptr, types_ptr, ids_ptr, severities_ptr, lengths_ptr, messageLog_ptr);
                messageLog = Marshal.PtrToStringUTF8((IntPtr)messageLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)messageLog_ptr);
            }
            return returnValue;
        }

        // PushDebugGroup overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe void PushDebugGroup(this GL glInstance, DebugSource source, uint id, int length, string message)
        {
            byte* message_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(message);
            glInstance.PushDebugGroup(source, id, length, message_ptr);
            Marshal.FreeCoTaskMem((IntPtr)message_ptr);
        }

        // ObjectLabel overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.Transformer
        public static unsafe void ObjectLabel(this GL glInstance, ObjectIdentifier identifier, uint name, int length, string label)
        {
            byte* label_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(label);
            glInstance.ObjectLabel(identifier, name, length, label_ptr);
            Marshal.FreeCoTaskMem((IntPtr)label_ptr);
        }

        // GetObjectLabel overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetObjectLabel(this GL glInstance, ObjectIdentifier identifier, uint name, int bufSize, Span<int> length)
        {
            string label;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetObjectLabel(identifier, name, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            return label;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetObjectLabel(this GL glInstance, ObjectIdentifier identifier, uint name, int bufSize, Span<int> length, out string label)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetObjectLabel(identifier, name, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetObjectLabel(this GL glInstance, ObjectIdentifier identifier, uint name, int bufSize, int[] length)
        {
            string label;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetObjectLabel(identifier, name, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            return label;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetObjectLabel(this GL glInstance, ObjectIdentifier identifier, uint name, int bufSize, int[] length, out string label)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetObjectLabel(identifier, name, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetObjectLabel(this GL glInstance, ObjectIdentifier identifier, uint name, int bufSize, ref int length)
        {
            string label;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetObjectLabel(identifier, name, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            return label;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetObjectLabel(this GL glInstance, ObjectIdentifier identifier, uint name, int bufSize, ref int length, out string label)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetObjectLabel(identifier, name, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
        }

        // ObjectPtrLabel overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ObjectPtrLabel(this GL glInstance, IntPtr ptr, int length, string label)
        {
            byte* label_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(label);
            var ptr_vptr = (void*)ptr;
            glInstance.ObjectPtrLabel(ptr_vptr, length, label_ptr);
            Marshal.FreeCoTaskMem((IntPtr)label_ptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ObjectPtrLabel<T1>(this GL glInstance, in T1 ptr, int length, string label)
            where T1 : unmanaged
        {
            fixed (void* ptr_ptr = &ptr) // RefInsteadOfPointerLayer
            {
                byte* label_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(label);
                glInstance.ObjectPtrLabel(ptr_ptr, length, label_ptr);
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
        }

        // GetObjectPtrLabel overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetObjectPtrLabel(this GL glInstance, IntPtr ptr, int bufSize, Span<int> length)
        {
            string label;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                var ptr_vptr = (void*)ptr;
                glInstance.GetObjectPtrLabel(ptr_vptr, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            return label;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetObjectPtrLabel(this GL glInstance, IntPtr ptr, int bufSize, Span<int> length, out string label)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                var ptr_vptr = (void*)ptr;
                glInstance.GetObjectPtrLabel(ptr_vptr, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetObjectPtrLabel(this GL glInstance, IntPtr ptr, int bufSize, int[] length)
        {
            string label;
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                var ptr_vptr = (void*)ptr;
                glInstance.GetObjectPtrLabel(ptr_vptr, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            return label;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetObjectPtrLabel(this GL glInstance, IntPtr ptr, int bufSize, int[] length, out string label)
        {
            fixed (int* length_ptr = length) // SpanOrArrayLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                var ptr_vptr = (void*)ptr;
                glInstance.GetObjectPtrLabel(ptr_vptr, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetObjectPtrLabel(this GL glInstance, IntPtr ptr, int bufSize, ref int length)
        {
            string label;
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                var ptr_vptr = (void*)ptr;
                glInstance.GetObjectPtrLabel(ptr_vptr, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            return label;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetObjectPtrLabel(this GL glInstance, IntPtr ptr, int bufSize, ref int length, out string label)
        {
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                var ptr_vptr = (void*)ptr;
                glInstance.GetObjectPtrLabel(ptr_vptr, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetObjectPtrLabel<T1>(this GL glInstance, in T1 ptr, int bufSize, Span<int> length)
            where T1 : unmanaged
        {
            string label;
            fixed (void* ptr_ptr = &ptr) // RefInsteadOfPointerLayer
            {
                fixed (int* length_ptr = length) // SpanOrArrayLayer
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    glInstance.GetObjectPtrLabel(ptr_ptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
            return label;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetObjectPtrLabel<T1>(this GL glInstance, in T1 ptr, int bufSize, Span<int> length, out string label)
            where T1 : unmanaged
        {
            fixed (void* ptr_ptr = &ptr) // RefInsteadOfPointerLayer
            {
                fixed (int* length_ptr = length) // SpanOrArrayLayer
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    glInstance.GetObjectPtrLabel(ptr_ptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetObjectPtrLabel<T1>(this GL glInstance, in T1 ptr, int bufSize, int[] length)
            where T1 : unmanaged
        {
            string label;
            fixed (void* ptr_ptr = &ptr) // RefInsteadOfPointerLayer
            {
                fixed (int* length_ptr = length) // SpanOrArrayLayer
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    glInstance.GetObjectPtrLabel(ptr_ptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
            return label;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetObjectPtrLabel<T1>(this GL glInstance, in T1 ptr, int bufSize, int[] length, out string label)
            where T1 : unmanaged
        {
            fixed (void* ptr_ptr = &ptr) // RefInsteadOfPointerLayer
            {
                fixed (int* length_ptr = length) // SpanOrArrayLayer
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    glInstance.GetObjectPtrLabel(ptr_ptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe string GetObjectPtrLabel<T1>(this GL glInstance, in T1 ptr, int bufSize, ref int length)
            where T1 : unmanaged
        {
            string label;
            fixed (void* ptr_ptr = &ptr) // RefInsteadOfPointerLayer
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetObjectPtrLabel(ptr_ptr, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            return label;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetObjectPtrLabel<T1>(this GL glInstance, in T1 ptr, int bufSize, ref int length, out string label)
            where T1 : unmanaged
        {
            fixed (void* ptr_ptr = &ptr) // RefInsteadOfPointerLayer
            fixed (int* length_ptr = &length) // RefInsteadOfPointerLayer
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                glInstance.GetObjectPtrLabel(ptr_ptr, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
        }

        // BufferStorage overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void BufferStorage(this GL glInstance, BufferStorageTarget target, nint size, IntPtr data, BufferStorageMask flags)
        {
            var data_vptr = (void*)data;
            glInstance.BufferStorage(target, size, data_vptr, flags);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BufferStorage<T1>(this GL glInstance, BufferStorageTarget target, ReadOnlySpan<T1> data, BufferStorageMask flags)
            where T1 : unmanaged
        {
            var size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.BufferStorage(target, size, data_ptr, flags);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BufferStorage<T1>(this GL glInstance, BufferStorageTarget target, T1[] data, BufferStorageMask flags)
            where T1 : unmanaged
        {
            var size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.BufferStorage(target, size, data_ptr, flags);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void BufferStorage<T1>(this GL glInstance, BufferStorageTarget target, nint size, in T1 data, BufferStorageMask flags)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.BufferStorage(target, size, data_ptr, flags);
            }
        }

        // ClearTexImage overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ClearTexImage(this GL glInstance, TextureHandle texture, int level, PixelFormat format, PixelType type, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.ClearTexImage(texture, level, format, type, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearTexImage<T1>(this GL glInstance, TextureHandle texture, int level, PixelFormat format, PixelType type, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.ClearTexImage(texture, level, format, type, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearTexImage<T1>(this GL glInstance, TextureHandle texture, int level, PixelFormat format, PixelType type, T1[] data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.ClearTexImage(texture, level, format, type, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClearTexImage<T1>(this GL glInstance, TextureHandle texture, int level, PixelFormat format, PixelType type, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.ClearTexImage(texture, level, format, type, data_ptr);
            }
        }

        // ClearTexSubImage overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ClearTexSubImage(this GL glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.ClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearTexSubImage<T1>(this GL glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.ClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ClearTexSubImage<T1>(this GL glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, T1[] data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.ClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClearTexSubImage<T1>(this GL glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.ClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data_ptr);
            }
        }

        // BindBuffersBase overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BindBuffersBase(this GL glInstance, BufferTargetARB target, uint first, ReadOnlySpan<BufferHandle> buffers)
        {
            var count = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                glInstance.BindBuffersBase(target, first, count, buffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BindBuffersBase(this GL glInstance, BufferTargetARB target, uint first, BufferHandle[] buffers)
        {
            var count = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                glInstance.BindBuffersBase(target, first, count, buffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void BindBuffersBase(this GL glInstance, BufferTargetARB target, uint first, int count, in BufferHandle buffers)
        {
            fixed (BufferHandle* buffers_ptr = &buffers) // RefInsteadOfPointerLayer
            {
                glInstance.BindBuffersBase(target, first, count, buffers_ptr);
            }
        }

        // BindBuffersRange overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BindBuffersRange(this GL glInstance, BufferTargetARB target, uint first, int count, ReadOnlySpan<BufferHandle> buffers, ReadOnlySpan<IntPtr> offsets, ReadOnlySpan<nint> sizes)
        {
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                fixed (IntPtr* offsets_ptr = offsets) // SpanOrArrayLayer
                {
                    fixed (nint* sizes_ptr = sizes) // SpanOrArrayLayer
                    {
                        glInstance.BindBuffersRange(target, first, count, buffers_ptr, offsets_ptr, sizes_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BindBuffersRange(this GL glInstance, BufferTargetARB target, uint first, int count, BufferHandle[] buffers, IntPtr[] offsets, nint[] sizes)
        {
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                fixed (IntPtr* offsets_ptr = offsets) // SpanOrArrayLayer
                {
                    fixed (nint* sizes_ptr = sizes) // SpanOrArrayLayer
                    {
                        glInstance.BindBuffersRange(target, first, count, buffers_ptr, offsets_ptr, sizes_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void BindBuffersRange(this GL glInstance, BufferTargetARB target, uint first, int count, in BufferHandle buffers, in IntPtr offsets, in nint sizes)
        {
            fixed (BufferHandle* buffers_ptr = &buffers) // RefInsteadOfPointerLayer
            fixed (IntPtr* offsets_ptr = &offsets) // RefInsteadOfPointerLayer
            fixed (nint* sizes_ptr = &sizes) // RefInsteadOfPointerLayer
            {
                glInstance.BindBuffersRange(target, first, count, buffers_ptr, offsets_ptr, sizes_ptr);
            }
        }

        // BindTextures overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BindTextures(this GL glInstance, uint first, ReadOnlySpan<TextureHandle> textures)
        {
            var count = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures) // SpanOrArrayLayer
            {
                glInstance.BindTextures(first, count, textures_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BindTextures(this GL glInstance, uint first, TextureHandle[] textures)
        {
            var count = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures) // SpanOrArrayLayer
            {
                glInstance.BindTextures(first, count, textures_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void BindTextures(this GL glInstance, uint first, int count, in TextureHandle textures)
        {
            fixed (TextureHandle* textures_ptr = &textures) // RefInsteadOfPointerLayer
            {
                glInstance.BindTextures(first, count, textures_ptr);
            }
        }

        // BindSamplers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BindSamplers(this GL glInstance, uint first, ReadOnlySpan<SamplerHandle> samplers)
        {
            var count = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers) // SpanOrArrayLayer
            {
                glInstance.BindSamplers(first, count, samplers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BindSamplers(this GL glInstance, uint first, SamplerHandle[] samplers)
        {
            var count = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers) // SpanOrArrayLayer
            {
                glInstance.BindSamplers(first, count, samplers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void BindSamplers(this GL glInstance, uint first, int count, in SamplerHandle samplers)
        {
            fixed (SamplerHandle* samplers_ptr = &samplers) // RefInsteadOfPointerLayer
            {
                glInstance.BindSamplers(first, count, samplers_ptr);
            }
        }

        // BindImageTextures overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BindImageTextures(this GL glInstance, uint first, ReadOnlySpan<TextureHandle> textures)
        {
            var count = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures) // SpanOrArrayLayer
            {
                glInstance.BindImageTextures(first, count, textures_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BindImageTextures(this GL glInstance, uint first, TextureHandle[] textures)
        {
            var count = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures) // SpanOrArrayLayer
            {
                glInstance.BindImageTextures(first, count, textures_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void BindImageTextures(this GL glInstance, uint first, int count, in TextureHandle textures)
        {
            fixed (TextureHandle* textures_ptr = &textures) // RefInsteadOfPointerLayer
            {
                glInstance.BindImageTextures(first, count, textures_ptr);
            }
        }

        // BindVertexBuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BindVertexBuffers(this GL glInstance, uint first, int count, ReadOnlySpan<BufferHandle> buffers, ReadOnlySpan<IntPtr> offsets, ReadOnlySpan<int> strides)
        {
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                fixed (IntPtr* offsets_ptr = offsets) // SpanOrArrayLayer
                {
                    fixed (int* strides_ptr = strides) // SpanOrArrayLayer
                    {
                        glInstance.BindVertexBuffers(first, count, buffers_ptr, offsets_ptr, strides_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void BindVertexBuffers(this GL glInstance, uint first, int count, BufferHandle[] buffers, IntPtr[] offsets, int[] strides)
        {
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                fixed (IntPtr* offsets_ptr = offsets) // SpanOrArrayLayer
                {
                    fixed (int* strides_ptr = strides) // SpanOrArrayLayer
                    {
                        glInstance.BindVertexBuffers(first, count, buffers_ptr, offsets_ptr, strides_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void BindVertexBuffers(this GL glInstance, uint first, int count, in BufferHandle buffers, in IntPtr offsets, in int strides)
        {
            fixed (BufferHandle* buffers_ptr = &buffers) // RefInsteadOfPointerLayer
            fixed (IntPtr* offsets_ptr = &offsets) // RefInsteadOfPointerLayer
            fixed (int* strides_ptr = &strides) // RefInsteadOfPointerLayer
            {
                glInstance.BindVertexBuffers(first, count, buffers_ptr, offsets_ptr, strides_ptr);
            }
        }

        // CreateTransformFeedbacks overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe TransformFeedbackHandle CreateTransformFeedback(this GL glInstance)
        {
            TransformFeedbackHandle ids;
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TransformFeedbackHandle* ids_handle = (TransformFeedbackHandle*)Unsafe.AsPointer(ref ids);
            glInstance.CreateTransformFeedbacks(n, ids_handle);
            return ids;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void CreateTransformFeedback(this GL glInstance, out TransformFeedbackHandle ids)
        {
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TransformFeedbackHandle* ids_handle = (TransformFeedbackHandle*)Unsafe.AsPointer(ref ids);
            glInstance.CreateTransformFeedbacks(n, ids_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateTransformFeedbacks(this GL glInstance, Span<TransformFeedbackHandle> ids)
        {
            var n = (int)(ids.Length);
            fixed (TransformFeedbackHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.CreateTransformFeedbacks(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateTransformFeedbacks(this GL glInstance, TransformFeedbackHandle[] ids)
        {
            var n = (int)(ids.Length);
            fixed (TransformFeedbackHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.CreateTransformFeedbacks(n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CreateTransformFeedbacks(this GL glInstance, int n, ref TransformFeedbackHandle ids)
        {
            fixed (TransformFeedbackHandle* ids_ptr = &ids) // RefInsteadOfPointerLayer
            {
                glInstance.CreateTransformFeedbacks(n, ids_ptr);
            }
        }

        // GetTransformFeedbackiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTransformFeedbacki(this GL glInstance, TransformFeedbackHandle xfb, TransformFeedbackPName pname, ref int param)
        {
            fixed (int* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.GetTransformFeedbackiv(xfb, pname, param_ptr);
            }
        }

        // GetTransformFeedbacki_v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTransformFeedback(this GL glInstance, TransformFeedbackHandle xfb, TransformFeedbackPName pname, uint index, ref int param)
        {
            fixed (int* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.GetTransformFeedbacki_v(xfb, pname, index, param_ptr);
            }
        }

        // GetTransformFeedbacki64_v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTransformFeedbacki64_(this GL glInstance, TransformFeedbackHandle xfb, TransformFeedbackPName pname, uint index, ref long param)
        {
            fixed (long* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.GetTransformFeedbacki64_v(xfb, pname, index, param_ptr);
            }
        }

        // CreateBuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe BufferHandle CreateBuffer(this GL glInstance)
        {
            BufferHandle buffers;
            int n = 1;
            Unsafe.SkipInit(out buffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            BufferHandle* buffers_handle = (BufferHandle*)Unsafe.AsPointer(ref buffers);
            glInstance.CreateBuffers(n, buffers_handle);
            return buffers;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void CreateBuffer(this GL glInstance, out BufferHandle buffers)
        {
            int n = 1;
            Unsafe.SkipInit(out buffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            BufferHandle* buffers_handle = (BufferHandle*)Unsafe.AsPointer(ref buffers);
            glInstance.CreateBuffers(n, buffers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateBuffers(this GL glInstance, Span<BufferHandle> buffers)
        {
            var n = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                glInstance.CreateBuffers(n, buffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateBuffers(this GL glInstance, BufferHandle[] buffers)
        {
            var n = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers) // SpanOrArrayLayer
            {
                glInstance.CreateBuffers(n, buffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CreateBuffers(this GL glInstance, int n, ref BufferHandle buffers)
        {
            fixed (BufferHandle* buffers_ptr = &buffers) // RefInsteadOfPointerLayer
            {
                glInstance.CreateBuffers(n, buffers_ptr);
            }
        }

        // NamedBufferStorage overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void NamedBufferStorage(this GL glInstance, BufferHandle buffer, nint size, IntPtr data, BufferStorageMask flags)
        {
            var data_vptr = (void*)data;
            glInstance.NamedBufferStorage(buffer, size, data_vptr, flags);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void NamedBufferStorage<T1>(this GL glInstance, BufferHandle buffer, ReadOnlySpan<T1> data, BufferStorageMask flags)
            where T1 : unmanaged
        {
            var size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.NamedBufferStorage(buffer, size, data_ptr, flags);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void NamedBufferStorage<T1>(this GL glInstance, BufferHandle buffer, T1[] data, BufferStorageMask flags)
            where T1 : unmanaged
        {
            var size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.NamedBufferStorage(buffer, size, data_ptr, flags);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void NamedBufferStorage<T1>(this GL glInstance, BufferHandle buffer, nint size, in T1 data, BufferStorageMask flags)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.NamedBufferStorage(buffer, size, data_ptr, flags);
            }
        }

        // NamedBufferData overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void NamedBufferData(this GL glInstance, BufferHandle buffer, nint size, IntPtr data, VertexBufferObjectUsage usage)
        {
            var data_vptr = (void*)data;
            glInstance.NamedBufferData(buffer, size, data_vptr, usage);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void NamedBufferData<T1>(this GL glInstance, BufferHandle buffer, nint size, in T1 data, VertexBufferObjectUsage usage)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.NamedBufferData(buffer, size, data_ptr, usage);
            }
        }

        // NamedBufferSubData overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void NamedBufferSubData(this GL glInstance, BufferHandle buffer, IntPtr offset, nint size, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.NamedBufferSubData(buffer, offset, size, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void NamedBufferSubData<T1>(this GL glInstance, BufferHandle buffer, IntPtr offset, nint size, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.NamedBufferSubData(buffer, offset, size, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void NamedBufferSubData<T1>(this GL glInstance, BufferHandle buffer, IntPtr offset, nint size, T1[] data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.NamedBufferSubData(buffer, offset, size, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void NamedBufferSubData<T1>(this GL glInstance, BufferHandle buffer, IntPtr offset, nint size, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.NamedBufferSubData(buffer, offset, size, data_ptr);
            }
        }

        // ClearNamedBufferData overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ClearNamedBufferData(this GL glInstance, BufferHandle buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.ClearNamedBufferData(buffer, internalformat, format, type, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClearNamedBufferData<T1>(this GL glInstance, BufferHandle buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.ClearNamedBufferData(buffer, internalformat, format, type, data_ptr);
            }
        }

        // ClearNamedBufferSubData overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ClearNamedBufferSubData(this GL glInstance, BufferHandle buffer, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.ClearNamedBufferSubData(buffer, internalformat, offset, size, format, type, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClearNamedBufferSubData<T1>(this GL glInstance, BufferHandle buffer, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.ClearNamedBufferSubData(buffer, internalformat, offset, size, format, type, data_ptr);
            }
        }

        // GetNamedBufferParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetNamedBufferParameteri(this GL glInstance, BufferHandle buffer, BufferPNameARB pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetNamedBufferParameteriv(buffer, pname, parameters_ptr);
            }
        }

        // GetNamedBufferParameteri64v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetNamedBufferParameteri64(this GL glInstance, BufferHandle buffer, BufferPNameARB pname, ref long parameters)
        {
            fixed (long* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetNamedBufferParameteri64v(buffer, pname, parameters_ptr);
            }
        }

        // GetNamedBufferPointerv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void GetNamedBufferPointer(this GL glInstance, BufferHandle buffer, BufferPointerNameARB pname, void** parameters) =>
            glInstance.GetNamedBufferPointerv(buffer, pname, parameters);

        // GetNamedBufferSubData overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetNamedBufferSubData(this GL glInstance, BufferHandle buffer, IntPtr offset, nint size, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.GetNamedBufferSubData(buffer, offset, size, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetNamedBufferSubData<T1>(this GL glInstance, BufferHandle buffer, IntPtr offset, nint size, ref T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.GetNamedBufferSubData(buffer, offset, size, data_ptr);
            }
        }

        // CreateFramebuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe FramebufferHandle CreateFramebuffer(this GL glInstance)
        {
            FramebufferHandle framebuffers;
            int n = 1;
            Unsafe.SkipInit(out framebuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            FramebufferHandle* framebuffers_handle = (FramebufferHandle*)Unsafe.AsPointer(ref framebuffers);
            glInstance.CreateFramebuffers(n, framebuffers_handle);
            return framebuffers;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void CreateFramebuffer(this GL glInstance, out FramebufferHandle framebuffers)
        {
            int n = 1;
            Unsafe.SkipInit(out framebuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            FramebufferHandle* framebuffers_handle = (FramebufferHandle*)Unsafe.AsPointer(ref framebuffers);
            glInstance.CreateFramebuffers(n, framebuffers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateFramebuffers(this GL glInstance, Span<FramebufferHandle> framebuffers)
        {
            var n = (int)(framebuffers.Length);
            fixed (FramebufferHandle* framebuffers_ptr = framebuffers) // SpanOrArrayLayer
            {
                glInstance.CreateFramebuffers(n, framebuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateFramebuffers(this GL glInstance, FramebufferHandle[] framebuffers)
        {
            var n = (int)(framebuffers.Length);
            fixed (FramebufferHandle* framebuffers_ptr = framebuffers) // SpanOrArrayLayer
            {
                glInstance.CreateFramebuffers(n, framebuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CreateFramebuffers(this GL glInstance, int n, ref FramebufferHandle framebuffers)
        {
            fixed (FramebufferHandle* framebuffers_ptr = &framebuffers) // RefInsteadOfPointerLayer
            {
                glInstance.CreateFramebuffers(n, framebuffers_ptr);
            }
        }

        // NamedFramebufferDrawBuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void NamedFramebufferDrawBuffers(this GL glInstance, FramebufferHandle framebuffer, int n, in ColorBuffer bufs)
        {
            fixed (ColorBuffer* bufs_ptr = &bufs) // RefInsteadOfPointerLayer
            {
                glInstance.NamedFramebufferDrawBuffers(framebuffer, n, bufs_ptr);
            }
        }

        // InvalidateNamedFramebufferData overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void InvalidateNamedFramebufferData(this GL glInstance, FramebufferHandle framebuffer, int numAttachments, in FramebufferAttachment attachments)
        {
            fixed (FramebufferAttachment* attachments_ptr = &attachments) // RefInsteadOfPointerLayer
            {
                glInstance.InvalidateNamedFramebufferData(framebuffer, numAttachments, attachments_ptr);
            }
        }

        // InvalidateNamedFramebufferSubData overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void InvalidateNamedFramebufferSubData(this GL glInstance, FramebufferHandle framebuffer, int numAttachments, in FramebufferAttachment attachments, int x, int y, int width, int height)
        {
            fixed (FramebufferAttachment* attachments_ptr = &attachments) // RefInsteadOfPointerLayer
            {
                glInstance.InvalidateNamedFramebufferSubData(framebuffer, numAttachments, attachments_ptr, x, y, width, height);
            }
        }

        // ClearNamedFramebufferiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClearNamedFramebufferi(this GL glInstance, FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, in int value)
        {
            fixed (int* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, value_ptr);
            }
        }

        // ClearNamedFramebufferuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClearNamedFramebufferui(this GL glInstance, FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, in uint value)
        {
            fixed (uint* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, value_ptr);
            }
        }

        // ClearNamedFramebufferfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ClearNamedFramebufferf(this GL glInstance, FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, in float value)
        {
            fixed (float* value_ptr = &value) // RefInsteadOfPointerLayer
            {
                glInstance.ClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, value_ptr);
            }
        }

        // ClearNamedFramebufferfi overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void ClearNamedFramebuffer(this GL glInstance, FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, float depth, int stencil) =>
            glInstance.ClearNamedFramebufferfi(framebuffer, buffer, drawbuffer, depth, stencil);

        // GetNamedFramebufferParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetNamedFramebufferParameteri(this GL glInstance, FramebufferHandle framebuffer, GetFramebufferParameter pname, ref int param)
        {
            fixed (int* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.GetNamedFramebufferParameteriv(framebuffer, pname, param_ptr);
            }
        }

        // GetNamedFramebufferAttachmentParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetNamedFramebufferAttachmentParameteri(this GL glInstance, FramebufferHandle framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, parameters_ptr);
            }
        }

        // CreateRenderbuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe RenderbufferHandle CreateRenderbuffer(this GL glInstance)
        {
            RenderbufferHandle renderbuffers;
            int n = 1;
            Unsafe.SkipInit(out renderbuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            RenderbufferHandle* renderbuffers_handle = (RenderbufferHandle*)Unsafe.AsPointer(ref renderbuffers);
            glInstance.CreateRenderbuffers(n, renderbuffers_handle);
            return renderbuffers;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void CreateRenderbuffer(this GL glInstance, out RenderbufferHandle renderbuffers)
        {
            int n = 1;
            Unsafe.SkipInit(out renderbuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            RenderbufferHandle* renderbuffers_handle = (RenderbufferHandle*)Unsafe.AsPointer(ref renderbuffers);
            glInstance.CreateRenderbuffers(n, renderbuffers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateRenderbuffers(this GL glInstance, Span<RenderbufferHandle> renderbuffers)
        {
            var n = (int)(renderbuffers.Length);
            fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers) // SpanOrArrayLayer
            {
                glInstance.CreateRenderbuffers(n, renderbuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateRenderbuffers(this GL glInstance, RenderbufferHandle[] renderbuffers)
        {
            var n = (int)(renderbuffers.Length);
            fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers) // SpanOrArrayLayer
            {
                glInstance.CreateRenderbuffers(n, renderbuffers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CreateRenderbuffers(this GL glInstance, int n, ref RenderbufferHandle renderbuffers)
        {
            fixed (RenderbufferHandle* renderbuffers_ptr = &renderbuffers) // RefInsteadOfPointerLayer
            {
                glInstance.CreateRenderbuffers(n, renderbuffers_ptr);
            }
        }

        // GetNamedRenderbufferParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetNamedRenderbufferParameteri(this GL glInstance, RenderbufferHandle renderbuffer, RenderbufferParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetNamedRenderbufferParameteriv(renderbuffer, pname, parameters_ptr);
            }
        }

        // CreateTextures overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe TextureHandle CreateTexture(this GL glInstance, TextureTarget target)
        {
            TextureHandle textures;
            int n = 1;
            Unsafe.SkipInit(out textures);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TextureHandle* textures_handle = (TextureHandle*)Unsafe.AsPointer(ref textures);
            glInstance.CreateTextures(target, n, textures_handle);
            return textures;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void CreateTexture(this GL glInstance, TextureTarget target, out TextureHandle textures)
        {
            int n = 1;
            Unsafe.SkipInit(out textures);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TextureHandle* textures_handle = (TextureHandle*)Unsafe.AsPointer(ref textures);
            glInstance.CreateTextures(target, n, textures_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateTextures(this GL glInstance, TextureTarget target, Span<TextureHandle> textures)
        {
            var n = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures) // SpanOrArrayLayer
            {
                glInstance.CreateTextures(target, n, textures_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateTextures(this GL glInstance, TextureTarget target, TextureHandle[] textures)
        {
            var n = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures) // SpanOrArrayLayer
            {
                glInstance.CreateTextures(target, n, textures_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CreateTextures(this GL glInstance, TextureTarget target, int n, ref TextureHandle textures)
        {
            fixed (TextureHandle* textures_ptr = &textures) // RefInsteadOfPointerLayer
            {
                glInstance.CreateTextures(target, n, textures_ptr);
            }
        }

        // TextureStorage2DMultisample overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void TextureStorage2DMultisample(this GL glInstance, TextureHandle texture, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations)
        {
            var fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
            glInstance.TextureStorage2DMultisample(texture, samples, internalformat, width, height, fixedsamplelocations_byte);
        }

        // TextureStorage3DMultisample overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void TextureStorage3DMultisample(this GL glInstance, TextureHandle texture, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
        {
            var fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
            glInstance.TextureStorage3DMultisample(texture, samples, internalformat, width, height, depth, fixedsamplelocations_byte);
        }

        // TextureSubImage1D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void TextureSubImage1D(this GL glInstance, TextureHandle texture, int level, int xoffset, int width, PixelFormat format, PixelType type, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.TextureSubImage1D(texture, level, xoffset, width, format, type, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TextureSubImage1D<T1>(this GL glInstance, TextureHandle texture, int level, int xoffset, int width, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.TextureSubImage1D(texture, level, xoffset, width, format, type, pixels_ptr);
            }
        }

        // TextureSubImage2D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void TextureSubImage2D(this GL glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.TextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, type, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TextureSubImage2D<T1>(this GL glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.TextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
            }
        }

        // TextureSubImage3D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void TextureSubImage3D(this GL glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.TextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TextureSubImage3D<T1>(this GL glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.TextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_ptr);
            }
        }

        // CompressedTextureSubImage1D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void CompressedTextureSubImage1D(this GL glInstance, TextureHandle texture, int level, int xoffset, int width, InternalFormat format, int imageSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.CompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CompressedTextureSubImage1D<T1>(this GL glInstance, TextureHandle texture, int level, int xoffset, int width, InternalFormat format, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.CompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, data_ptr);
            }
        }

        // CompressedTextureSubImage2D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void CompressedTextureSubImage2D(this GL glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.CompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CompressedTextureSubImage2D<T1>(this GL glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.CompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, data_ptr);
            }
        }

        // CompressedTextureSubImage3D overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void CompressedTextureSubImage3D(this GL glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.CompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CompressedTextureSubImage3D<T1>(this GL glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.CompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_ptr);
            }
        }

        // TextureParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TextureParameterf(this GL glInstance, TextureHandle texture, TextureParameterName pname, in float param)
        {
            fixed (float* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.TextureParameterfv(texture, pname, param_ptr);
            }
        }

        // TextureParameterIiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TextureParameterIi(this GL glInstance, TextureHandle texture, TextureParameterName pname, in int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.TextureParameterIiv(texture, pname, parameters_ptr);
            }
        }

        // TextureParameterIuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TextureParameterIui(this GL glInstance, TextureHandle texture, TextureParameterName pname, in uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.TextureParameterIuiv(texture, pname, parameters_ptr);
            }
        }

        // TextureParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void TextureParameteri(this GL glInstance, TextureHandle texture, TextureParameterName pname, in int param)
        {
            fixed (int* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.TextureParameteriv(texture, pname, param_ptr);
            }
        }

        // GetTextureImage overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetTextureImage(this GL glInstance, TextureHandle texture, int level, PixelFormat format, PixelType type, int bufSize, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.GetTextureImage(texture, level, format, type, bufSize, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTextureImage<T1>(this GL glInstance, TextureHandle texture, int level, PixelFormat format, PixelType type, int bufSize, ref T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.GetTextureImage(texture, level, format, type, bufSize, pixels_ptr);
            }
        }

        // GetCompressedTextureImage overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetCompressedTextureImage(this GL glInstance, TextureHandle texture, int level, int bufSize, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.GetCompressedTextureImage(texture, level, bufSize, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetCompressedTextureImage<T1>(this GL glInstance, TextureHandle texture, int level, int bufSize, ref T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.GetCompressedTextureImage(texture, level, bufSize, pixels_ptr);
            }
        }

        // GetTextureLevelParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTextureLevelParameterf(this GL glInstance, TextureHandle texture, int level, GetTextureParameter pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTextureLevelParameterfv(texture, level, pname, parameters_ptr);
            }
        }

        // GetTextureLevelParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTextureLevelParameteri(this GL glInstance, TextureHandle texture, int level, GetTextureParameter pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTextureLevelParameteriv(texture, level, pname, parameters_ptr);
            }
        }

        // GetTextureParameterfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTextureParameterf(this GL glInstance, TextureHandle texture, GetTextureParameter pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTextureParameterfv(texture, pname, parameters_ptr);
            }
        }

        // GetTextureParameterIiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTextureParameterIi(this GL glInstance, TextureHandle texture, GetTextureParameter pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTextureParameterIiv(texture, pname, parameters_ptr);
            }
        }

        // GetTextureParameterIuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTextureParameterIui(this GL glInstance, TextureHandle texture, GetTextureParameter pname, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTextureParameterIuiv(texture, pname, parameters_ptr);
            }
        }

        // GetTextureParameteriv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTextureParameteri(this GL glInstance, TextureHandle texture, GetTextureParameter pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetTextureParameteriv(texture, pname, parameters_ptr);
            }
        }

        // CreateVertexArrays overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe VertexArrayHandle CreateVertexArray(this GL glInstance)
        {
            VertexArrayHandle arrays;
            int n = 1;
            Unsafe.SkipInit(out arrays);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            VertexArrayHandle* arrays_handle = (VertexArrayHandle*)Unsafe.AsPointer(ref arrays);
            glInstance.CreateVertexArrays(n, arrays_handle);
            return arrays;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void CreateVertexArray(this GL glInstance, out VertexArrayHandle arrays)
        {
            int n = 1;
            Unsafe.SkipInit(out arrays);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            VertexArrayHandle* arrays_handle = (VertexArrayHandle*)Unsafe.AsPointer(ref arrays);
            glInstance.CreateVertexArrays(n, arrays_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateVertexArrays(this GL glInstance, Span<VertexArrayHandle> arrays)
        {
            var n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays) // SpanOrArrayLayer
            {
                glInstance.CreateVertexArrays(n, arrays_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateVertexArrays(this GL glInstance, VertexArrayHandle[] arrays)
        {
            var n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays) // SpanOrArrayLayer
            {
                glInstance.CreateVertexArrays(n, arrays_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CreateVertexArrays(this GL glInstance, int n, ref VertexArrayHandle arrays)
        {
            fixed (VertexArrayHandle* arrays_ptr = &arrays) // RefInsteadOfPointerLayer
            {
                glInstance.CreateVertexArrays(n, arrays_ptr);
            }
        }

        // VertexArrayVertexBuffers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void VertexArrayVertexBuffers(this GL glInstance, VertexArrayHandle vaobj, uint first, int count, in BufferHandle buffers, in IntPtr offsets, in int strides)
        {
            fixed (BufferHandle* buffers_ptr = &buffers) // RefInsteadOfPointerLayer
            fixed (IntPtr* offsets_ptr = &offsets) // RefInsteadOfPointerLayer
            fixed (int* strides_ptr = &strides) // RefInsteadOfPointerLayer
            {
                glInstance.VertexArrayVertexBuffers(vaobj, first, count, buffers_ptr, offsets_ptr, strides_ptr);
            }
        }

        // VertexArrayAttribFormat overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.BoolOverloader
        public static unsafe void VertexArrayAttribFormat(this GL glInstance, VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset)
        {
            var normalized_byte = (byte)(normalized ? 1 : 0);
            glInstance.VertexArrayAttribFormat(vaobj, attribindex, size, type, normalized_byte, relativeoffset);
        }

        // GetVertexArrayiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetVertexArrayi(this GL glInstance, VertexArrayHandle vaobj, VertexArrayPName pname, ref int param)
        {
            fixed (int* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.GetVertexArrayiv(vaobj, pname, param_ptr);
            }
        }

        // GetVertexArrayIndexediv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetVertexArrayIndexedi(this GL glInstance, VertexArrayHandle vaobj, uint index, VertexArrayPName pname, ref int param)
        {
            fixed (int* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.GetVertexArrayIndexediv(vaobj, index, pname, param_ptr);
            }
        }

        // GetVertexArrayIndexed64iv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetVertexArrayIndexed64iv(this GL glInstance, VertexArrayHandle vaobj, uint index, VertexArrayPName pname, ref long param)
        {
            fixed (long* param_ptr = &param) // RefInsteadOfPointerLayer
            {
                glInstance.GetVertexArrayIndexed64iv(vaobj, index, pname, param_ptr);
            }
        }

        // CreateSamplers overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe SamplerHandle CreateSampler(this GL glInstance)
        {
            SamplerHandle samplers;
            int n = 1;
            Unsafe.SkipInit(out samplers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            SamplerHandle* samplers_handle = (SamplerHandle*)Unsafe.AsPointer(ref samplers);
            glInstance.CreateSamplers(n, samplers_handle);
            return samplers;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void CreateSampler(this GL glInstance, out SamplerHandle samplers)
        {
            int n = 1;
            Unsafe.SkipInit(out samplers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            SamplerHandle* samplers_handle = (SamplerHandle*)Unsafe.AsPointer(ref samplers);
            glInstance.CreateSamplers(n, samplers_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateSamplers(this GL glInstance, Span<SamplerHandle> samplers)
        {
            var n = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers) // SpanOrArrayLayer
            {
                glInstance.CreateSamplers(n, samplers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateSamplers(this GL glInstance, SamplerHandle[] samplers)
        {
            var n = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers) // SpanOrArrayLayer
            {
                glInstance.CreateSamplers(n, samplers_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CreateSamplers(this GL glInstance, int n, ref SamplerHandle samplers)
        {
            fixed (SamplerHandle* samplers_ptr = &samplers) // RefInsteadOfPointerLayer
            {
                glInstance.CreateSamplers(n, samplers_ptr);
            }
        }

        // CreateProgramPipelines overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe ProgramPipelineHandle CreateProgramPipeline(this GL glInstance)
        {
            ProgramPipelineHandle pipelines;
            int n = 1;
            Unsafe.SkipInit(out pipelines);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            ProgramPipelineHandle* pipelines_handle = (ProgramPipelineHandle*)Unsafe.AsPointer(ref pipelines);
            glInstance.CreateProgramPipelines(n, pipelines_handle);
            return pipelines;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void CreateProgramPipeline(this GL glInstance, out ProgramPipelineHandle pipelines)
        {
            int n = 1;
            Unsafe.SkipInit(out pipelines);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            ProgramPipelineHandle* pipelines_handle = (ProgramPipelineHandle*)Unsafe.AsPointer(ref pipelines);
            glInstance.CreateProgramPipelines(n, pipelines_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateProgramPipelines(this GL glInstance, Span<ProgramPipelineHandle> pipelines)
        {
            var n = (int)(pipelines.Length);
            fixed (ProgramPipelineHandle* pipelines_ptr = pipelines) // SpanOrArrayLayer
            {
                glInstance.CreateProgramPipelines(n, pipelines_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateProgramPipelines(this GL glInstance, ProgramPipelineHandle[] pipelines)
        {
            var n = (int)(pipelines.Length);
            fixed (ProgramPipelineHandle* pipelines_ptr = pipelines) // SpanOrArrayLayer
            {
                glInstance.CreateProgramPipelines(n, pipelines_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CreateProgramPipelines(this GL glInstance, int n, ref ProgramPipelineHandle pipelines)
        {
            fixed (ProgramPipelineHandle* pipelines_ptr = &pipelines) // RefInsteadOfPointerLayer
            {
                glInstance.CreateProgramPipelines(n, pipelines_ptr);
            }
        }

        // CreateQueries overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.OutToReturnOverloader
        public static unsafe QueryHandle CreateQuerie(this GL glInstance, QueryTarget target)
        {
            QueryHandle ids;
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            QueryHandle* ids_handle = (QueryHandle*)Unsafe.AsPointer(ref ids);
            glInstance.CreateQueries(target, n, ids_handle);
            return ids;
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.GenCreateAndDeleteOverloader
        public static unsafe void CreateQuerie(this GL glInstance, QueryTarget target, out QueryHandle ids)
        {
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            QueryHandle* ids_handle = (QueryHandle*)Unsafe.AsPointer(ref ids);
            glInstance.CreateQueries(target, n, ids_handle);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateQueries(this GL glInstance, QueryTarget target, Span<QueryHandle> ids)
        {
            var n = (int)(ids.Length);
            fixed (QueryHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.CreateQueries(target, n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void CreateQueries(this GL glInstance, QueryTarget target, QueryHandle[] ids)
        {
            var n = (int)(ids.Length);
            fixed (QueryHandle* ids_ptr = ids) // SpanOrArrayLayer
            {
                glInstance.CreateQueries(target, n, ids_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void CreateQueries(this GL glInstance, QueryTarget target, int n, ref QueryHandle ids)
        {
            fixed (QueryHandle* ids_ptr = &ids) // RefInsteadOfPointerLayer
            {
                glInstance.CreateQueries(target, n, ids_ptr);
            }
        }

        // GetQueryBufferObjecti64v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void GetQueryBufferObjecti64(this GL glInstance, QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset) =>
            glInstance.GetQueryBufferObjecti64v(id, buffer, pname, offset);

        // GetQueryBufferObjectiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void GetQueryBufferObjecti(this GL glInstance, QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset) =>
            glInstance.GetQueryBufferObjectiv(id, buffer, pname, offset);

        // GetQueryBufferObjectui64v overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void GetQueryBufferObjectui64(this GL glInstance, QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset) =>
            glInstance.GetQueryBufferObjectui64v(id, buffer, pname, offset);

        // GetQueryBufferObjectuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.TrimNameOverloader
        public static unsafe void GetQueryBufferObjectui(this GL glInstance, QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset) =>
            glInstance.GetQueryBufferObjectuiv(id, buffer, pname, offset);

        // GetTextureSubImage overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetTextureSubImage(this GL glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, int bufSize, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.GetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetTextureSubImage<T1>(this GL glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, int bufSize, ref T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.GetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels_ptr);
            }
        }

        // GetCompressedTextureSubImage overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetCompressedTextureSubImage(this GL glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.GetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetCompressedTextureSubImage<T1>(this GL glInstance, TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, ref T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.GetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels_ptr);
            }
        }

        // GetnCompressedTexImage overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetnCompressedTexImage(this GL glInstance, TextureTarget target, int lod, int bufSize, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.GetnCompressedTexImage(target, lod, bufSize, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnCompressedTexImage<T1>(this GL glInstance, TextureTarget target, int lod, Span<T1> pixels)
            where T1 : unmanaged
        {
            var bufSize = (int)(pixels.Length * sizeof(T1));
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.GetnCompressedTexImage(target, lod, bufSize, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnCompressedTexImage<T1>(this GL glInstance, TextureTarget target, int lod, T1[] pixels)
            where T1 : unmanaged
        {
            var bufSize = (int)(pixels.Length * sizeof(T1));
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.GetnCompressedTexImage(target, lod, bufSize, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnCompressedTexImage<T1>(this GL glInstance, TextureTarget target, int lod, int bufSize, ref T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.GetnCompressedTexImage(target, lod, bufSize, pixels_ptr);
            }
        }

        // GetnTexImage overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetnTexImage(this GL glInstance, TextureTarget target, int level, PixelFormat format, PixelType type, int bufSize, IntPtr pixels)
        {
            var pixels_vptr = (void*)pixels;
            glInstance.GetnTexImage(target, level, format, type, bufSize, pixels_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnTexImage<T1>(this GL glInstance, TextureTarget target, int level, PixelFormat format, PixelType type, Span<T1> pixels)
            where T1 : unmanaged
        {
            var bufSize = (int)(pixels.Length * sizeof(T1));
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.GetnTexImage(target, level, format, type, bufSize, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnTexImage<T1>(this GL glInstance, TextureTarget target, int level, PixelFormat format, PixelType type, T1[] pixels)
            where T1 : unmanaged
        {
            var bufSize = (int)(pixels.Length * sizeof(T1));
            fixed (void* pixels_ptr = pixels) // SpanOrArrayLayer
            {
                glInstance.GetnTexImage(target, level, format, type, bufSize, pixels_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnTexImage<T1>(this GL glInstance, TextureTarget target, int level, PixelFormat format, PixelType type, int bufSize, ref T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels) // RefInsteadOfPointerLayer
            {
                glInstance.GetnTexImage(target, level, format, type, bufSize, pixels_ptr);
            }
        }

        // GetnUniformdv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformd(this GL glInstance, ProgramHandle program, int location, Span<double> parameters)
        {
            var bufSize = (int)(parameters.Length * 8);
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformdv(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformd(this GL glInstance, ProgramHandle program, int location, double[] parameters)
        {
            var bufSize = (int)(parameters.Length * 8);
            fixed (double* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformdv(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnUniformd(this GL glInstance, ProgramHandle program, int location, int bufSize, ref double parameters)
        {
            fixed (double* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetnUniformdv(program, location, bufSize, parameters_ptr);
            }
        }

        // GetnUniformfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformf(this GL glInstance, ProgramHandle program, int location, Span<float> parameters)
        {
            var bufSize = (int)(parameters.Length * 4);
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformfv(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformf(this GL glInstance, ProgramHandle program, int location, float[] parameters)
        {
            var bufSize = (int)(parameters.Length * 4);
            fixed (float* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformfv(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnUniformf(this GL glInstance, ProgramHandle program, int location, int bufSize, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetnUniformfv(program, location, bufSize, parameters_ptr);
            }
        }

        // GetnUniformiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformi(this GL glInstance, ProgramHandle program, int location, Span<int> parameters)
        {
            var bufSize = (int)(parameters.Length * 4);
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformiv(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformi(this GL glInstance, ProgramHandle program, int location, int[] parameters)
        {
            var bufSize = (int)(parameters.Length * 4);
            fixed (int* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformiv(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnUniformi(this GL glInstance, ProgramHandle program, int location, int bufSize, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetnUniformiv(program, location, bufSize, parameters_ptr);
            }
        }

        // GetnUniformuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformui(this GL glInstance, ProgramHandle program, int location, Span<uint> parameters)
        {
            var bufSize = (int)(parameters.Length * 4);
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformuiv(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnUniformui(this GL glInstance, ProgramHandle program, int location, uint[] parameters)
        {
            var bufSize = (int)(parameters.Length * 4);
            fixed (uint* parameters_ptr = parameters) // SpanOrArrayLayer
            {
                glInstance.GetnUniformuiv(program, location, bufSize, parameters_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnUniformui(this GL glInstance, ProgramHandle program, int location, int bufSize, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters) // RefInsteadOfPointerLayer
            {
                glInstance.GetnUniformuiv(program, location, bufSize, parameters_ptr);
            }
        }

        // ReadnPixels overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void ReadnPixels(this GL glInstance, int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, IntPtr data)
        {
            var data_vptr = (void*)data;
            glInstance.ReadnPixels(x, y, width, height, format, type, bufSize, data_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ReadnPixels<T1>(this GL glInstance, int x, int y, int width, int height, PixelFormat format, PixelType type, Span<T1> data)
            where T1 : unmanaged
        {
            var bufSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.ReadnPixels(x, y, width, height, format, type, bufSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void ReadnPixels<T1>(this GL glInstance, int x, int y, int width, int height, PixelFormat format, PixelType type, T1[] data)
            where T1 : unmanaged
        {
            var bufSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data) // SpanOrArrayLayer
            {
                glInstance.ReadnPixels(x, y, width, height, format, type, bufSize, data_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void ReadnPixels<T1>(this GL glInstance, int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, ref T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data) // RefInsteadOfPointerLayer
            {
                glInstance.ReadnPixels(x, y, width, height, format, type, bufSize, data_ptr);
            }
        }

        // GetnMapdv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnMapd(this GL glInstance, MapTarget target, MapQuery query, int bufSize, Span<double> v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.GetnMapdv(target, query, bufSize, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnMapd(this GL glInstance, MapTarget target, MapQuery query, int bufSize, double[] v)
        {
            fixed (double* v_ptr = v) // SpanOrArrayLayer
            {
                glInstance.GetnMapdv(target, query, bufSize, v_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnMapd(this GL glInstance, MapTarget target, MapQuery query, int bufSize, ref double v)
        {
            fixed (double* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.GetnMapdv(target, query, bufSize, v_ptr);
            }
        }

        // GetnMapfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnMapf(this GL glInstance, MapTarget target, MapQuery query, int bufSize, ref float v)
        {
            fixed (float* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.GetnMapfv(target, query, bufSize, v_ptr);
            }
        }

        // GetnMapiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnMapi(this GL glInstance, MapTarget target, MapQuery query, int bufSize, ref int v)
        {
            fixed (int* v_ptr = &v) // RefInsteadOfPointerLayer
            {
                glInstance.GetnMapiv(target, query, bufSize, v_ptr);
            }
        }

        // GetnPixelMapfv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnPixelMapf(this GL glInstance, PixelMap map, int bufSize, Span<float> values)
        {
            fixed (float* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.GetnPixelMapfv(map, bufSize, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnPixelMapf(this GL glInstance, PixelMap map, int bufSize, float[] values)
        {
            fixed (float* values_ptr = values) // SpanOrArrayLayer
            {
                glInstance.GetnPixelMapfv(map, bufSize, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnPixelMapf(this GL glInstance, PixelMap map, int bufSize, ref float values)
        {
            fixed (float* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                glInstance.GetnPixelMapfv(map, bufSize, values_ptr);
            }
        }

        // GetnPixelMapuiv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnPixelMapui(this GL glInstance, PixelMap map, int bufSize, ref uint values)
        {
            fixed (uint* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                glInstance.GetnPixelMapuiv(map, bufSize, values_ptr);
            }
        }

        // GetnPixelMapusv overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnPixelMap(this GL glInstance, PixelMap map, int bufSize, ref ushort values)
        {
            fixed (ushort* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                glInstance.GetnPixelMapusv(map, bufSize, values_ptr);
            }
        }

        // GetnPolygonStipple overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnPolygonStipple(this GL glInstance, Span<byte> pattern)
        {
            var bufSize = (int)(pattern.Length);
            fixed (byte* pattern_ptr = pattern) // SpanOrArrayLayer
            {
                glInstance.GetnPolygonStipple(bufSize, pattern_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnPolygonStipple(this GL glInstance, byte[] pattern)
        {
            var bufSize = (int)(pattern.Length);
            fixed (byte* pattern_ptr = pattern) // SpanOrArrayLayer
            {
                glInstance.GetnPolygonStipple(bufSize, pattern_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnPolygonStipple(this GL glInstance, int bufSize, ref byte pattern)
        {
            fixed (byte* pattern_ptr = &pattern) // RefInsteadOfPointerLayer
            {
                glInstance.GetnPolygonStipple(bufSize, pattern_ptr);
            }
        }

        // GetnColorTable overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetnColorTable(this GL glInstance, ColorTableTarget target, PixelFormat format, PixelType type, int bufSize, IntPtr table)
        {
            var table_vptr = (void*)table;
            glInstance.GetnColorTable(target, format, type, bufSize, table_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnColorTable<T1>(this GL glInstance, ColorTableTarget target, PixelFormat format, PixelType type, Span<T1> table)
            where T1 : unmanaged
        {
            var bufSize = (int)(table.Length * sizeof(T1));
            fixed (void* table_ptr = table) // SpanOrArrayLayer
            {
                glInstance.GetnColorTable(target, format, type, bufSize, table_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnColorTable<T1>(this GL glInstance, ColorTableTarget target, PixelFormat format, PixelType type, T1[] table)
            where T1 : unmanaged
        {
            var bufSize = (int)(table.Length * sizeof(T1));
            fixed (void* table_ptr = table) // SpanOrArrayLayer
            {
                glInstance.GetnColorTable(target, format, type, bufSize, table_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnColorTable<T1>(this GL glInstance, ColorTableTarget target, PixelFormat format, PixelType type, int bufSize, ref T1 table)
            where T1 : unmanaged
        {
            fixed (void* table_ptr = &table) // RefInsteadOfPointerLayer
            {
                glInstance.GetnColorTable(target, format, type, bufSize, table_ptr);
            }
        }

        // GetnConvolutionFilter overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetnConvolutionFilter(this GL glInstance, ConvolutionTarget target, PixelFormat format, PixelType type, int bufSize, IntPtr image)
        {
            var image_vptr = (void*)image;
            glInstance.GetnConvolutionFilter(target, format, type, bufSize, image_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnConvolutionFilter<T1>(this GL glInstance, ConvolutionTarget target, PixelFormat format, PixelType type, Span<T1> image)
            where T1 : unmanaged
        {
            var bufSize = (int)(image.Length * sizeof(T1));
            fixed (void* image_ptr = image) // SpanOrArrayLayer
            {
                glInstance.GetnConvolutionFilter(target, format, type, bufSize, image_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnConvolutionFilter<T1>(this GL glInstance, ConvolutionTarget target, PixelFormat format, PixelType type, T1[] image)
            where T1 : unmanaged
        {
            var bufSize = (int)(image.Length * sizeof(T1));
            fixed (void* image_ptr = image) // SpanOrArrayLayer
            {
                glInstance.GetnConvolutionFilter(target, format, type, bufSize, image_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnConvolutionFilter<T1>(this GL glInstance, ConvolutionTarget target, PixelFormat format, PixelType type, int bufSize, ref T1 image)
            where T1 : unmanaged
        {
            fixed (void* image_ptr = &image) // RefInsteadOfPointerLayer
            {
                glInstance.GetnConvolutionFilter(target, format, type, bufSize, image_ptr);
            }
        }

        // GetnSeparableFilter overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetnSeparableFilter(this GL glInstance, SeparableTarget target, PixelFormat format, PixelType type, int rowBufSize, IntPtr row, int columnBufSize, IntPtr column, IntPtr span)
        {
            var row_vptr = (void*)row;
            var column_vptr = (void*)column;
            var span_vptr = (void*)span;
            glInstance.GetnSeparableFilter(target, format, type, rowBufSize, row_vptr, columnBufSize, column_vptr, span_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnSeparableFilter<T1, T2, T3>(this GL glInstance, SeparableTarget target, PixelFormat format, PixelType type, Span<T3> row, Span<T2> column, Span<T1> span)
            where T1 : unmanaged
            where T2 : unmanaged
            where T3 : unmanaged
        {
            var rowBufSize = (int)(row.Length * sizeof(T3));
            fixed (void* row_ptr = row) // SpanOrArrayLayer
            {
                var columnBufSize = (int)(column.Length * sizeof(T2));
                fixed (void* column_ptr = column) // SpanOrArrayLayer
                {
                    fixed (void* span_ptr = span) // SpanOrArrayLayer
                    {
                        glInstance.GetnSeparableFilter(target, format, type, rowBufSize, row_ptr, columnBufSize, column_ptr, span_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnSeparableFilter<T1, T2, T3>(this GL glInstance, SeparableTarget target, PixelFormat format, PixelType type, T3[] row, T2[] column, T1[] span)
            where T1 : unmanaged
            where T2 : unmanaged
            where T3 : unmanaged
        {
            var rowBufSize = (int)(row.Length * sizeof(T3));
            fixed (void* row_ptr = row) // SpanOrArrayLayer
            {
                var columnBufSize = (int)(column.Length * sizeof(T2));
                fixed (void* column_ptr = column) // SpanOrArrayLayer
                {
                    fixed (void* span_ptr = span) // SpanOrArrayLayer
                    {
                        glInstance.GetnSeparableFilter(target, format, type, rowBufSize, row_ptr, columnBufSize, column_ptr, span_ptr);
                    }
                }
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnSeparableFilter<T1, T2, T3>(this GL glInstance, SeparableTarget target, PixelFormat format, PixelType type, int rowBufSize, ref T1 row, int columnBufSize, ref T2 column, ref T3 span)
            where T1 : unmanaged
            where T2 : unmanaged
            where T3 : unmanaged
        {
            fixed (void* row_ptr = &row) // RefInsteadOfPointerLayer
            fixed (void* column_ptr = &column) // RefInsteadOfPointerLayer
            fixed (void* span_ptr = &span) // RefInsteadOfPointerLayer
            {
                glInstance.GetnSeparableFilter(target, format, type, rowBufSize, row_ptr, columnBufSize, column_ptr, span_ptr);
            }
        }

        // GetnHistogram overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetnHistogram(this GL glInstance, HistogramTarget target, bool reset, PixelFormat format, PixelType type, int bufSize, IntPtr values)
        {
            var values_vptr = (void*)values;
            var reset_byte = (byte)(reset ? 1 : 0);
            glInstance.GetnHistogram(target, reset_byte, format, type, bufSize, values_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnHistogram<T1>(this GL glInstance, HistogramTarget target, bool reset, PixelFormat format, PixelType type, Span<T1> values)
            where T1 : unmanaged
        {
            var bufSize = (int)(values.Length * sizeof(T1));
            fixed (void* values_ptr = values) // SpanOrArrayLayer
            {
                var reset_byte = (byte)(reset ? 1 : 0);
                glInstance.GetnHistogram(target, reset_byte, format, type, bufSize, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnHistogram<T1>(this GL glInstance, HistogramTarget target, bool reset, PixelFormat format, PixelType type, T1[] values)
            where T1 : unmanaged
        {
            var bufSize = (int)(values.Length * sizeof(T1));
            fixed (void* values_ptr = values) // SpanOrArrayLayer
            {
                var reset_byte = (byte)(reset ? 1 : 0);
                glInstance.GetnHistogram(target, reset_byte, format, type, bufSize, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnHistogram<T1>(this GL glInstance, HistogramTarget target, bool reset, PixelFormat format, PixelType type, int bufSize, ref T1 values)
            where T1 : unmanaged
        {
            fixed (void* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                var reset_byte = (byte)(reset ? 1 : 0);
                glInstance.GetnHistogram(target, reset_byte, format, type, bufSize, values_ptr);
            }
        }

        // GetnMinmax overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void GetnMinmax(this GL glInstance, MinmaxTarget target, bool reset, PixelFormat format, PixelType type, int bufSize, IntPtr values)
        {
            var values_vptr = (void*)values;
            var reset_byte = (byte)(reset ? 1 : 0);
            glInstance.GetnMinmax(target, reset_byte, format, type, bufSize, values_vptr);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnMinmax<T1>(this GL glInstance, MinmaxTarget target, bool reset, PixelFormat format, PixelType type, Span<T1> values)
            where T1 : unmanaged
        {
            var bufSize = (int)(values.Length * sizeof(T1));
            fixed (void* values_ptr = values) // SpanOrArrayLayer
            {
                var reset_byte = (byte)(reset ? 1 : 0);
                glInstance.GetnMinmax(target, reset_byte, format, type, bufSize, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.SpanAndArrayOverloader
        public static unsafe void GetnMinmax<T1>(this GL glInstance, MinmaxTarget target, bool reset, PixelFormat format, PixelType type, T1[] values)
            where T1 : unmanaged
        {
            var bufSize = (int)(values.Length * sizeof(T1));
            fixed (void* values_ptr = values) // SpanOrArrayLayer
            {
                var reset_byte = (byte)(reset ? 1 : 0);
                glInstance.GetnMinmax(target, reset_byte, format, type, bufSize, values_ptr);
            }
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void GetnMinmax<T1>(this GL glInstance, MinmaxTarget target, bool reset, PixelFormat format, PixelType type, int bufSize, ref T1 values)
            where T1 : unmanaged
        {
            fixed (void* values_ptr = &values) // RefInsteadOfPointerLayer
            {
                var reset_byte = (byte)(reset ? 1 : 0);
                glInstance.GetnMinmax(target, reset_byte, format, type, bufSize, values_ptr);
            }
        }

        // SpecializeShader overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void SpecializeShader(this GL glInstance, ShaderHandle shader, string pEntryPoint, uint numSpecializationConstants, in uint pConstantIndex, in uint pConstantValue)
        {
            fixed (uint* pConstantIndex_ptr = &pConstantIndex) // RefInsteadOfPointerLayer
            fixed (uint* pConstantValue_ptr = &pConstantValue) // RefInsteadOfPointerLayer
            {
                byte* pEntryPoint_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(pEntryPoint);
                glInstance.SpecializeShader(shader, pEntryPoint_ptr, numSpecializationConstants, pConstantIndex_ptr, pConstantValue_ptr);
                Marshal.FreeCoTaskMem((IntPtr)pEntryPoint_ptr);
            }
        }

        // MultiDrawArraysIndirectCount overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void MultiDrawArraysIndirectCount(this GL glInstance, PrimitiveType mode, IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride)
        {
            var indirect_vptr = (void*)indirect;
            glInstance.MultiDrawArraysIndirectCount(mode, indirect_vptr, drawcount, maxdrawcount, stride);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiDrawArraysIndirectCount<T1>(this GL glInstance, PrimitiveType mode, in T1 indirect, IntPtr drawcount, int maxdrawcount, int stride)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = &indirect) // RefInsteadOfPointerLayer
            {
                glInstance.MultiDrawArraysIndirectCount(mode, indirect_ptr, drawcount, maxdrawcount, stride);
            }
        }

        // MultiDrawElementsIndirectCount overloads

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.VoidPtrToIntPtrOverloader
        public static unsafe void MultiDrawElementsIndirectCount(this GL glInstance, PrimitiveType mode, DrawElementsType type, IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride)
        {
            var indirect_vptr = (void*)indirect;
            glInstance.MultiDrawElementsIndirectCount(mode, type, indirect_vptr, drawcount, maxdrawcount, stride);
        }

        // Generated by Gwi.OpenGL.BindingGenerator.Parsing.RefInsteadOfPointerOverloader
        public static unsafe void MultiDrawElementsIndirectCount<T1>(this GL glInstance, PrimitiveType mode, DrawElementsType type, in T1 indirect, IntPtr drawcount, int maxdrawcount, int stride)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = &indirect) // RefInsteadOfPointerLayer
            {
                glInstance.MultiDrawElementsIndirectCount(mode, type, indirect_ptr, drawcount, maxdrawcount, stride);
            }
        }
    }

#pragma warning restore IDE1006 // Naming Styles
}
